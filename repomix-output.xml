This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursorrules
.gitignore
.repomixignore
eslint.config.js
ideas.md
index.html
package.json
postcss.config.mjs
prisma/schema.prisma
PROJECT_CONTEXT.md
README.md
redis.conf
scripts/bundleServer.ts
scripts/clearServerRequests.ts
scripts/generateServerRequests.ts
server/auth/checkOrigin.ts
server/auth/login.ts
server/auth/loginConfig.ts
server/dev/hotReload.ts
server/dev/loader.ts
server/dev/request.py
server/functions/boardcaster.ts
server/functions/db.ts
server/functions/game.ts
server/functions/redis.ts
server/functions/session.ts
server/functions/sleep.ts
server/functions/tryCatch.ts
server/prod/generatedApis.ts
server/prod/serveFile.ts
server/server.ts
server/sockets/handleApiRequest.ts
server/sockets/handleSyncRequest.ts
server/sockets/socket.ts
server/sockets/utils/activityBroadcaster.ts
server/sockets/utils/logout.ts
server/sockets/utils/onLocationChange.ts
server/utils/console.log.ts
server/utils/getParams.ts
server/utils/repl.ts
server/utils/serveAvatars.ts
src/_components/Avatar.tsx
src/_components/AvatarProvider.tsx
src/_components/ConfirmMenu.tsx
src/_components/Dropdown.tsx
src/_components/Icon.tsx
src/_components/InputDialog.tsx
src/_components/LocationProvider.tsx
src/_components/LoginForm.tsx
src/_components/MenuHandler.tsx
src/_components/Middleware.tsx
src/_components/Navbar.tsx
src/_components/Router.tsx
src/_components/TemplateProvider.tsx
src/_components/ThemeToggler.tsx
src/_components/Tooltip.tsx
src/_components/TranslationProvider.tsx
src/_functions/confetti.ts
src/_functions/icon.ts
src/_functions/menuHandler.ts
src/_functions/middlewareHandler.ts
src/_functions/notify.ts
src/_functions/sleep.ts
src/_functions/translator.ts
src/_functions/tryCatch.ts
src/_locales/de.json
src/_locales/en.json
src/_locales/fr.json
src/_locales/nl.json
src/_providers/SessionProvider.tsx
src/_providers/socketStatusProvider.tsx
src/_sockets/apiRequest.ts
src/_sockets/socketInitializer.ts
src/_sockets/syncRequest.ts
src/home/page.tsx
src/index.css
src/login/page.tsx
src/main.tsx
src/NoteEditor.css
src/page.tsx
src/register/page.tsx
src/sandbox/_components/drawing/DrawingLayer.tsx
src/sandbox/_components/drawing/DrawingSideMenu.tsx
src/sandbox/_components/drawing/DrawingTopMenu.tsx
src/sandbox/_components/editor/BaseCodeEditor.tsx
src/sandbox/_components/editor/BuilderMenu.tsx
src/sandbox/_components/editor/CodeEditor.tsx
src/sandbox/_components/editor/CodeMirrorEditor.tsx
src/sandbox/_components/editor/Editor.tsx
src/sandbox/_components/files/File.tsx
src/sandbox/_components/files/Render.tsx
src/sandbox/_components/grid/ErrorBoundary.tsx
src/sandbox/_components/grid/Grid.tsx
src/sandbox/_components/grid/ScreenRenderer.tsx
src/sandbox/_components/menus/BottomLeftMenu.tsx
src/sandbox/_components/menus/CreateComponentMenu.tsx
src/sandbox/_components/menus/NoteOptionsMenu.tsx
src/sandbox/_components/notes/CodeBlockComponent.tsx
src/sandbox/_components/notes/Note.tsx
src/sandbox/_components/notes/NoteEditor.tsx
src/sandbox/_functions/codeEditor/autocompletions/autocompletionHandler.ts
src/sandbox/_functions/codeEditor/autocompletions/customComponents.ts
src/sandbox/_functions/codeEditor/autocompletions/JSX.ts
src/sandbox/_functions/codeEditor/autocompletions/reactHooks.ts
src/sandbox/_functions/codeEditor/babel/compiler.ts
src/sandbox/_functions/codeEditor/compilerOptions.ts
src/sandbox/_functions/codeEditor/hoverTooltip.ts
src/sandbox/_functions/codeEditor/tailwindcss/autoSuggestion.ts
src/sandbox/_functions/codeEditor/tailwindcss/classDetector.ts
src/sandbox/_functions/codeEditor/tailwindcss/color.js
src/sandbox/_functions/codeEditor/tailwindcss/inlineColorIcon.ts
src/sandbox/_functions/codeEditor/tailwindcss/tailwindcss.ts
src/sandbox/_functions/codeEditor/themes/onig.wasm
src/sandbox/_functions/codeEditor/themes/textmate/theme-converter.ts
src/sandbox/_functions/codeEditor/themes/textmate/tm-to-monaco-token.ts
src/sandbox/_functions/codeEditor/themes/textmate/wireTmGrammars.ts
src/sandbox/_functions/codeEditor/themes/themes.ts
src/sandbox/_functions/codeEditor/themes/trae_dark_color.json
src/sandbox/_functions/codeEditor/themes/trae_dark_plus.json
src/sandbox/_functions/codeEditor/traverseClickedComponent.ts
src/sandbox/_functions/drawing/clientToWorld.ts
src/sandbox/_functions/drawing/clipUtils.ts
src/sandbox/_functions/drawing/eraseStroke.ts
src/sandbox/_functions/drawing/exportUtils.ts
src/sandbox/_functions/drawing/generateShapePoints.ts
src/sandbox/_functions/drawing/getSvgPathFromStroke.ts
src/sandbox/_functions/drawing/RenderDrawingPath.tsx
src/sandbox/_functions/drawing/selectionUtils.ts
src/sandbox/_functions/drawing/sharedUtils.ts
src/sandbox/_functions/drawing/snappingUtils.ts
src/sandbox/_functions/drawing/useDrawingEvents.ts
src/sandbox/_functions/drawing/useKeyboardShortcuts.ts
src/sandbox/_functions/files/babelUtils.ts
src/sandbox/_functions/files/fileUtils.ts
src/sandbox/_functions/grid/onFileDrop.ts
src/sandbox/_functions/grid/onMouseDown.ts
src/sandbox/_functions/grid/onMouseLeave.ts
src/sandbox/_functions/grid/onMouseMove.ts
src/sandbox/_functions/grid/onMouseUp.ts
src/sandbox/_functions/grid/onMouseWheel.ts
src/sandbox/_functions/grid/useGridKeyboardShortcuts.ts
src/sandbox/_functions/notes/getCaretPosition.ts
src/sandbox/_functions/notes/handleCaretPosition.ts
src/sandbox/_functions/notes/PlaceholderPerLine.ts
src/sandbox/_providers/BlueprintsContextProvider.tsx
src/sandbox/_providers/BuilderPanelContextProvider.tsx
src/sandbox/_providers/CodeContextProvider.tsx
src/sandbox/_providers/DrawingContextProvider.tsx
src/sandbox/_providers/GridContextProvider.tsx
src/sandbox/_providers/MenusContextProvider.tsx
src/sandbox/_providers/NotesContextProvider.tsx
src/sandbox/page.tsx
src/sandbox/types/blueprints.ts
src/sandbox/types/createComponentMenuTypes.ts
src/sandbox/types/gridProps.ts
src/sandbox/types/NotesOptionsTypes.ts
src/sandbox/types/react-jsx-runtime.d.ts
src/sandbox/types/viewportMapping.ts
src/scrollbar-dark.css
src/scrollbar-white.css
src/settings/_api/updateUser.ts
src/settings/page.tsx
src/test/_api/testApi.ts
src/test/_sync/updateCounter_client.ts
src/test/_sync/updateCounter_server.ts
src/test/page.tsx
src/types/react-hooks.d.ts
src/types/react-jsx-runtime.d.ts
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.server.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursorrules">
# Cursor AI Project Rules

You have access to valid project context in the following files. You should prioritize reading these files to understand the project structure, configuration, and current state before proposing changes or answering complex questions:

1. **`repomix-output.xml`**: Contains a comprehensive dump or summary of the codebase. Check this for overall code patterns and existing implementation.
2. **`PROJECT_CONTEXT.md`**: Contains high-level architecture documentation, terminology, and design decisions. useful for "big picture" understanding.
3. **`config.ts`**: Contains the main application configuration constants and types.
4. **`.env`**: Contains environment variables and active configuration settings.

## Behavior
- When starting a significant task, always check `PROJECT_CONTEXT.md` first.
- If you need to understand the broader codebase without searching every file, `repomix-output.xml` is a good source.
- Verify configuration values in `config.ts` and `.env` when debugging or adding features.

## Context Update Rule (IMPORTANT)
**After every code change, you MUST:**
1. **Update `PROJECT_CONTEXT.md`** - Document any new files, functions, patterns, or behavior changes you've made. Keep the documentation in sync with the codebase.
2. **Regenerate `repomix-output.xml`** - Run `npx repomix` to regenerate the codebase summary with your changes.

This ensures future AI sessions have accurate context about the current state of the codebase.
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

.env
node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

config.ts
config

uploads/**
</file>

<file path=".repomixignore">
# Exclude dependencies and builds
node_modules/
dist/
build/
.next/
public/

# Exclude large data/config files
package-lock.json
yarn.lock
*.svg
*.png

# Exclude logs and temp files
*.log
.env*

src/sandbox/_functions/codeEditor/themes/TypeScriptReact.tmLanguage.json
src/sandbox/types/react.d.ts
src/types/react/index.d.ts
public/themes/trae_dark.json
src/sandbox/_functions/codeEditor/themes/trae_dark_vs.json
src/sandbox/_functions/codeEditor/tailwindcss/classes.js
src/sandbox/types/react-dom.d.ts
src/types/react-dom.d.ts
src/sandbox/types/react-global.d.ts
src/types/react/global.d.ts
envTemplate.txt
configTemplate.txt
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import reactX from 'eslint-plugin-react-x' // Import react-x plugin
// No need to import react-dom here

export default tseslint.config(
  { ignores: ['dist'] },
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Replace ...tseslint.configs.recommended with this for strict type checking
      ...tseslint.configs.strictTypeChecked,
      // Optionally add stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // From eslint-plugin-react-x
      js.configs.recommended,
      tseslint.configs.recommended,
      reactX.configs.recommended, // Add react-x plugin's recommended configuration
      // No need to add react-dom.configs.recommended again, it's redundant
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
      // Removed react-x from plugins since it's already handled by extends
      // Removed react-dom here since it's already handled by extends
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
      // You can add specific custom rules for react-x or react-dom here if necessary
    },
  },
  {
    files: [
      'src/**/*api/**/*.ts', 
      'src/**/*Api/**/*.ts', 
      'src/**/*sync/**/*.ts',
      'src/**/*Sync/**/*.ts'
    ],
    rules: {
      '@typescript-eslint/no-unused-vars': 'off',
    },
  }
)
//npx eslint src/**/*.tsx
// ctrl + shift + p -> Restart TS server
</file>

<file path="ideas.md">
diagram builder - [
  <!-- use case diagram ( look at PlantUML vscode extensions, idea is to make this but we force alot of values from dropdowns and make a 2d grid and give everything a location so that we can use AI to make them. example being we have a boilerplate text wich you need to paste in ai and based on this info the ai can generate a UCD and we can import it and edit it easily)
  description at the bottom or next to the diagram
  img export
  ...other diagrams -->
  Types of diagrams:
    Use Case Diagram (UCD)
    Flowchart
    Class Diagram
    Entity-Relationship Diagram (ERD)

  Features:
    Force certain values via dropdowns to keep data structured (good for AI generation later)
    Auto-arrange items on the 2D grid, but allow manual repositioning
    Add descriptions at the bottom or side of each diagram element
    Export: PNG, SVG, PDF
    AI integration: Provide boilerplate text or prompts → AI generates diagram nodes/edges
    Element styles: color coding for types of elements (actors, systems, processes, etc.)
    Templates: pre-made diagram templates for common cases

  Possible enhancements:
    Version history for diagrams
    Comments/annotations on each node
    Import diagrams from PlantUML or other standard formats
]

User Story - [
  <!-- simple table with 3 columns where they go like
  "As USER" | "I wanna be able to FUNCTIONALITY" | "Because REASON"
  As a teacher | I wanna be able to see student results | because i wanna be able to monitor them

  the default values like "As", "I wanna be able to FUNCTIONALITY" and "Because REASON" you can change cause they are in a input field but just the default values -->
  Columns:
    Default: As [USER] | I want to [FUNCTIONALITY] | Because [REASON]
    Optional columns
  Features:
    Inline editing of cells
    Add/remove rows dynamically
    Drag & drop rows for ordering
    Default values auto-populate, but editable
    Highlight incomplete stories or missing fields
  Enhancements:
    Filter by user role or priority
    Export to CSV, Markdown, or PDF
    Link user stories to requirements or diagrams for traceability
]

requirements report - [
  simple table with columns you can enable/disable
  X amount of questions so that you can ask yourself does this requirement fulfill these questions
]

Columns: Requirement ID, Description, Status, Priority, Assigned To, Compliance Check (Y/N), Notes

Features:

Enable/disable columns dynamically

Add checklist questions for each requirement (e.g., “Does it have measurable acceptance criteria?”)

Highlight requirements that don’t meet certain criteria

Export options: PDF, CSV

Enhancements:

AI suggestions for missing or incomplete requirements

Versioning/history of requirement changes

Tags for categories or features

notes - [
  simple notes,
  sorted list,
  unsorted list

  changable font sizes
  changable text color
]

drawing - [
  draw freely,
  change size,
  change color,
  erase,
  change erase size
]

code blocks - [

]





geidentificeerd
grammaticaal correct
atomain (moet aan 1 eis voldoen dus niet (authentication system: login and register system (FOUT)))
geen verboden woorden (Expensive, cheap, quick, easy (heeft een andere betekenis in ieder zijn oog, voor anja is 100 euro duur en voor john is 300 euro goedkoop))
geen ontwerpaspecten
uniform gedefineerd
meetbaar
onderling consistent
geprioriteerd
eigenaar
geaccepteerd
tracebaar (waar gebruikt)
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="./favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- <script src="https://unpkg.com/react-scan/dist/auto.global.js"></script> -->
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div class="w-full h-svh m-0 p-0" id="root"></div>
    <div 
      class="w-full h-svh m-0 p-0 absolute top-0 pointer-events-none overflow-hidden" id="portalRoot"
      style="z-index: 999999999;"
    ></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="postcss.config.mjs">
export default {
    plugins: {
        "@tailwindcss/postcss": {},
    }
}
</file>

<file path="README.md">
Self made tech stack.

https://lucky23.gitbook.io/luckystack/
</file>

<file path="redis.conf">
appendonly yes          # Enable AOF persistence
appendfsync everysec    # Sync every write operation to disk every second
</file>

<file path="scripts/bundleServer.ts">
import { build } from "esbuild";
import { dependencies } from "../package.json";

const externalDeps = [
  ...Object.keys(dependencies || {}),
  // Native Node.js modules
  "fs", "path", "url", "os", "child_process", "crypto"
];

await build({
  entryPoints: ["server/server.ts"], // Adjust if entry is different
  outfile: "dist/server.js",         // Final bundled output
  bundle: true,
  platform: "node",
  target: "node22",                  // Match your runtime (Node 18, 20 etc.)
  format: "esm",                     // Your project uses "type": "module"
  sourcemap: true,
  external: externalDeps,
  logLevel: "info",
}).catch((e) => {
  console.error("Build failed:", e);
  process.exit(1);
});
</file>

<file path="scripts/clearServerRequests.ts">
//? used when running npm run dev
//? in dev mode we dont need the production apis and syncs so we clear them to avoid it erroring when e.g. changing file names

import fs from "fs";

let apiMap = "export const apis: Record<string, { auth: any, main: any }> = { };\n";
let syncMap = "export const syncs: Record<string, { main: any, auth: Record<string, any> }> | any = { };\n";
let functionsMap = "export const functions: Record<string, any> = { };";

const output = `${apiMap}\n${syncMap}\n${functionsMap}`;

fs.writeFileSync("./server/prod/generatedApis.ts", output);
// console.log("✅ server/prod/generatedApis.ts Cleared");
</file>

<file path="scripts/generateServerRequests.ts">
import fs from "fs";
import path from "path";

const normalizePath = (p: string) => p.split(path.sep).join("/");

// Recursively walk dirs to collect _api and _sync files
const walkSrcFiles = (dir: string, results: string[] = []) => {
  const list = fs.readdirSync(dir);
  for (const file of list) {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      walkSrcFiles(fullPath, results);
    } else if (file.endsWith(".ts") && (fullPath.includes("_api") || fullPath.includes("_sync"))) {
      // if (file.endsWith("_client.ts")) continue; // skip client stubs
      results.push(fullPath);
    }
  }
  return results;
};

// Collect server function files
const walkFunctionFiles = (dir: string) => {
  if (!fs.existsSync(dir)) return [];
  return fs
    .readdirSync(dir)
    .filter((file) => file.endsWith(".ts"))
    .map((file) => normalizePath(path.join(dir, file)));
};

// --------------------
// Collect files
// --------------------
const rawSrcFiles = walkSrcFiles("./src").map(normalizePath).sort();
const functionFiles = walkFunctionFiles("./server/functions").sort();

// --------------------
// Buckets
// --------------------
const apiImports: string[] = [];
const syncImports: string[] = [];
const functionImports: string[] = [];

let apiMap = "export const apis: Record<string, { auth: any, main: any }> = {\n";
let syncMap = "export const syncs: Record<string, { main: any, auth: Record<string, any> }> | any = {\n";
let functionsMap = "export const functions: Record<string, any> = {\n";

let apiCount = 0;
let syncCount = 0;
let fnCount = 0;

// --------------------
// Process API + Sync
// --------------------
rawSrcFiles.forEach((normalized) => {
  const importPath = "../../" + normalized.replace(/\.ts$/, "");

  // API
  if (normalized.includes("_api/")) {
    const varName = `api${apiCount++}`;
    apiImports.push(`import * as ${varName} from '${importPath}';`);

    // capture "games/boerZoektVrouw" and "getGameData"
    const match = normalized.match(/src\/(.+?)\/_api\/(.+)\.ts$/i);
    if (!match) return;
    const [_, pagePath, apiName] = match;
    const routeKey = `api/${pagePath}/${apiName}`; // clean route-like key

    apiMap += `  "${routeKey}": {\n    auth: "auth" in ${varName} ? ${varName}.auth : {},\n    main: ${varName}.main,\n  },\n`;
  }

  // Sync
  if (normalized.includes("_sync/")) {
    const match = normalized.match(/src\/(.+?)\/_sync\/(.+)\.ts$/i);
    if (!match) return;
    const [_, pagePath, syncName] = match;
    const routeKey = `sync/${pagePath}/${syncName}`;
  
    console.log(syncName)
    if (syncName.endsWith("_client")) {
      const varName = `syncClient${syncCount++}`;
      syncImports.push(`import * as ${varName} from '${importPath}';`);
      syncMap += `  "${routeKey}": ${varName}.main,\n`;
    }
  
    if (syncName.endsWith("_server")) {
      const varName = `syncServer${syncCount++}`;
      syncImports.push(`import * as ${varName} from '${importPath}';`);
      syncMap += `  "${routeKey}": { auth: "auth" in ${varName} ? ${varName}.auth : {}, main: ${varName}.main },\n`;
    }
  }
});

// --------------------
// Process Functions
// --------------------
functionFiles.forEach((filePath) => {
  const importPath = "../../" + filePath.replace(/\.ts$/, "");
  const varName = `fn${fnCount++}`;
  functionImports.push(`import * as ${varName} from '${importPath}';`);
  functionsMap += `  ...${varName},\n`;
});

// --------------------
// Close Maps
// --------------------
apiMap += "};\n";
syncMap += "};\n";
functionsMap += "};";

// --------------------
// Final Output
// --------------------
const importStatements = [
  ...apiImports,
  "",
  ...syncImports,
  "",
  ...functionImports,
].join("\n");

const output = `${importStatements}\n\n${apiMap}\n${syncMap}\n${functionsMap}`;

fs.writeFileSync("./server/prod/generatedApis.ts", output);
console.log("✅ server/prod/generatedApis.ts created");
</file>

<file path="server/auth/checkOrigin.ts">
const allowedOrigin = (origin: string) => {
  const location = `http${process.env.SECURE == 'true'?'s' : ''}://${process.env.SERVER_IP}:${process.env.SERVER_PORT}/`;
  const formattedOrigin = origin.includes('://') ? origin : `http${process.env.SECURE == 'true' ? 's' : ''}://${origin}/`;
    
  //? we check if the origin of the user is allowed to access the server directly
  if (location == formattedOrigin) { return true; } 
  if (origin == 'localhost') { return true; }

  //? if the origin is not allowed we check if the origin is allowed we port 80 or port 443 cause the browser removes these sometimes

  const externalOrigins = process.env.EXTERNAL_ORIGINS?.split(',') || [];
  for (const externalOrigin of externalOrigins) {
    if (origin == externalOrigin) { return true; }
    if (origin == externalOrigin+'/') { return true; }
  }

  if (origin == process.env.DNS) { return true; }
  if (origin == process.env.DNS+'/') { return true; }
  if (!origin.startsWith('http://') && !origin.startsWith('https://')) {
    // origin = 'https://' + origin;
    if (`http${process.env.SECURE ? 's' : ''}://${origin}` == `${process.env.DNS}`) { return true; }
    if (`http${process.env.SECURE ? 's' : ''}://${origin}` == `${process.env.DNS}/`) { return true; }
  }

  console.log('')
  console.log('origin not allowed')
  console.log('origin:', origin)
  console.log('formattedOrigin:', formattedOrigin)
  console.log('dns:', process.env.DNS)
  console.log('dns:', process.env.DNS+'/')
  for (const externalOrigin of externalOrigins) {
    console.log('externalOrigin:', externalOrigin)
    console.log('externalOrigin:', externalOrigin+'/')
  }
  return false;
}

export default allowedOrigin;
</file>

<file path="server/auth/login.ts">
import dotenv from 'dotenv';
import oauthProviders from "./loginConfig";
import { IncomingMessage, ServerResponse } from 'http';
import { URLSearchParams } from 'url';
import { tryCatch } from '../functions/tryCatch';
import { prisma } from '../functions/db';
import { Prisma, PROVIDERS } from '@prisma/client';
import bcrypt from 'bcrypt';
import { randomBytes } from 'crypto';
import { saveSession } from "../functions/session"
import validator from "validator"
import config, { SessionLayout } from '../../config';
import path from 'path';
import { existsSync } from 'fs';

dotenv.config();

type paramsType = {
  email?: string,
  password?: string,
  name?: string,
  confirmPassword?: string,
}

const uploadsFolder = path.join(process.cwd(), "uploads");

// Route that starts the OAuth flow for the specified provider and redirects to the callback endpoint
const loginWithCredentials = async (params: paramsType) => {

  const email = validator.escape(params.email || '');
  const password = validator.escape(params.password || '');
  const name = params.name ? validator.escape(params.name) : undefined;
  const confirmPassword = params. confirmPassword ? validator.escape(params.confirmPassword) : undefined;

  console.log(name, email, password, confirmPassword)
  
  if (!email || !password) { return { status: false, reason: 'login.empty' }; }
  if (email.length > 191) { return { status: false, reason: 'login.emailCharacterLimit' }; }
  if (password.length < 8) { return { status: false, reason: 'login.passwordCharacterMinimum' }; }
  if (password.length > 191) { return { status: false, reason: 'login.passwordCharacterLimit' }; }
  if (name && name.length > 191) { return { status: false, reason: 'login.nameCharacterLimit' }; }
  if (!validator.isEmail(email)) { return { status: false, reason: 'login.invalidEmailFormat' }; }

  if (name && confirmPassword) { //? register
    if (password != confirmPassword) { return { status: false, reason: 'login.passwordNotMatch' }; }

    const checkEmail = async () => {
      return await prisma.user.findFirst({
        where: {
          email: email,
          provider: PROVIDERS.credentials
        },
      })
    }

    //? check if email already exists
    const [checkEmailError, checkEmailResponse] = await tryCatch(checkEmail);
    if (checkEmailError) { 
      console.log(checkEmailError);
      return { status: false, reason: checkEmailError }; 
    }
    if (checkEmailResponse) { return { status: false, reason: 'login.emailExist' }; }

    //? email is not in use so we define the function to create the new user
    const createNewUser = async () => {
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
      return await prisma.user.create({
        data: {
          email: email,
          provider: PROVIDERS.credentials,
          name: name,
          password: hashedPassword,
          avatar: '',
          admin: false,
          language: config.defaultLanguage
        }
      }) 
    }

    //? here we create the new user
    const [createNewUserError, createNewUserResponse] = await tryCatch(createNewUser);
    if (createNewUserError) { return { status: false, reason: createNewUserError }; }
    if (createNewUserResponse) { return { status: true, reason: 'login.userCreated', session: createNewUserResponse }; }
    return { status: false, reason: 'login.createUserFailed' };

  } else { //? login
    //? here we define the function to find the user
    const findUser = async () => {
      return await prisma.user.findFirst({
        where: {
          email: email,
          provider: PROVIDERS.credentials
        }
      }) 
    }

    //? attempt to find the user
    const [findUserError, findUserResponse] = await tryCatch(findUser);
    if (findUserError) { 
      console.log(findUserError, ' findUserError');
      return { status: false, reason: findUserError }; 
    }
    if (!findUserResponse) { return { status: false, reason: 'login.userNotFound' }; }

    //? if we found a user we check if the password matches the hashed one in the db
    const checkPassword = async () => { return await bcrypt.compare(password, findUserResponse.password as string); }
    const [checkPasswordError, checkPasswordResponse] = await tryCatch(checkPassword);
    if (checkPasswordError) { 
      console.log(checkPasswordError, ' checkPasswordError');
      return { status: false, reason: checkPasswordError }; 
    }
    if (!checkPasswordResponse) { return { status: false, reason: 'login.wrongPassword' }; }

    //? if the password matches we return the user
    if (checkPasswordResponse) {
      const newToken = randomBytes(32).toString("hex")
      const newUser = { 
        id: findUserResponse.id,
        name: findUserResponse.name,
        provider: 'credentials',
        email: findUserResponse.email,
        createdAt: findUserResponse.createdAt,
        updatedAt: findUserResponse.updatedAt,
        token: newToken,
        avatar: findUserResponse.avatar || '',
        avatarFallback: `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, "0")}`,
        admin: findUserResponse.admin,
        language: findUserResponse.language,
        theme: findUserResponse.theme
      };

      const filePath = path.join(uploadsFolder, `${newUser.id}.webp`);
      if (existsSync(filePath)) {
        newUser.avatar = `${newUser.id}.webp`;
      }

      await saveSession(newToken, newUser, true);
      console.log(newUser);
      return { status: true, reason: 'login.loggedIn', newToken, session: newUser };
    }
  }
}

// Route that handles the callback from the OAuth provider
const loginCallback = async (pathname: string, req: IncomingMessage, res: ServerResponse) => {
  //? check if provider exists
  const providerName = pathname.split('/')[3]; // Extract the provider (google/github)
  const provider = oauthProviders.find(p => p.name === providerName);
  if (!provider || !req.url) { return false }
  if (!('clientID' in provider)) { return }

  const queryString = req.url.split('?')[1]; // Get the part after '?'
  const params = new URLSearchParams(queryString);
  const code = params.get('code');

  //? if no code provided in the url we return false (the code is used to get the access token and should be provided by the oauth provider)
  if (!code || code == '') { 
    console.log('no code provided in callback url')
    return false 
  }

  const values = {
    code,
    client_id: provider.clientID,
    client_secret: provider.clientSecret,
    redirect_uri: provider.callbackURL,
    grant_type: 'authorization_code'
  }

  //? with the code we can get the access token
  const getToken = async () => {
    if (provider.tokenExchangeMethod == 'json') {
      const url = provider.tokenExchangeURL;
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify(values),
      })
      return await response.json();
    } else if (provider.tokenExchangeMethod == 'form') {
      const url = provider.tokenExchangeURL;
      const params = new URLSearchParams();
      params.append('client_id', provider.clientID);
      params.append('client_secret', provider.clientSecret);
      params.append('code', values.code);
      params.append('grant_type', 'authorization_code');
      params.append('redirect_uri', provider.callbackURL);
    
      console.log(params)
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Accept': 'application/json'
        },
        body: params.toString()
      });
    
      return await response.json();
    }
  }

  const [getTokenError, getTokenResponse] = await tryCatch(getToken)
  if (getTokenError) {
    console.log(getTokenError, 'getTokenError');
    return false;
  }

  //? here we get the access token
  const { access_token, id_token } = getTokenResponse;
  const getUserData = async () => {
    // const url = `${provider.userInfoURL}?alt=json&access_token=${access_token}`;
    const url = provider.userInfoURL;
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': `Bearer ${access_token}`
      },
    })
    return await response.json();
  }

  //? with the access_token token we get the user data 
  const [getUserDataError, getUserDataResponse] = await tryCatch(getUserData);
  if (getUserDataError) {
    console.log(getUserDataError);
    return false;
  }

  const name: string = getUserDataResponse[provider.nameKey] || 'didnt find a name'

  let email: string | undefined = getUserDataResponse[provider.emailKey];
  const avatar: string = 
    provider?.avatarKey ? getUserDataResponse[provider.avatarKey] : 
    provider.getAvatar ? provider.getAvatar({userData: getUserDataResponse, avatarId: getUserDataResponse[provider.avatarCodeKey]}) : '';

  console.log(avatar)
  // const user = {
  //   id: '',
  //   name,
  //   provider: provider.name,
  //   email,
  //   createdAt: new Date(),
  //   updatedAt: new Date(),
  //   token: '',
  //   avatar,
  //   admin: false,
  //   language: config.defaultLanguage
  // }

  //? if we didnt find the email we try to get it with a external link if this one is provided
  if (!email && provider.getEmail) {
    const selectedEmail = await provider.getEmail(access_token);
    
    if (!selectedEmail) {
      console.log('no email found');
      return false; 
    }

    email = selectedEmail;
  }

  let tempUser: SessionLayout | undefined;
  if (email) {
    const fetchUser = async () => {
      return await prisma.user.findFirst({
        where: {
          email: email,
          provider: provider.name as PROVIDERS
        }
      })
    } 

    //? here we check if the user exists in the db
    const [userDataError, userDataResponse] = await tryCatch(fetchUser);
    if (userDataError) {
      console.log(userDataError);
      return false;
    }

    console.log('ASDSADASDDASDA')
    //? if the user exists we assign it to the tempUser variable
    if (userDataResponse?.id) { 
      const { password, ...safeData } = userDataResponse;
      const filePath = path.join(uploadsFolder, `${safeData.id}.webp`);
      if (existsSync(filePath)) {
        safeData.avatar = `${safeData.id}.webp`;
      }

      tempUser = {
        ...safeData, 
        avatarFallback: 
        `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, "0")}`,
        token: '' 
      }; 
    }

    //? if the user doesnt exist we create a new one
    if (!tempUser) {
      const createNewUser = async () => {
        if (!email) { return false; }
        return await prisma.user.create({
          data: {
            email,
            provider: provider.name as PROVIDERS,
            name,
            avatar,
            language: config.defaultLanguage
          }
        })
      }
      const [createNewUserError, createNewUserResponse] = await tryCatch(createNewUser);
      if (createNewUserError) {
        console.log(createNewUserError);
        return false;
      }

      if (createNewUserResponse) { 
        const { password,...safeData } = createNewUserResponse;
        tempUser = {
          ...safeData, 
          avatarFallback: `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, "0")}`,
          token: ''
        }; 
      }
    }
  }

  if (!tempUser) {
    return false;
  }

  //? here we create a new token, create the users session and return the token as a sign of success
  const newToken = randomBytes(32).toString("hex")
  // user.id = tempUser.id;
  // user.createdAt = tempUser.createdAt;
  // user.updatedAt = tempUser.updatedAt;
  // user.token = newToken;
  // user.admin = tempUser.admin
  // user.language = config.defaultLanguage;
  // if (tempUser.avatar) { user.avatar = tempUser.avatar; }


  tempUser.token = newToken;
  await saveSession(newToken, tempUser, true);
  console.log(tempUser)
  return newToken;
}

export { loginWithCredentials, loginCallback }
</file>

<file path="server/auth/loginConfig.ts">
import dotenv from 'dotenv';
import { tryCatch } from '../functions/tryCatch';

dotenv.config(); // Load environment variables from .env file

interface BasicProvider {
  name: string;
}

interface FullProvider {
  name: string,
  clientID: string,
  clientSecret: string,
  callbackURL: string,
  authorizationURL: string,
  tokenExchangeURL: string,
  tokenExchangeMethod: 'json' | 'form',
  userInfoURL: string,
  scope: string[],
  getEmail?: (access_token: string) => Promise<string | false | undefined>,
  nameKey: string,
  emailKey: string, 

  avatarKey?: string, //? the avatarKey represent the url to the img
  avatarCodeKey: string, //? the avatarCodeKey should be the key representing the avatar id if the provider doesnt give the avatar url directly, we use the getAvatar function with this value together
  getAvatar?: ({userData, avatarId}: {userData: Record<string, any>, avatarId: string}) => any
}

type oauthProvidersProps = | BasicProvider | (Required<FullProvider>); 

// const backendUrl = `http${process.env.SECURE == 'true' ? 's' : ''}://${process.env.SERVER_IP}:${process.env.SERVER_PORT}`;
const prod = process.env.NODE_ENV !== 'development';
const backendUrl = process.env.NODE_ENV == 'development' 
  ? `http${process.env.SECURE == 'true' ? 's' : ''}://${process.env.SERVER_IP}:${process.env.SERVER_PORT}`
  : process.env.DNS
  
const oauthProviders: oauthProvidersProps[] = [
  {
    name: 'credentials',
  },
  {
    name: 'google',
    clientID: prod ?  process.env.GOOGLE_CLIENT_ID : process.env.DEV_GOOGLE_CLIENT_ID,
    clientSecret: prod ?  process.env.GOOGLE_CLIENT_SECRET : process.env.DEV_GOOGLE_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/google`,
    authorizationURL: 'https://accounts.google.com/o/oauth2/v2/auth',
    tokenExchangeURL: 'https://oauth2.googleapis.com/token',
    tokenExchangeMethod: 'json',
    userInfoURL: 'https://www.googleapis.com/oauth2/v1/userinfo',
    scope: [
      "https://www.googleapis.com/auth/userinfo.profile",
      "https://www.googleapis.com/auth/userinfo.email"
    ],
    nameKey: 'name',
    emailKey: 'email',
    avatarKey: 'picture'
  },
  {
    name: 'github',
    clientID: prod ?  process.env.GITHUB_CLIENT_ID : process.env.DEV_GITHUB_CLIENT_ID,
    clientSecret: prod ?  process.env.GITHUB_CLIENT_SECRET : process.env.DEV_GITHUB_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/github`,
    authorizationURL: 'https://github.com/login/oauth/authorize',
    tokenExchangeURL: 'https://github.com/login/oauth/access_token',
    tokenExchangeMethod: 'json',
    userInfoURL: 'https://api.github.com/user',
    scope: ['read:user', 'user:email'],
    nameKey: 'login',
    emailKey: 'email',
    avatarKey: 'avatar_url',
    getEmail: async (access_token: string) => {
      const getEmail = async () => {
        const url = 'https://api.github.com/user/emails';
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${access_token}`
          },
        })
        return await response.json(); 
      }
  
      const [getEmailError, getEmailResponse] = await tryCatch(getEmail);
      if (getEmailError) {
        console.log(getEmailError);
        return false;
      }
  
      //? if we found the email we set it to the user object
      let mainEmail: string | undefined;
      for (const email of getEmailResponse) {
        if (email.primary) { mainEmail = email.email; }
      }
      if (!mainEmail) { mainEmail = getEmailResponse?.[0]?.email; }
      return mainEmail;
    },
  },
  {
    name: 'discord',
    clientID: prod ?  process.env.DISCORD_CLIENT_ID : process.env.DEV_DISCORD_CLIENT_ID,
    clientSecret: prod ?  process.env.DISCORD_CLIENT_SECRET : process.env.DEV_DISCORD_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/discord`,
    authorizationURL: 'https://discord.com/oauth2/authorize',
    tokenExchangeURL: 'https://discord.com/api/oauth2/token',
    tokenExchangeMethod: 'form',
    userInfoURL: 'https://discord.com/api/users/@me',
    scope: [
      "identify",
      'email',
    ],
    nameKey: 'username',
    emailKey: 'email',
    avatarCodeKey: 'avatar',
    getAvatar: ({userData, avatarId}: {userData: Record<string, any>, avatarId: string}) => {
      if (!avatarId) {
        // Default avatar (based on discriminator % 5)
        // const defaultAvatarIndex = userId % 5;
        // return `https://cdn.discordapp.com/embed/avatars/${defaultAvatarIndex}.png`;
        return undefined;
      }
      const userId = userData.id;
      const format = avatarId.startsWith("a_") ? "gif" : "png";
      return `https://cdn.discordapp.com/avatars/${userId}/${avatarId}.${format}`;
    }
  },
  {
    name: 'facebook',
    clientID: prod ?  process.env.FACEBOOK_CLIENT_ID : process.env.DEV_FACEBOOK_CLIENT_ID,
    clientSecret: prod ?  process.env.FACEBOOK_CLIENT_SECRET : process.env.DEV_FACEBOOK_CLIENT_SECRET,
    callbackURL: `${backendUrl}/auth/callback/facebook`,
    authorizationURL: 'https://www.facebook.com/v10.0/dialog/oauth',
    tokenExchangeURL: 'https://graph.facebook.com/v10.0/oauth/access_token',
    tokenExchangeMethod: 'form',
    userInfoURL: 'https://graph.facebook.com/me?fields=id,name,email,picture.type(large)',
    scope: ['public_profile', 'email'],
    nameKey: 'name',
    emailKey: 'email',
    getAvatar: ({userData}: {userData: Record<string, any>}) => {
      return userData?.picture?.data?.url || undefined;
    }
  },
];

export default oauthProviders;
</file>

<file path="server/dev/hotReload.ts">
import chokidar from "chokidar";
import { initializeApis, initializeFunctions, initializeSyncs } from "./loader";

// ----------------------------
// Watcher for Hot Reload
// ----------------------------
export const setupWatchers = () => {
  if (process.env.NODE_ENV !== "development") return;

  const handleChange = (path: string) => {
    const normalizedPath = path.replace(/\\/g, '/');

    if (normalizedPath.includes('api/')) {
      console.log(`[Watcher] Reloading API due to change in: ${normalizedPath}`);
      initializeApis();
    } else if (normalizedPath.includes('sync/')) {
      console.log(`[Watcher] Reloading Sync due to change in: ${normalizedPath}`);
      initializeSyncs();
    }
  };

  const handleFunctionChange = (path: string) => {
    console.log(`[Watcher] Reloading Function due to change in: ${path.replace(/\\/g, '/')}`);
    initializeFunctions();
  };

  // Watch the main source folders
  chokidar.watch('src', { ignoreInitial: true })
    .on('add', handleChange)
    .on('change', handleChange);

  // Watch functions separately
  chokidar.watch('server/functions', { ignoreInitial: true })
    .on('add', handleFunctionChange)
    .on('change', handleFunctionChange);
};
</file>

<file path="server/dev/loader.ts">
import fs from "fs";
import path from "path";
import { pathToFileURL } from "url";
import { tryCatch } from "../functions/tryCatch";

// ----------------------------
// Storage for loaded modules
// ----------------------------
export const devApis: Record<string, any> = {};
export const devSyncs: Record<string, any> = {};
export const devFunctions: Record<string, any> = {};

// ----------------------------
// Unified Initialization
// ----------------------------
export const initializeAll = async () => {
  await Promise.all([initializeApis(), initializeSyncs(), initializeFunctions()]);
  console.log(devApis)
  console.log(devSyncs)
  console.log("DEV modules initialized.");
  // console.log(devFunctions)
};

// ----------------------------
// Helper: convert absolute path to proper file URL for import
// ----------------------------
const importFile = async (absolutePath: string) => {
  const url = pathToFileURL(absolutePath).href;
  return import(`${url}?update=${Date.now()}`);
};

// ----------------------------
// API Loader
// ----------------------------
export const initializeApis = async () => {
  Object.keys(devApis).forEach(k => delete devApis[k]);
  const srcFolder = fs.readdirSync(path.resolve("./src"));

  for (const file of srcFolder) {
    await scanApiFolder(file);
  }
};

const scanApiFolder = async (file: string, basePath = "") => {
  const fullPath = path.join("./src", basePath, file);
  if (!fs.statSync(fullPath).isDirectory()) return;

  if (file.toLowerCase().endsWith("api")) {
    const files = fs.readdirSync(fullPath);
    for (const f of files) {
      if (!f.endsWith(".ts")) continue;

      const modulePath = path.join(fullPath, f);
      const [err, module] = await tryCatch(async () => importFile(modulePath));
      if (err) continue;

      const { auth = {}, main } = module;
      if (!main || typeof main !== "function") continue;

      // const pageLocation = modulePath.split(`/${file}/`)[0].replace(/^src[\/\\]/, "");
      let pageLocation = path
        .join(basePath, file)
        .replace(/^src[\/\\]/, '')
        .replace(/\\/g, '/')
        .split("/api")[0];

      const lastSlash = pageLocation.lastIndexOf('/');
      if (lastSlash !== -1) {
        pageLocation = pageLocation.substring(0, lastSlash);
      }

      devApis[`api/${pageLocation}/${f.replace(".ts", "")}`] = {
        main,
        auth: {
          login: auth.login || false,
          additional: auth.additional || [],
        },
      };
    }
  } else {
    const subFolders = fs.readdirSync(fullPath);
    for (const sub of subFolders) {
      await scanApiFolder(sub, path.join(basePath, file));
    }
  }
};

// ----------------------------
// Sync Loader
// ----------------------------
export const initializeSyncs = async () => {
  Object.keys(devSyncs).forEach(k => delete devSyncs[k]);
  const srcFolder = fs.readdirSync(path.resolve("./src"));

  for (const file of srcFolder) {
    await scanSyncFolder(file);
  }
};

const scanSyncFolder = async (file: string, basePath = "") => {
  const fullPath = path.join("./src", basePath, file);
  if (!fs.statSync(fullPath).isDirectory()) return;

  if (file.toLowerCase().endsWith("sync")) {
    const files = fs.readdirSync(fullPath);
    for (const f of files) {
      if (!f.endsWith("_client.ts") && !f.endsWith("_server.ts")) { continue; }

      const filePath = path.join(fullPath, f);
      const [fileError, fileResult] = await tryCatch(async () => importFile(filePath));

      if (fileError) { continue; }

      // build the route key similar to API routes
      let pageLocation = path
        .join(basePath, file)
        .replace(/^src[\/\\]/, '')
        .replace(/\\/g, '/')
        .split('/sync')[0];

      // remove last segment
      const lastSlash = pageLocation.lastIndexOf('/');
      if (lastSlash !== -1) {
        pageLocation = pageLocation.substring(0, lastSlash);
      }

      if (f.endsWith("_server.ts")) {
        devSyncs[`sync/${pageLocation}/${f.replace(".ts", "")}`] = { 
          main: fileResult.main, 
          auth: fileResult.auth || {} 
        };
      } else {
        devSyncs[`sync/${pageLocation}/${f.replace(".ts", "")}`] = fileResult.main;
      }

      // // optional _server.ts
      // const serverFile = f.replace("_client.ts", "_server.ts");
      // const serverPath = path.join(fullPath, serverFile);

      // if (fs.existsSync(serverPath)) {
      //   const [errServer, serverModule] = await tryCatch(async () => importFile(serverPath));
      //   if (!errServer && typeof serverModule.main === "function") {
      //     // final key style: sync/games/boerZoektVrouw/getCards
      //     devSyncs[`sync/${pageLocation}/${f.replace("_client.ts", "_server")}`] = { main: serverModule.main, auth: serverModule.auth || {} };
      //   }
      // }


    }
  } else {
    const subFolders = fs.readdirSync(fullPath);
    for (const sub of subFolders) {
      await scanSyncFolder(sub, path.join(basePath, file));
    }
  }
};

// ----------------------------
// Functions Loader
// ----------------------------
export const initializeFunctions = async () => {
  Object.keys(devFunctions).forEach(k => delete devFunctions[k]);
  const functionsFolder = fs.readdirSync(path.resolve("./server/functions"));

  for (const file of functionsFolder) {
    const filePath = path.join("./server/functions", file);
    if (!fs.statSync(filePath).isFile() || !file.endsWith(".ts")) continue;

    const [err, module] = await tryCatch(async () => importFile(filePath));
    if (err) continue;


    Object.assign(devFunctions, module);
  }
};
</file>

<file path="server/dev/request.py">
import requests

url = "http://192.168.178.68:80"
data = {"name": "mike", "age": 18}

response = requests.get(url, json=data)

print("Status Code:", response.status_code)
print("Response:", response.text)
</file>

<file path="server/functions/boardcaster.ts">
import { ioInstance } from "../../server/sockets/socket"
import { getSession } from "./session";

export default async function boardcaster({
  code,
  event,
  session,
  data,
  ignoreSelf
}: {
  code: string,
  event: string,
  session?: boolean,
  data?: any,
  ignoreSelf?: string
}) {
  const io = ioInstance;
  if (!io) { return; }

  const sockets = io.sockets.adapter.rooms.get(code);
  if (!sockets) { return; }

  
  for (const socketId of sockets || []) {
    const tempSocket = io.sockets.sockets.get(socketId as string);
    if (!tempSocket) { continue; }

    if (ignoreSelf || session) {
      
      const tempCookie = tempSocket.handshake.headers.cookie; // get the cookie from the socket connection
      const tempSessionToken = tempSocket.handshake.auth?.token
      const tempToken = tempCookie && process.env.VITE_SESSION_BASED_TOKEN === 'false' ? tempCookie.split("=")[1] 
        : tempSessionToken && process.env.VITE_SESSION_BASED_TOKEN === 'true' ? tempSessionToken
        : null; 

      if (ignoreSelf == tempToken) { 
        console.log(' skipping self emit ');
        continue; 
      } //? we dont send the event to the client who called the event


      if (!tempToken) { continue; }
      const sessionData = await getSession(tempToken);

      tempSocket.emit(event, { ...data, session: sessionData });

    } else {
      tempSocket.emit(event, { ...data });
    }
  }
  
}
</file>

<file path="server/functions/db.ts">
import { PrismaClient } from '@prisma/client'

const globalForPrisma = global as unknown as { prisma: PrismaClient | undefined }

export const prisma = globalForPrisma.prisma || new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
</file>

<file path="server/functions/game.ts">
import redis from "./redis";

export interface GameDataProps {
  players: { 
    id: string, 
    name: string, 
    avatar: string,
    role: 'farmer' | 'queen' | 'manipulator' | null,
    selected?: boolean
  }[],
  gameCode: string,
  queenRoles: number,
  manipulatorRoles: number,
  currentCountdownId: number,
  state: 'lobby' | 'loadingScreen' | 'started' | 'finished',
  loadingScreenState: 'roulette' | 'focusFarmer' | 'focusPersonalCard' | null;
  selectedRewards: { [key: string]: string[] },
  availableRewards: {
    name: string,
    id: string
  }[],
  lives: number,
  maxLives: number,
  gameStartTime: number | null,
  totalDrinkTime: number,
  won: 'farmer' | 'player' | 'none' | false,
  revealed: { 
    id: string, 
    role: 'queen' | 'manipulator'
  }[],
}


const saveGameData = async (gameCode: string, data: GameDataProps) => {
  // console.log(gameCode)
  // console.log(data)
  await redis.set(`${process.env.PROJECT_NAME}-games:${gameCode}`, JSON.stringify(data));
  await redis.expire(`${process.env.PROJECT_NAME}-games:${gameCode}`, 60 * 60 * 24 * 7); // same TTL as session or adjust
  return true;
};

const getGameData = async (gameCode: string) => {
  const data = await redis.get(`${process.env.PROJECT_NAME}-games:${gameCode}`);
  return data ? JSON.parse(data) as GameDataProps : null;
};

const getAllGameDatas = async () => {
  const allGameDatas = await redis.keys("*");
  const GameDatas = await Promise.all(allGameDatas.map((gameData) => redis.get(gameData)));
  return GameDatas.map((gameData) => JSON.parse(gameData || "{}")); 
}


const deleteGameData = async (gameCode: string) => {
  await redis.del(`${process.env.PROJECT_NAME}-games:${gameCode}`);
  return true;
};

const gameExists = async (gameCode: string): Promise<boolean> => {
  const exists = await redis.exists(`${process.env.PROJECT_NAME}-games:${gameCode}`);
  return exists === 1;
};

export { saveGameData, getGameData, getAllGameDatas, deleteGameData, gameExists  };
</file>

<file path="server/functions/redis.ts">
import Redis from 'ioredis';
import dotenv from 'dotenv';

dotenv.config(); 

//? here we create a Redis instance
const redis = new Redis({
  host: process.env.REDIS_HOST as string,
  port: parseInt(process.env.REDIS_PORT as string),
});

redis.on('connect', async () => {
  console.log('Connected to Redis');

  if (process.env.NODE_ENV == 'development') { return; }

  const prefix = `${process.env.PROJECT_NAME}-games:`;
  await clearKeysWithPrefix(prefix);
});

redis.on('error', (err) => {
  console.error('Error connecting to Redis:', err);
});

async function clearKeysWithPrefix(prefix: string) {
  let cursor = '0';
  do {
    const [nextCursor, keys] = await redis.scan(cursor, 'MATCH', `${prefix}*`, 'COUNT', 100);
    cursor = nextCursor;
    if (keys.length > 0) {
      // delete keys in bulk
      await redis.del(...keys);
      console.log(`Deleted Redis keys: ${keys.join(', ')}`);
    }
  } while (cursor !== '0');
}

export default redis;
</file>

<file path="server/functions/session.ts">
import type { SessionLayout } from "config";
import redis from "./redis";
// import { logout } from "../sockets/utils/logout";

const saveSession = async (token: string, data: SessionLayout, newUser?: boolean) => {
  await redis.set(`${process.env.PROJECT_NAME}-session:${token}`, JSON.stringify(data));
  await redis.expire(`${process.env.PROJECT_NAME}-session:${token}`, 60 * 60 * 24 * 7); //? 7 days

  const { ioInstance } = await import('../sockets/socket');

  const io = ioInstance;
  if (!io) { return false; } //? if this fails we are fucked but it should never fail

  if (newUser) { //? new user is true when someone logs in
    const userId = data?.id;
    if (!userId) return;

    const tokensOfPreviousUsersKey = `${process.env.PROJECT_NAME}-activeUsers:${userId}`
    const tokensOfPreviousUsers = await redis.smembers(tokensOfPreviousUsersKey);

    const { logout } = await import('../sockets/utils/logout');

    await Promise.all(tokensOfPreviousUsers.map(async (tokenOfPreviousUser) => {
      const sockets = io.sockets.adapter.rooms.get(tokenOfPreviousUser); // Set of socket IDs
      if (sockets) { //? if we found a client it means the user is still connected
        console.log('remving old session data from sockets', 'green')
        for (const socketId of sockets) {
          const socket = io.sockets.sockets.get(socketId);
          if (socket) {
            await logout({ token: tokenOfPreviousUser, socket, userId });
          }
        }
      } else {
        //? if we didnt find any clients it means the user is not connected, we can just delete there session data
        await redis.del(`${process.env.PROJECT_NAME}-session:${tokenOfPreviousUser}`);
        await redis.srem(tokensOfPreviousUsersKey, tokenOfPreviousUser);
      }
    }));

    await redis.sadd(tokensOfPreviousUsersKey, token);
    await redis.expire(tokensOfPreviousUsersKey, 60 * 60 * 24 * 7); //? 7 days
  }

  if (io.sockets.adapter.rooms.has(token)) {
    io.to(token).emit('updateSession', JSON.stringify(data));
  }
};

const getSession = async (token: string | null) => {
  if (!token) return {};
  const session = await redis.get(`${process.env.PROJECT_NAME}-session:${token}`);
  if (!session) { return {} };
  const formattedSession = JSON.parse(session);
  if (!formattedSession) { return {} };
  return {...formattedSession, token: token};
};

const deleteSession = async (token: string) => {
  const user = await redis.get(`${process.env.PROJECT_NAME}-session:${token}`);

  if (user) {
    const userId = JSON.parse(user)?.id;
    if (userId) {
      const tokensOfPreviousUsers = `${process.env.PROJECT_NAME}-activeUsers:${userId}`;
      const { ioInstance } = await import('../sockets/socket');
      // ioInstance?.to(token).emit('forceLogout');
      if (ioInstance?.sockets.adapter.rooms.has(token)) {
        ioInstance.to(token).emit('forceLogout');
      }

      await redis.srem(tokensOfPreviousUsers, token);
    }
  }

  await redis.del(`${process.env.PROJECT_NAME}-session:${token}`);
  return true;
};

const getAllSessions = async () => {
  const sessions = await redis.keys(`${process.env.PROJECT_NAME}-session:*`);
  const sessionData = await Promise.all(sessions.map((session) => redis.get(session)));
  return sessionData.map((session) => JSON.parse(session || "{}")); 
}

// const clearAllSessions = async () => {
//   const sessions = await redis.keys("*");
//   await Promise.all(sessions.map((session) => redis.del(session)));
//   return true; 
// }

export { saveSession, getSession, deleteSession, getAllSessions };
</file>

<file path="server/functions/sleep.ts">
export default function sleep(ms: number) {
  return new Promise<void>((resolve) => setTimeout(resolve, ms));
}
</file>

<file path="server/functions/tryCatch.ts">
const tryCatch = async <T, P>(func: (values: P) => Promise<T> | T, params?: P): Promise<[any, T | null]> => {
  try {
    const response = await func(params as P);
    return [null, response];
  } catch (error) {
    return [error, null];
  }
}

export { tryCatch }
</file>

<file path="server/prod/generatedApis.ts">
export const apis: Record<string, { auth: any, main: any }> = { };

export const syncs: Record<string, { main: any, auth: Record<string, any> }> | any = { };

export const functions: Record<string, any> = { };
</file>

<file path="server/prod/serveFile.ts">
import fs from "fs";
import { IncomingMessage, ServerResponse } from "http";
import path from "path";
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootFolder = path.join(__dirname, '../dist');

export const serveFavicon = (res: ServerResponse) => {
  //? here we get the favicon.ico file from the public folder and serve it to the client
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const faviconPath = path.join(__dirname, '../public', 'favicon.ico');
  res.writeHead(200, { 'Content-Type': 'image/x-icon' });
  fs.createReadStream(faviconPath).pipe(res); 
}

export const serveFile = async (req: IncomingMessage | { url: string }, res: ServerResponse) => {

  //? if request is / (root) we serve the index.html 
  const url = !req.url ? 'index.html' : req.url == '/' ? 'index.html' : req.url;
  const safePath = path.normalize(decodeURIComponent(url)).replace(/^(\.\.[\/\\])+/, '');
  let filePath = path.join(rootFolder, safePath);

  console.log(filePath)
  console.log(rootFolder)

  if (!filePath.startsWith(rootFolder)) {
    //! here we avoid directory traversal attacks
    res.writeHead(403, { "Content-Type": "text/plain" });
    return res.end("Forbidden");
  }

  //? here we check if the file extension or just the filename is in the list of files we dont want to serve
  //? a file that is in the list below should not be able to run this function in the first place cause we filter the routePath using zod before calling this function
  //? but if it passes somehow, we avoid it being served
  if (filePath.includes('.env') || 
      filePath.includes('.ts') || 
      filePath.includes('.tsx') || 
      filePath.includes('.py') || 
      filePath.includes('package.json') || 
      filePath.includes('package-lock.json') || 
      filePath.includes('.gitignore') || 
      filePath.includes('eslint.config.js') || 
      filePath.includes('postcss.config.mjs') || 
      filePath.includes('README.md') || 
      filePath.includes('redis.conf') || 
      filePath.includes('tailwind.config.js') || 
      filePath.includes('tsconfig.app.json') || 
      filePath.includes('tsconfig.json') || 
      filePath.includes('tsconfig.node.json') || 
      filePath.includes('vite.config.ts') || 
      filePath.includes('schema.prisma')
  ) {
    return res.end("Forbidden");
  }
  

  const extname = path.extname(filePath);
  let contentType = 'text/html';

  //? here we get the content type of the file and serve it to the client
  //? if the file extension is not in the list below, we serve the index.html file
  switch (extname) {
    case '.css': contentType = 'text/css'; break;
    case '.js': contentType = 'text/javascript'; break;
    case '.json': contentType = 'application/json'; break;
    case '.png': contentType = 'image/png'; break;
    case '.jpg':
    case '.jpeg': contentType = 'image/jpeg'; break;
    case '.gif': contentType = 'image/gif'; break;
    case '.svg': contentType = 'image/svg+xml'; break;
    case '.ico': contentType = 'image/x-icon'; break;
    default:
      contentType = 'text/html';
      filePath = path.join(rootFolder, 'index.html');
  }

  try {
    //? attempt to read the file and serve it to the client
    const content = await fs.promises.readFile(filePath);
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.writeHead(200, { 'Content-Type': contentType });
    res.end(content);
  } catch (err) {
    if (url == 'index.html') {
      res.end("-_- you have to run the 'npm run build' command first -_-")
    } else {
      res.writeHead(404, { "Content-Type": "text/plain" });
      res.end("Not Found");
    }
  }
};
</file>

<file path="server/server.ts">
import dotenv from 'dotenv';
dotenv.config();
import http from 'http';
import getParams from './utils/getParams';
import { loginWithCredentials, loginCallback } from './auth/login';
import { serveFavicon, serveFile } from './prod/serveFile';
import loadSocket from './sockets/socket';
import z from 'zod';
import oauthProviders from "./auth/loginConfig";
import { deleteSession } from './functions/session';
import allowedOrigin from './auth/checkOrigin';
import { SessionLayout } from '../config';
import { initializeAll } from './dev/loader';
import { setupWatchers } from './dev/hotReload';
import { initConsolelog } from './utils/console.log';
import { initRepl } from './utils/repl';
import { serveAvatar } from './utils/serveAvatars';

const ServerRequest = async (req: http.IncomingMessage, res: http.ServerResponse) => {

  const origin = req.headers.origin || req.headers.referer || req.headers.host || '';

  if (!allowedOrigin(origin)) {
    res.statusCode = 403;
    res.setHeader('Content-Type', 'text/plain');
    return res.end('Forbidden');
  }
  
  res.setHeader("Access-Control-Allow-Origin", origin);
  res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
  res.setHeader("Access-Control-Allow-Credentials", "true");
  res.setHeader('Referrer-Policy', 'no-referrer'); // prevents the browser from leaking sensative urls
  res.setHeader('X-Frame-Options', 'SAMEORIGIN'); // only allows iframes to use this pages content if on the same domain
  res.setHeader('X-XSS-Protection', '1; mode=block'); // prevents some xss attacks
  res.setHeader('X-Content-Type-Options', 'nosniff'); // prevents mimetype sniffing, this means that when sending a txt file it will not try to execute it as ddl if the user requested this

  if (req.method === "OPTIONS") {
    res.writeHead(204);
    return res.end();
  }

  const method = req.method;
  const url = req.url || '/';
  const [routePath, queryString] = url.split('?');

  if (method !== 'GET' && method != 'POST' && method != 'PUT' && method != 'DELETE') {
    res.statusCode = 404;
    res.setHeader('Content-Type', 'text/plain');
    return res.end(`method: ${method} not supported, use one of the following methods: GET, POST, PUT, DELETE`);
  }

  const cookieHeader = req.headers.cookie || '';
  const token = cookieHeader
    .split('; ')
    .find(row => row.startsWith('token='))
    ?.split('=')[1];


  //? here we load the application icon
  if (z.literal('/favicon.ico').safeParse(routePath).success) {
    return serveFavicon(res);
  }

  //? here we get the params from the request
  let params: object | null;
  params = await getParams({ method, req, res, queryString });

  //? we log the request and if there are any params we log them with the request
  if (params && typeof params == 'object' && Object.keys(params).length !== 0) { 
    console.log(`method: ${method}, url: ${routePath}, params: ${JSON.stringify(params)}`, 'magenta') 
  } else { 
    console.log(`method: ${method}, url: ${routePath}`, 'magenta'); 
    params = {}; 
  }

  //? we dont use zod cause it doesnt allow you to pass in a id in the url
  // if (z.literal('/uploads/').safeParse(routePath).success) {
  if (routePath.startsWith('/uploads/')) {
    await serveAvatar({ routePath, res });
    return;
  }
    
  //? triggers when logging in
  //? when using the credentials provider all the logic happends here else we redirect to the oauth provider and all the logic happends in the auth/callback api
  if (z.string().startsWith('/auth/api').safeParse(routePath).success) {
    const providerName = routePath.split('/')[3]; // Extract the provider (google/github)
    const provider = oauthProviders.find(p => p.name === providerName);
    if (!provider || !provider.name) { return { provider, status: false, reason: 'login.providerNotFound' }; }

    if (provider?.name != 'credentials' && 'scope' in provider) {
      res.writeHead(302, {
        'Location': `${provider.authorizationURL}?client_id=${provider.clientID}&redirect_uri=${provider.callbackURL}&scope=${provider.scope.join('%20')}&response_type=code&prompt=select_account`,
      });
      return res.end(); 
    }

    //? here all the logic happends for login or creating an account with credentials
    const { status, reason, newToken, session } = await loginWithCredentials(params) as {
      status: boolean,
      reason: string,
      newToken: string | null,
      session: SessionLayout | undefined
    }

    //? if it failed to either login or creating an account then we return
    if (!status) {
      res.setHeader("content-type", "application/json; charset=utf-8");
      return res.end(JSON.stringify({ status, reason: reason || 'internal server error' }));
    }

    //? if it was successful then we apply the cookie and return the user id and reason for the login or account creation
    if (newToken) { 
      if (token) { await deleteSession(token); }

      console.log('setting cookie with newToken: ', newToken, 'green');
      // const cookieOptions = process.env.NODE_ENV == "development" ? 
      //   "HttpOnly; SameSite=Strict; Path=/; Max-Age=604800;": 
      //   "HttpOnly; SameSite=Strict; Path=/; Max-Age=604800; Secure;";
      const cookieOptions = `HttpOnly; SameSite=Strict; Path=/; Max-Age=604800; ${process.env.SECURE == 'true' ? "Secure;" : ""}`

      res.setHeader("Set-Cookie", `token=${newToken}; ${cookieOptions}`);
      // return res.end(JSON.stringify({ status, reason, session })) 
    // } else { 
    }
    return res.end(JSON.stringify({ status, reason, session, newToken })) 

  } else if (z.string().startsWith('/auth/callback').safeParse(routePath).success) {
    //? this endpoint is triggerd by the oauth provider after the user has logged in
    const newToken = await loginCallback(routePath, req, res);

    //? if it failed to either login or creating an account then we return
    if (!newToken) {
      res.writeHead(401, { "Content-Type": "text/plain" });
      return res.end('Login failed');
    }

    //? we successfully logged in or created an acocunt

    //? if the user already had a token then we delete the previous session data
    if (token) { await deleteSession(token); }

    //? we set the cookie with the new token and redirect the user to the frontend
    console.log('setting cookie with newToken: ', newToken, 'green');
    const cookieOptions = `HttpOnly; SameSite=Strict; Path=/; Max-Age=604800; ${process.env.SECURE == 'true' ? "Secure;" : ""}`
      
    const location = process.env.DNS

    if (process.env.VITE_SESSION_BASED_TOKEN == 'true') {
      res.writeHead(302, {
        Location: `${process.env.DNS}?token=${newToken}`,
      });
    } else {
      res.setHeader("Set-Cookie", `token=${newToken}; ${cookieOptions}`);
      res.writeHead(302, { Location: location }); // Redirect without exposing token in URL
    }
    return res.end();

  } else if (routePath.includes("/assets/")) {
    const assetPath = routePath.slice(routePath.indexOf("/assets/"));
    req.url = assetPath;
    return serveFile(req, res);

  } else if (z.string()
    .regex(/^\/(assets\/[a-zA-Z0-9_\-/]+|[a-zA-Z0-9_\-]+)\.(png|jpg|jpeg|gif|svg|html|css|js)$/)
    .safeParse(routePath).success) {
    //? if the request is a file with one of the following extensions then we serve it
    //? png|jpg|jpeg|gif|svg|html|css|js
    return serveFile(req, res); 

  } else { // for the index.html
    //? if the request doesnt fit any of the above then we serve the index.html file
    return serveFile({url: '/'}, res);
  }
}

const ip: string = process.env.SERVER_IP || '127.0.0.1';
const port: string = process.env.SERVER_PORT || '80';

(async () => {
  if (process.env.NODE_ENV == 'development') {
    initConsolelog();
    await initializeAll();
    setupWatchers();
    initRepl();
  }

  const httpServer = http.createServer(async(req, res) => { ServerRequest(req, res) });
  loadSocket(httpServer);
  // @ts-ignore // typescript thinks ip needs to be a number
  httpServer.listen(port, ip, () => {
    console.log(`Server is running on http://${ip}:${port}/`, 'green'); 
  });
  
  
})()
</file>

<file path="server/sockets/handleApiRequest.ts">
import { tryCatch } from '../functions/tryCatch';
import { apis, functions } from '../prod/generatedApis'
import { devApis, devFunctions } from "../dev/loader"
import { apiMessage } from './socket';
import { getSession } from '../functions/session';
import type { SessionLayout } from '../../config';
import { Socket } from 'socket.io';
import { logout } from './utils/logout';

type handleApiRequestType = {
  msg: apiMessage,
  socket: Socket,
  token: string | null,
}

const isFalsy = (value: any) => {
  return (
    value === false ||
    value === 0 ||
    value === 0n ||
    value === '' ||
    value === null ||
    value === undefined ||
    (typeof value === 'number' && isNaN(value))
  );
}

const validateRequest = ({ auth, user }: {
  auth: {
    login: boolean;
    additional?: {
      key: string;
      type?: 'string' | 'number' | 'boolean' | 'object' | 'function' | 'undefined';
      value?: any;
      mustBeFalsy?: boolean;
      nullish?: boolean;
    }[]
  }, 
  user: SessionLayout
}) => {

  //? if the additional key is an array we check if the following
  //? if it has a key and a type we check if the user has the key and if the value is of the correct type
  //? if it has a key and a value we check if the user has the key and if the value is the same as the given value
  //? examples:
  //? { key: 'admin', type: 'boolean' } -> checks if the user has the key admin and if the value is of type boolean
  //? { key: 'admin', value: true } -> checks if the user has the key admin and if the value is true   

  if (auth.additional) {
    for (const condition of auth.additional) {
      if (!condition.key) { 
        return {
          status: "error",
          message: `Missing key in auth.additional condition`,
        };
      }

      if (!(condition.key in user)) {
        return { status: "error", message: `Key ${condition.key} not found in user session` };
      }

      const val = user?.[condition.key as keyof SessionLayout];

      //? If nullish flag is set, check accordingly
      if (typeof condition.nullish === 'boolean') {
        const isNullish = val === null || val === undefined;
        if (condition.nullish && !isNullish) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be null or undefined`,
          };
        }
        if (!condition.nullish && isNullish) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be not null and not undefined`,
          };
        }
      }

      //? Check type if specified (skip null or undefined values)
      if (condition.type && val != null) {
        if (typeof val !== condition.type) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be of type ${condition.type}`,
          };
        }
      }

      //? Check exact value if specified (strict equality)
      if ('value' in condition) {
        if (val !== condition.value) {
          return {
            status: "error",
            message: `Expected ${condition.key} to equal ${JSON.stringify(condition.value)}`,
          };
        }
      }

      //? Check truthy/falsy if specified
      if (typeof condition.mustBeFalsy === 'boolean') {
        if (condition.mustBeFalsy && !isFalsy(val)) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be falsy`,
          };
        }
        if (!condition.mustBeFalsy && isFalsy(val)) {
          return {
            status: "error",
            message: `Expected ${condition.key} to be truthy`,
          };
        }
      }
    }
  
  }
  return {
    status: "success"
  }
}

// export default async function handleApiRequest({ name, data, user }: handleApiRequestType) {
export default async function handleApiRequest({ msg, socket, token }: handleApiRequestType) {
  // console.log(msg)
  //? this event gets triggerd when the client uses the apiRequest function from serverRequest.ts
  //? we check if the msg contains a name and check if there is a api that exist with this name
  if (typeof msg != 'object' ) {
    console.log('socket message was not a json object!!!!', 'red')
    console.log('socket message was not a json object!!!!', 'red')
    console.log('socket message was not a json object!!!!', 'red')
    return;
  }

  const { name, data, responseIndex } = msg;
  const user = await getSession(token)

  if (!responseIndex && typeof responseIndex !== 'number') {
    console.log('no response index given!!!!', 'red')
    console.log('no response index given!!!!', 'red')
    console.log('no response index given!!!!', 'red')
    return;
  }

  //? if the name of the apiRequest is 'session' we return the users session data else we check if there is an api with this name
  if (name == 'session') {
    return socket.emit(`apiResponse-${responseIndex}`, { result: user });
  }

  if (name == 'logout') {
    await logout({ token, socket, userId: user?.id || null });
    return socket.emit(`apiResponse-${responseIndex}`, { result: true });
  }

  if (!name || !data || typeof name != 'string' || typeof data != 'object') {
    return socket.emit(`apiResponse-${responseIndex}`, { status: "error" , message: `socket message was incomplete, needs a name ${name} and data: ${JSON.stringify(data)}` });
  }

  console.log(' ', 'blue')
  console.log(' ', 'blue')
  console.log(`api: ${name} called`, 'blue');

  const apisObject = process.env.NODE_ENV == 'development'? devApis : apis;

  //? check if there exist a function with the given name
  if (!apisObject[name]) { return socket.emit(`apiResponse-${responseIndex}`, { status: "error", message: 'api not found' }); }

  const { auth, main } = apisObject[name];

  //? if the login key is true we check if the user has an id in the session object
  if (auth.login) { 
    if (!user?.id) { 
      console.log(`ERROR!!!, not logged in but api call requires login`, 'red');
      return socket.emit(`apiResponse-${responseIndex}`, { status: "error", message: 'not logged in but api call requires login' }); 
    }
  }

  const notValid = validateRequest({ auth, user: user as SessionLayout });
  if (!notValid || notValid?.status === "error") { return socket.emit(`apiResponse-${responseIndex}`, notValid); }

  //? All checks passed so we call the api function and return the result
  const functionsObject = process.env.NODE_ENV == 'development' ? devFunctions : functions;
  const [error, result] = await tryCatch(async () => await main({ data, user, functions: functionsObject }));
  if (error) { 
    console.log(error, 'red'); 
    socket.emit(`apiResponse-${responseIndex}`, { status: "error", message: error });
  } else if (result) { 
    console.log(result, 'blue');
    socket.emit(`apiResponse-${responseIndex}`, { status: "success", result });
  } else {
    console.log('api didnt return anything', 'red');
    socket.emit(`apiResponse-${responseIndex}`, { status: "error", message: 'api didnt return anything' });
  }
}
</file>

<file path="server/sockets/handleSyncRequest.ts">
import { tryCatch } from "../functions/tryCatch";
import { devSyncs, devFunctions } from "../dev/loader"
import { syncs, functions } from '../prod/generatedApis'
import { ioInstance, syncMessage } from "./socket";
import { Socket } from "socket.io";
import { getSession } from "../functions/session";
import { SessionLayout } from "config";

const functionsObject = process.env.NODE_ENV == 'development' ? devFunctions : functions;

const isFalsy = (value: any) => {
  return (
    value === false ||
    value === 0 ||
    value === 0n ||
    value === '' ||
    value === null ||
    value === undefined ||
    (typeof value === 'number' && isNaN(value))
  );
}

const validateRequest = ({ auth, user }: {
  auth: {
    login: boolean;
    additional?: {
      key: string;
      type?: 'string' | 'number' | 'boolean' | 'object' | 'function' | 'undefined';
      value?: any;
      mustBeFalsy?: boolean;
      nullish?: boolean;
    }[]
  }, 
  user: SessionLayout
}) => {

  //? if the additional key is an array we check if the following
  //? if it has a key and a type we check if the user has the key and if the value is of the correct type
  //? if it has a key and a value we check if the user has the key and if the value is the same as the given value
  //? examples:
  //? { key: 'admin', type: 'boolean' } -> checks if the user has the key admin and if the value is of type boolean
  //? { key: 'admin', value: true } -> checks if the user has the key admin and if the value is true   

  if (auth.additional) {
    for (const condition of auth.additional) {

      if (!condition.key) { 
        return {
          error: true,
          message: `Missing key in auth.additional condition`,
        };
      }

      if (!(condition.key in user)) {
        return { status: "error", message: `Key ${condition.key} not found in user session` };
      }

      const val = user?.[condition.key as keyof SessionLayout];

      //? If nullish flag is set, check accordingly
      if (typeof condition.nullish === 'boolean') {
        const isNullish = val === null || val === undefined;
        if (condition.nullish && !isNullish) {
          return {
            error: true,
            message: `Expected ${condition.key} to be null or undefined`,
          };
        }
        if (!condition.nullish && isNullish) {
          return {
            error: true,
            message: `Expected ${condition.key} to be not null and not undefined`,
          };
        }
      }

      //? Check type if specified (skip null or undefined values)
      if (condition.type && val != null) {
        if (typeof val !== condition.type) {
          return {
            error: true,
            message: `Expected ${condition.key} to be of type ${condition.type}`,
          };
        }
      }

      //? Check exact value if specified (strict equality)
      if ('value' in condition) {
        if (val !== condition.value) {
          return {
            error: true,
            message: `Expected ${condition.key} to equal ${JSON.stringify(condition.value)}`,
          };
        }
      }

      //? Check truthy/falsy if specified
      if (typeof condition.mustBeFalsy === 'boolean') {
        if (condition.mustBeFalsy && !isFalsy(val)) {
          return {
            error: true,
            message: `Expected ${condition.key} to be falsy`,
          };
        }
        if (!condition.mustBeFalsy && isFalsy(val)) {
          return {
            error: true,
            message: `Expected ${condition.key} to be truthy`,
          };
        }
      }
    }
  
  }
}


// export default async function handleSyncRequest({ name, clientData, user, serverData, roomCode }: syncMessage) {
export default async function handleSyncRequest({ msg, socket, token }: {
  msg: syncMessage,
  socket: Socket,
  token: string | null,
}) {

  if (!ioInstance) { return; }
  
  //? first we validate the data
  if (typeof msg!= 'object' ) {
    console.log('message','socket message was not a json object', 'red')
    return socket.emit('sync','socket message was not a json object');
  }

  const { name, data, cb, receiver, responseIndex, ignoreSelf } = msg;

  if (!name || !data || typeof name != 'string' || typeof data != 'object') {
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `socket message was incomplete, syncName: ${name}, syncData: ${JSON.stringify(data)}` })
  }

  if (!cb || typeof cb != 'string') {
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `socket message was incomplete, cb: ${cb}` });
  }
  
  if (!receiver) {
    console.log('receiver / roomCode: ', receiver, 'red')
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `socket message was incomplete, needs a receiver / roomCode: ${receiver}` });
  }

  console.log(' ', 'blue')
  console.log(' ', 'blue')
  console.log(`sync: ${name} called`, 'blue');

  const user = await getSession(token);
  const syncObject = process.env.NODE_ENV == 'development' ? devSyncs : syncs;

  console.log(syncObject)
  //? we check if there is a client file or/and a server file, if they both dont exist we abort
  if (!syncObject[`${name}_client`] && !syncObject[`${name}_server`]) { 
    console.log("ERROR!!!, ", `you need ${name}_client or ${name}_server file to sync`, 'red');
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `you need ${name}_client or ${name}_server file to sync` });
  }

  let serverData = {};
  if (syncObject[`${name}_server`]) {
    const { auth, main: serverMain } = syncObject[`${name}_server`];

    //? if the login key is true we check if the user has an id in the session object
    if (auth.login) { 
      if (!user?.id) { 
        console.log(`ERROR!!!, not logged in but sync requires login`, 'red');
        return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: 'not logged in but sync requires login' }); 
      }
    }

    const notValid = validateRequest({ auth, user: user as SessionLayout });
    if (notValid) { 
      console.log('ERROR!!!, ', notValid.message, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, notValid); 
    }

    //? if the user has passed all the checks we call the preload sync function and return the result
    const [serverSyncError, serverSyncResult] = await tryCatch(async () => await serverMain({ clientData: data, user, functions: functionsObject, roomCode: receiver }));
    if (serverSyncError) {
      console.log('ERROR!!!, ', serverSyncError.message, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: serverSyncError.message });
    } else if (serverSyncResult?.status == 'error') {
      console.log('ERROR!!!, ', serverSyncResult.message, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: serverSyncResult.message });
    } else if (serverSyncResult?.status !== 'success') {
      //? badReturn means it doesnt include a status key with the value 'success' || 'error'
      console.log('ERROR!!!, ', `sync ${name}_server function didnt return a status key with the value 'success' or 'error'`, 'red');
      return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `sync ${name}_server function didnt return a status key with the value 'success' or 'error'` });
    } else if (serverSyncResult?.status == 'success') {
      serverData = serverSyncResult;
    }
  }

  //? from here on we can assume that we have either called a server sync and got a proper result of we didnt call a server sync

  //? get the desired sockets based on the receiver key
  const sockets = receiver === 'all'
    ? ioInstance.sockets.sockets //? all connected sockets (Map)
    : ioInstance.sockets.adapter.rooms.get(receiver) //? Set of socket IDs in room

  //? now we check if we found any sockets
  if (!sockets) { 
    console.log('data: ', msg, 'red');
    console.log('receiver: ', receiver, 'red');
    console.log('no sockets found', 'red');
    return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { status: "error", message: `no sockets found for receiver / roomCode: ${receiver}` });
  }

  //? here we loop over all the connected clients
  //? we keep track of an counter and await the loop every 100 iterations to avoid the server running out of memory and crashing
  let tempCount = 1;
  for (const socketEntry of sockets) {
    tempCount++;
    if (tempCount % 100 == 0) { await new Promise(resolve => setTimeout(resolve, 1)); }

    const tempSocket = receiver === 'all'
      ? (socketEntry as [string, Socket])[1] //? Map entry
      : ioInstance.sockets.sockets.get(socketEntry as string); //? socket ID from Set

    if (!tempSocket) { continue; }

    //? check if they have a token stored in there cookie or session based on the settings
    const tempCookie = tempSocket.handshake.headers.cookie; // get the cookie from the socket connection
    const tempSessionToken = tempSocket.handshake.auth?.token
    const tempToken = tempCookie && process.env.VITE_SESSION_BASED_TOKEN === 'false' ? tempCookie.split("=")[1] 
      : tempSessionToken && process.env.VITE_SESSION_BASED_TOKEN === 'true' ? tempSessionToken
      : null; 

    //? here we get the users session of the client and run the sync function with the data and the users session data
    const user = await getSession(tempToken);

    if (ignoreSelf && typeof ignoreSelf == 'boolean') {
      if (token == tempToken) {
        continue;
      }
    }

    if (syncObject[`${name}_client`]) {
      const [clientSyncError, clientSyncResult] = await tryCatch(async () => await syncObject[`${name}_client`]({ clientData: data, user, functions: functionsObject, serverData, roomCode: receiver }));
      // if (clientSyncError) { socket.emit(`sync-${responseIndex}`, { status: "error", message: clientSyncError }); }
      if (clientSyncError) { tempSocket.emit(`sync`, { status: "error", message: clientSyncError }) }
      //? if we return error we dont want this client to get the event
      else if (clientSyncResult?.status == 'error') { continue; }
      else if (clientSyncResult?.status == 'success') {
        const result = { 
          cb, 
          serverData, 
          clientData: clientSyncResult, 
          message: clientSyncResult.message || `${name} sync success`, 
          status: 'success' 
        };
        console.log(result, 'blue')
        tempSocket.emit(`sync`, result);
      } 
    } else {
      //? if there is no client function we still want to send the server data to the clients
      const result = { 
        cb, 
        serverData, 
        clientData: {}, 
        message: `${name} sync success`, 
        status: 'success' 
      };
      console.log(result, 'blue')
      tempSocket.emit(`sync`, result);
    }
  }

  return typeof responseIndex == 'number' && socket.emit(`sync-${responseIndex}`, { success: true, message: `sync ${name} success` });
}
</file>

<file path="server/sockets/socket.ts">
import dotenv from 'dotenv';
dotenv.config();

import handleApiRequest from "./handleApiRequest";
import { getSession, saveSession } from "../functions/session";
import { Server as SocketIOServer } from 'socket.io';
import handleSyncRequest from "./handleSyncRequest";
import allowedOrigin from '../auth/checkOrigin';
import { initAcitivityBroadcaster, socketConnected, socketDisconnecting, socketLeaveRoom } from './utils/activityBroadcaster';
import config, { SessionLayout } from '../../config';

export type apiMessage = {
  name: string;
  data: object;
  responseIndex: number;
}

export type syncMessage = {
  name: string;
  data: object;
  cb: string;
  receiver: string;
  responseIndex?: number;
  ignoreSelf?: boolean;
}

export let ioInstance: SocketIOServer | null = null;

export default function loadSocket(httpServer: any) {

  //? here we create the SocketIOServer instance
  const io = new SocketIOServer(httpServer, {
    cors: { 
      methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
      origin: (origin, callback) => {
        if (!origin || allowedOrigin(origin)) {
          callback(null, true);
        } else {
          callback(new Error('Not allowed by CORS'));
        }
      },
      credentials: true,
    },
    maxHttpBufferSize: 5 * 1024 * 1024, // 5 MB
  });

  ioInstance = io;
  
  console.log('SocketIO server initialized', 'green');

  //? when a client connects to the SocketIO server we define there cookies and define some events to work with the exports of serverRequest.ts on the client
  io.on('connection', (socket) => {
    const cookie = socket.handshake.headers.cookie; // get the cookie from the socket connection
    const sessionToken = socket.handshake.auth?.token;
    const token = 
      cookie && process.env.VITE_SESSION_BASED_TOKEN === 'false' ? cookie.split("=")[1] 
      : sessionToken && process.env.VITE_SESSION_BASED_TOKEN === 'true'? sessionToken
      : null; 


    if (token) {
      socketConnected({ token, io });
    }

    socket.on('apiRequest', async (msg: apiMessage) => {
      handleApiRequest({ msg, socket, token });
    });
    socket.on('sync', async (msg: syncMessage) => {
      handleSyncRequest({ msg, socket, token });
    });
    socket.on('joinRoom', async (data) => {
      const { group, responseIndex } = data;
      await socket.join(group);
      await saveSession(token, { ...await getSession(token), code: group });
      socket.emit(`joinRoom-${responseIndex}`);
      console.log(`Socket ${socket.id} joined group ${group}`, 'cyan');
    });

    socket.on('disconnect', async (reason) => {
      if (config.socketActivityBroadcaster) {
        socketDisconnecting({ token, socket, reason });
      } else {
        if (!token) { return; }
        console.log(`user disconnected, reason: ${reason}`, 'yellow');
      }
    });

    socket.on('updateLocation', async (newLocation) => {
      console.log('updating location to: ', newLocation.pathName, 'yellow')

      let returnedUser: SessionLayout | undefined;
      if (config.socketActivityBroadcaster) {
        returnedUser = await socketLeaveRoom({ token, socket, newPath: newLocation.pathName });
      }

      if (!newLocation) { return; }
      const user = returnedUser || await getSession(token);
      if (!user) { return; }

      user.location = newLocation;
      return await saveSession(token, user);
    });

    if (config.socketActivityBroadcaster) {
      initAcitivityBroadcaster({ socket, token });
    }

    if (token) {
      socket.join(token);
    }
  
  });
  return io;
}
</file>

<file path="server/sockets/utils/activityBroadcaster.ts">
// ------------
// Activity Broadcaster
// ------------
// This module provides info about the users activty
// this is usefull to make a game to pause it for example when the user is not active

import { Server, Socket } from "socket.io";
import { deleteSession, getSession } from "../../functions/session";
import handleSyncRequest from "../handleSyncRequest";
import { ioInstance } from "../socket";

export const disconnectTimers = new Map<string, NodeJS.Timeout>();
export const disconnectReasonsWeIgnore: string[] = ['ping timeout', ];
export const disconnectReasonsWeAllow: string[] = ['transport close', 'transport error'];
export const tempDisconnectedSockets = new Set<string>();
export const clientSwitchedTab = new Set<string>();

export const socketConnected = async ({
  token,
  io
}: {
  token: string,
  io: Server
}) => {
  const timer = disconnectTimers.get(token);
  if (timer) { 
    console.log(`user came back with token: ${token}`, 'yellow');
    clearTimeout(timer);
    disconnectTimers.delete(token);
    if (tempDisconnectedSockets.has(token)) {
      tempDisconnectedSockets.delete(token);
    } else {
      console.log(`a user connected with token: ${token}`, 'cyan');
    }
  }

  const session = await getSession(token);
  const userId = session?.id || null;
  const code = session?.code || null;

  if (!code) { return; }
  if (!userId) { return; }

  informRoomPeers({ token, io, event: 'userBack', extraData: { ignoreSelf: true } });
}


export const socketLeaveRoom = async ({ token, socket, newPath }: {
  token: string | null,
  socket: Socket,
  newPath: string | null
}) => {

  //? retrieve users session data
  if (!token) { 
    console.log('trying to update room peers but no token provided', 'red'); 
    return;
  }

  const user = await getSession(token);
  if (!user?.id) { 
    console.log(`no session data for given token: ${token}`, 'red'); 
    return;
  }

  const { pathName, searchParams } = user.location || {};



  /////////////
  //? EXAMPLE USAGE
  /////////////

  
  // console.log(`
  //   check1: ${pathName == '/games/test123'}
  //   check2: ${user.code}
  //   check3: ${!newPath || newPath !== pathName}
  // `, 'cyan');
  
  // //? if user is at a certain location we run a sync function to update the other players that are in the same room has him
  // if (
  //   pathName == '/games/test123' &&
  //   user.code &&
  //   (!newPath || newPath !== pathName)
  // ) {
  //   console.log('socket is leaving test123 game', 'cyan');
  //   handleSyncRequest({
  //     msg: { 
  //       name: 'sync/games/test123/playerLeave', 
  //       data: { gameCode: user.code, oldUser: user },
  //       cb: 'playerLeave',
  //       receiver: searchParams?.code, ignoreSelf: true
  //     },
  //     socket,
  //     token
  //   });
  //   socket.leave(user.code);
  // }

  return user;

}

const getDisconnectTime = ({ 
  token, 
  reason 
}: {
  token: string,
  reason: string | undefined
}) => {
  return clientSwitchedTab.has(token) 
    ? 20000 
    // ? 3000 
    : disconnectReasonsWeAllow.includes(reason ?? "NULL") 
    ? 60000 
    : 2000
}

export const socketDisconnecting = async ({
  token,
  reason,
  socket
}: {
  token: string,
  reason: string,
  socket: Socket
}) => {

  if (disconnectReasonsWeIgnore.includes(reason)) {
    console.log(`user disconnected but we ignore it, reason: ${reason}`, 'yellow');
    return; 
  }

  if (!token) { return; }
  if (!tempDisconnectedSockets.has(token)) {
    tempDisconnectedSockets.add(token);
  } else {
    return; //? if the user is already in the tempDisconnectedSockets array we ignore the disconnect event
  }

  const time = getDisconnectTime({ token, reason });

  let deleteSessionOnDisconnect = true;
  if (clientSwitchedTab.has(token)) {
    deleteSessionOnDisconnect = false;
    clientSwitchedTab.delete(token);
  }

  console.log(`user disconnected, reason: ${reason}, timer: ${time/1000} seconds`, 'yellow');

  const timeout = setTimeout(async () => {
    if (tempDisconnectedSockets.has(token)) {
      tempDisconnectedSockets.delete(token);
    } else { return; } //? if the user has reconnected we dont run the logout function

    if (disconnectTimers.get(token) !== timeout) { return };

    await socketLeaveRoom({ token, socket, newPath: null });

    //? we only delete the session if the user disconnected themself, it the server kicked them it means that they were kicked from a game
    if (deleteSessionOnDisconnect) {
      await deleteSession(token);
    }

    console.log(`user fully disconnected, reason: ${reason}, timer : ${time/1000} seconds, deleteSessionOnDisconnect: ${deleteSessionOnDisconnect}`, 'yellow');
  }, time);

  if (disconnectTimers.has(token)) {
    clearTimeout(disconnectTimers.get(token)!);
    disconnectTimers.delete(token);
  }
  disconnectTimers.set(token, timeout);

}

const informRoomPeers = async ({
  token,
  io = ioInstance,

  event,
  extraData,
}: {
  token: string,
  io?: Server | null

  event: 'userAfk' | 'userBack',
  extraData?: any
}) => {
  if (!io) { 
    console.log('no io instance found to inform room peers', 'red');
    return; 
  }

  const session = await getSession(token);
  if (session.code) {
    const roomSockets = io.sockets.adapter.rooms.get(session.code);
    console.log(roomSockets);
    
    for (const socketId of roomSockets || []) {
      const tempSocket = io.sockets.sockets.get(socketId as string);
      if (!tempSocket) { continue; }

      if (extraData?.ignoreSelf) {
        console.log(' skipping self emit ');
        
        const tempCookie = tempSocket.handshake.headers.cookie; // get the cookie from the socket connection
        const tempSessionToken = tempSocket.handshake.auth?.token
        const tempToken = tempCookie && process.env.VITE_SESSION_BASED_TOKEN === 'false' ? tempCookie.split("=")[1] 
          : tempSessionToken && process.env.VITE_SESSION_BASED_TOKEN === 'true' ? tempSessionToken
          : null; 

        if (token == tempToken) { continue; } //? we dont send the event to the client who called the event
      }

      if (event == 'userAfk') {
        console.log({ userId: session.id, endTime: Date.now() + (extraData?.time || 0) });
        tempSocket?.emit('userAfk', { userId: session.id, endTime: Date.now() + (extraData?.time || 0) });
      } else if (event == 'userBack') {
        tempSocket?.emit('userBack', { userId: session.id });
      }
    }
  }
}

export const initAcitivityBroadcaster = ({
  token,
  socket
}: {
  token: string,
  socket: Socket,
}) => {
  socket.on("intentionalDisconnect", async () => {
    clientSwitchedTab.add(token);
    const time = getDisconnectTime({ token, reason: undefined });

    await informRoomPeers({ token, event: 'userAfk', extraData: { time } });

    socket.disconnect(false);
  });
}
</file>

<file path="server/sockets/utils/logout.ts">
import { Socket } from "socket.io";
import redis from "../../functions/redis";
import { tryCatch } from "../../functions/tryCatch";
import { disconnectTimers, tempDisconnectedSockets } from "./activityBroadcaster";
import { deleteSession } from "../../functions/session";
import { socketLeaveRoom } from "./activityBroadcaster";

export const logout = async ({ token, socket, userId }: {
  token: string | null,
  socket: Socket | undefined,
  userId: string | null,
}) => {
  const [error, result] = await tryCatch(async () => {
    if (!socket) { 
      console.log('Trying to logout but invalid socket', 'red');
      return;
    }
    if (!token) { 
      console.log('Trying to logout without a token', 'red');
      return;
    }
    
    if (tempDisconnectedSockets.has(token)) {
      tempDisconnectedSockets.delete(token);
    }

    if (disconnectTimers.has(token)) {
      const timer = disconnectTimers.get(token);
      if (timer) {
        clearTimeout(timer);
        disconnectTimers.delete(token);
      } 
    }

    console.log(`Logging out user with token: ${token}`, 'cyan');
    
    await socketLeaveRoom({ token, socket, newPath: null });
    await deleteSession(token);
    const tokensOfActiveUsers = `${process.env.PROJECT_NAME}-activeUsers:${userId}`
    await redis.srem(tokensOfActiveUsers, token);
    socket.leave(token);
    return true;
  });
  if (error) {
    if (socket) {
      socket.emit(`logout`, "error");
    }
  } else if (result) {
    if (socket) {
      socket.emit(`logout`, "success");
    }
  }
}
</file>

<file path="server/sockets/utils/onLocationChange.ts">

</file>

<file path="server/utils/console.log.ts">
const COLORS: Record<string, string> = {
  black: "\x1b[30m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  magenta: "\x1b[35m",
  cyan: "\x1b[36m",
  white: "\x1b[37m",
  reset: "\x1b[0m",
};

export const initConsolelog = () => {
  const originalLog = console.log;
  console.log = (...args: any[]) => {
    const stack = new Error().stack?.split("\n")[2]?.trim();
    if (!stack) return originalLog(...args);
  
    let lineInfo = stack.substring(stack.indexOf("(") + 1, stack.lastIndexOf(")"));
    if (lineInfo === "") lineInfo = stack;
    const extractedInfo = lineInfo
      .substring(lineInfo.lastIndexOf("\\") + 1)
      .replace(/:\d+$/, "");
  
    // find color keyword and remove it from args
    let colorCode = COLORS.white;
    for (const key of Object.keys(COLORS)) {
      const index = args.findIndex((a) => a === key);
      if (index !== -1) {
        colorCode = COLORS[key];
        args.splice(index, 1);
        break;
      }
    }
  
    // handle object vs text
    if (typeof args[0] === "object") {
      originalLog(`${colorCode}${extractedInfo}${COLORS.reset}`);
      originalLog(args);
    } else {
      originalLog(`${colorCode}${extractedInfo} -- ${args.join(" ")}${COLORS.reset}`);
    }
  };
}
</file>

<file path="server/utils/getParams.ts">
import { IncomingMessage, ServerResponse } from "http";
import { tryCatch } from "../functions/tryCatch";

type getParamsType = {
  method: string;
  req: IncomingMessage;
  res: ServerResponse;
  queryString?: string;
}

export default async function getParams({ method, req, res, queryString }: getParamsType): Promise<Record<string, any> | null> {

  if (method == "GET") {
    //? if get request we return the query string as an object
    return Object.fromEntries(new URLSearchParams(queryString || '')) as Record<string, string>;
  }

  //? if a POST, PUT or DELETE method we return the body as an object
  return new Promise((resolve, reject) => {
    const contentType = req.headers['content-type'] || '';

    //? we store the passed data chunks in a string
      let body = '';
      req.on('data', (chunk) => {
        body += chunk.toString();
      }); 

      req.on('end', async () => {
        //? here we parse the data depending on the content type
        //? if the content type is application/x-www-form-urlencoded we parse the data as a URLSearchParams object
        if (contentType.startsWith('application/x-www-form-urlencoded')) {
          const parseData = () => {
            const data = new URLSearchParams(body);
            return Object.fromEntries(data);
          }
          const [error, response] = await tryCatch(parseData)
          if (response) { resolve(response) }
          else { reject(error)}
        }

        //? if the content type is application/json we parse the data as a JSON object
        if (contentType.startsWith('application/json')) {
          const parseData = () => {
            return JSON.parse(body || '{}');
          }
          const [error, response] = await tryCatch(parseData)
          if (response) { resolve(response) }
          else { reject(error)}
        }

        resolve({ body });
      })

      req.on('error', (error) => {
        reject(error);
      })
    // }

  });
}
</file>

<file path="server/utils/repl.ts">
import { getAllGameDatas, getGameData, saveGameData } from "../functions/game"
import { deleteSession, getAllSessions, getSession } from "../functions/session"
import repl from 'repl';

export const initRepl = () => {
  const replInstance = repl.start({
    prompt: 'server> ',
    useColors: true,
    useGlobal: true,
  })
  
  replInstance.context.getAllSessions = async () => {
    console.log(await getAllSessions())
  }

  replInstance.context.getSession = async (token: string) => {
  
    const session = await getSession(token)
    if (session && typeof session == 'object' && Object.keys(session).length > 0) {
      console.log(session) 
    } else {
      console.log('no session found')
    }
  }
  
  replInstance.context.deleteSession = async (token: string) => {
  
    const result = await deleteSession(token)
    console.log(result)
  }
  
  replInstance.context.getGame = async (code: string, keys?: string) => {
    if (!code) {
      console.log(await getAllGameDatas())
      return;
    }
  
    const gameData = await getGameData(code)
    if (typeof gameData == 'object' && gameData?.gameCode) {
      if (keys) {
        const parts = keys
        .replace(/\[(\w+)\]/g, ".$1")   // turn [0] into .0
        .replace(/^\./, "")             // remove leading dot
        .split(/(?:\?\.)|\./);          // split on ?. or .
        
        // @ts-ignore
        console.log(parts.reduce((acc, key) => acc?.[key], gameData));
      } else {
        console.log(gameData) 
      }
    } else {
      console.log('no session found')
    }
  }
  
  replInstance.context.updateGame = async (code: string, keys: string, value: any) => {
    if (!code || !keys) {
      console.log("Usage: updateGame(code, 'nested.path.like.this', value)");
      return;
    }
  
    let gameData = await getGameData(code);
    if (typeof gameData !== "object" || !gameData?.gameCode) {
      console.log("No session found");
      return;
    }
  
    // Parse the keys string into parts (supporting [0], ?. etc.)
    const parts = keys
      .replace(/\[(\w+)\]/g, ".$1") // turn [0] into .0
      .replace(/^\./, "")           // remove leading dot
      .split(/(?:\?\.)|\./);        // split on ?. or .
  
    // Walk into object and set the value
    let target = gameData;
    for (let i = 0; i < parts.length - 1; i++) {
      const key = parts[i];
      if (!(key in target)) {
        // @ts-ignore
        target[key] = {}; // create missing objects
      }
      // @ts-ignore
      target = target[key];
    }
  
    const lastKey = parts[parts.length - 1];
    // @ts-ignore
    target[lastKey] = value;
  
    // Persist the change (assuming you already have a saveGameData function)
    await saveGameData(code, gameData);
  
    console.log(`Updated ${keys} to:`, value);
  };
  
  
  replInstance.context.commands = () => {
    console.log('commands:')
    console.log('getSession(token) -- if no token provided then it will return all sessions')
    console.log('deleteSession(token) -- if no token provided then it will delete all sessions')
    console.log('getGame(code) -- if no code provided then it will return all sessions')
  }
}
</file>

<file path="src/_components/Avatar.tsx">
import { backendUrl, SessionLayout } from "config";
import { useAvatarContext } from "./AvatarProvider";

export default function Avatar({
  user,
  textSize,
}: {
  user: SessionLayout 
  | {name: string, avatar?: string, avatarFallback?: string},
  textSize?: "text-sm" | "text-base" | "text-lg" | "text-xl" | "text-2xl" | "text-3xl" | "text-4xl" | "text-5xl" | "text-6xl" | "text-7xl" | "text-8xl" | "text-9xl"
}) {
  const { avatarStatuses, setAvatarStatus } = useAvatarContext();

  // Unique key per avatar
  if (!user) { return null; }

  const key = user.avatar || user.avatarFallback || user.name;
  const avatarStatus = key ? avatarStatuses[key] : null;

  const formattedName = user?.name?.[0]?.toUpperCase() || "?";

  return user?.avatar && (avatarStatus === 'avatar' || !avatarStatus) ? (
    <Img user={user} key={key} setAvatarStatus={setAvatarStatus} />
  ) : (
    <FallbackImg user={user} formattedName={formattedName} textSize={textSize} />
  );
}

const Img = ({ user, setAvatarStatus }: any) => {
  if (!user?.avatar) {
    const key = user.avatar || user.avatarFallback || user.name;
    setAvatarStatus(key, 'fallback');
    return null;
  }

  const key = user.avatar || user.avatarFallback || user.name;

  return (
    <img
      className="rounded-full w-full h-full select-none object-cover aspect-square"
      src={user.avatar.startsWith('http') ? user.avatar : `${backendUrl}/uploads/${user.avatar}`}
      alt="Avatar"
      onError={() => setAvatarStatus(key, 'fallback')}
      onLoad={() => setAvatarStatus(key, 'avatar')}
    />
  );
};

const FallbackImg = ({ user, formattedName, textSize }: any) => {
  return (
    <div
      className={`rounded-full bg-gray-300 text-white flex items-center justify-center w-full h-full select-none ${textSize || 'text-lg'}`}
      style={{ backgroundColor: user?.avatarFallback }}
    >
      {user?.name && user.name !== 'Wachten op speler' ? formattedName : null}
    </div>
  );
};
</file>

<file path="src/_components/AvatarProvider.tsx">
import { createContext, useContext, useState, ReactNode } from "react";

type AvatarStatus = 'avatar' | 'fallback';

interface AvatarContextType {
  avatarStatuses: Record<string, AvatarStatus>;
  setAvatarStatus: (key: string, status: AvatarStatus) => void;
}

const AvatarContext = createContext<AvatarContextType | null>(null);

export const AvatarProvider = ({ children }: { children: ReactNode }) => {
  const [avatarStatuses, setAvatarStatuses] = useState<Record<string, AvatarStatus>>({});

  const setAvatarStatus = (key: string, status: AvatarStatus) => {
    setAvatarStatuses(prev => ({ ...prev, [key]: status }));
  };

  return (
    <AvatarContext.Provider value={{ avatarStatuses, setAvatarStatus }}>
      {children}
    </AvatarContext.Provider>
  );
};

export const useAvatarContext = () => {
  const ctx = useContext(AvatarContext);
  if (!ctx) throw new Error("useAvatarContext must be used within AvatarProvider");
  return ctx;
};
</file>

<file path="src/_components/Dropdown.tsx">
import { faCaretDown, faCheck } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { useState, useRef, useEffect } from "react";

interface DropdownProps {
  items: any[];
  itemsPlaceholder?: string[]; // The nice text (e.g., "Open")
  onChange?: (value: any) => void;
  placeholder?: string; // The text to show when nothing is selected
  value?: any;    // The actual code value (e.g., "OPEN")
  className?: string; // Allow custom classes from parent
}

export default function Dropdown({
  items,
  itemsPlaceholder,
  onChange = () => {},
  placeholder,
  value,
  className = "",
}: DropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [dropdownRef]);

  if (!items || items.length === 0) return null;

  const getDisplayLabel = (val: any) => {
    const index = items.indexOf(val);
    if (index !== -1 && itemsPlaceholder && itemsPlaceholder[index]) {
      return itemsPlaceholder[index];
    }
    return val;
  };

  const isValueSelected = value !== undefined && value !== null && items.includes(value);
  const currentLabel = isValueSelected ? getDisplayLabel(value) : placeholder;

  return (
    <div
      ref={dropdownRef}
      className={`
        dropdown
        relative flex items-center justify-between gap-3 
        p-2 min-w-[140px] cursor-pointer select-none rounded-md 
        bg-background2 transition-colors hover:bg-accent/10
        ${className}
      `}
      onClick={() => setIsOpen((prev) => !prev)}
    >
      {/* Current Selection / Title */}
      <span className={`text-sm ${!isValueSelected ? "text-muted-foreground" : "font-medium"}`}>
        {currentLabel}
      </span>

      <FontAwesomeIcon
        icon={faCaretDown}
        className={`text-xs text-muted-foreground transition-transform duration-300 ${
          isOpen ? "rotate-180" : ""
        }`}
      />

      {/* Dropdown Menu */}
      <div
        className={`
          absolute left-0 top-full z-50 mt-1 w-full min-w-[140px] origin-top rounded-md 
          border border-border2 bg-background2 shadow-lg 
          transition-all duration-200 ease-out
          ${isOpen ? "opacity-100 scale-100 translate-y-0" : "opacity-0 scale-95 -translate-y-2 pointer-events-none"}
        `}
      >
        <div className="flex flex-col p-1 max-h-60 overflow-y-auto">
          {items.map((item, index) => {
            const isSelected = item === value;
            const label = itemsPlaceholder ? itemsPlaceholder[index] : item;

            return (
              <div
                key={index}
                className={`
                  dropdown
                  flex items-center justify-between rounded-sm px-2 py-1.5 text-sm transition-colors
                  cursor-pointer
                  ${isSelected ? "bg-accent/20 text-primary font-medium" : "hover:bg-accent/10 text-foreground"}
                `}
                onClick={(e) => {
                  e.stopPropagation();
                  onChange(item);
                  setIsOpen(false);
                }}
              >
                <span>{label}</span>
                {/* Optional: Add a checkmark for the selected item */}
                {isSelected && <FontAwesomeIcon icon={faCheck} className="text-xs ml-2" />}
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/_components/Icon.tsx">
interface Props {
	name: string,
	size?: string,
	weight?: string,
  customClasses?: string,
  onClick?: () => void
}

export default function Icon({ name, size, weight, customClasses, onClick }: Props) {
  if (!name) return null

  return (
    <span
      style={{ fontSize: size ? size : '20px', fontWeight: weight ? weight : 'lighter' }}
      className={`material-icons select-none ${customClasses}`}
      onClick={onClick}
    >
      {name}
    </span>
  )
}
</file>

<file path="src/_components/InputDialog.tsx">
import { ReactNode, useState } from 'react';
import { menuHandler } from 'src/_functions/menuHandler';

export interface InputDialogResult {
  name: string;
  description?: string;
}

interface InputDialogProps {
  title: string;
  content?: string | ReactNode;
  nameLabel?: string;
  namePlaceholder?: string;
  descriptionLabel?: string;
  descriptionPlaceholder?: string;
  showDescription?: boolean;
  nameValidation?: (value: string) => string | null; // Returns error message or null if valid
  resolve: (val: InputDialogResult | null) => void;
}

export const InputDialog = ({
  title,
  content,
  nameLabel = 'Name',
  namePlaceholder = 'Enter name...',
  descriptionLabel = 'Description',
  descriptionPlaceholder = 'Enter description (optional)...',
  showDescription = false,
  nameValidation,
  resolve
}: InputDialogProps) => {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleConfirm = () => {
    // Run validation
    if (nameValidation) {
      const validationError = nameValidation(name);
      if (validationError) {
        setError(validationError);
        return;
      }
    }

    // Basic required check
    if (!name.trim()) {
      setError('Name is required');
      return;
    }

    resolve({ name: name.trim(), description: description.trim() || undefined });
    menuHandler.close();
  };

  const handleCancel = () => {
    resolve(null);
    menuHandler.close();
  };

  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setName(e.target.value);
    // Clear error when user starts typing
    if (error) setError(null);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleConfirm();
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      handleCancel();
    }
  };

  const isValid = name.trim().length > 0 && !error;

  return (
    <div className="p-6 flex flex-col gap-4 bg-background2 text-text w-full max-w-md">
      <h2 className="text-xl font-bold">{title}</h2>

      {typeof content === 'string' ? (
        <p className="text-text2">{content}</p>
      ) : (
        content
      )}

      {/* Name Input */}
      <div className="flex flex-col gap-1">
        <label className="text-sm text-text2 font-medium">
          {nameLabel}
        </label>
        <input
          type="text"
          className={`border rounded px-3 py-2 bg-background text-text outline-none focus:ring-0 transition-colors ${error ? 'border-wrong' : 'border-border focus:border-primary'
            }`}
          value={name}
          onChange={handleNameChange}
          onKeyDown={handleKeyDown}
          placeholder={namePlaceholder}
          autoFocus
        />
        {error && (
          <span className="text-sm text-wrong">{error}</span>
        )}
      </div>

      {/* Description Input (optional) */}
      {showDescription && (
        <div className="flex flex-col gap-1">
          <label className="text-sm text-text2 font-medium">
            {descriptionLabel}
          </label>
          <textarea
            className="border border-border rounded px-3 py-2 bg-background text-text focus:border-primary outline-none focus:ring-0 resize-none transition-colors"
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Escape') {
                e.preventDefault();
                handleCancel();
              }
            }}
            placeholder={descriptionPlaceholder}
            rows={3}
          />
        </div>
      )}

      <div className="flex gap-4 justify-end mt-2">
        <button
          onClick={handleCancel}
          className="px-4 py-2 rounded bg-background hover:bg-background-hover text-text text-sm font-semibold transition-colors"
        >
          Cancel
        </button>
        <button
          onClick={handleConfirm}
          disabled={!isValid}
          className={`px-4 py-2 rounded text-sm text-white transition-colors font-semibold
            ${!isValid
              ? 'bg-primary/40 cursor-not-allowed'
              : 'bg-primary hover:bg-primary/80 cursor-pointer'
            }`}
        >
          Create
        </button>
      </div>
    </div>
  );
};

// Helper function to open input dialog
export const inputDialog = (props: Omit<InputDialogProps, 'resolve'>): Promise<InputDialogResult | null> => {
  return new Promise((resolve) => {
    menuHandler.open(
      <InputDialog {...props} resolve={resolve} />,
      { dimBackground: true, background: 'bg-background2', size: 'sm' }
    );
  });
};
</file>

<file path="src/_components/Middleware.tsx">
import { ReactNode, useEffect, useState } from "react";
import middlewareHandler from "src/_functions/middlewareHandler"
import { useLocation, useNavigate } from "react-router-dom";
import { useSession } from "../_providers/SessionProvider";

export default function Middleware({ children }: { children: ReactNode }) {
  const [allowed, setAllowed] = useState(false);
  const [checking, setChecking] = useState(true);

  const location = useLocation();
  const navigate = useNavigate();
  const { session, sessionLoaded } = useSession();

  useEffect(() => {
    let isMounted = true;
    setAllowed(false);
    setChecking(true);

    void (async () => {
      const params = new URLSearchParams(location.search);
      const queryObject: Record<string, string> = {};

      params.forEach((value, key) => {
        queryObject[key] = value;
      });

      let count = 0;
      while (!sessionLoaded) { 
        await new Promise(res => setTimeout(res, 10));
        count++;
        if (count > 500) break; // after 5 seconds we stop waiting for the session
      }

      // const session = await apiRequest({ name: 'session' }) as SessionLayout;
      const result = await middlewareHandler({ location: location.pathname, searchParams: queryObject, session }) as { success: boolean, redirect: string } | undefined;

      if (!isMounted) return;
      if (result?.success) {
        setAllowed(true);
      } else if (result?.redirect) {
        void navigate(result.redirect);
      } else {
        void navigate(-1);
      }

      setChecking(false);

      return () => {
        isMounted = false;
      }

    })();

    //! dont remove isMounted, read below
    //? i dont know why but the isMounted = false will always be false but because of this the navigate(-1) will always redirect to the previous page
    //? if we remove the isMounted variable than it will redirect to the previous page and then to the page before that one and so on wich we dont want
    //? e.g if we are on /test and go to /admin wich is not allowed we come back to /test, if we spam this request we come back to /test but if we remove the isMounted
    //? we first go back to /test but the second time we go back to the route before /test e.g /dashboard wich we dont want
    return () => {
      isMounted = false;
    };
  }, [location.pathname, sessionLoaded]); // important: rerun on path change

  if (checking || !allowed) return null;
  return <div className="w-full h-full">{children}</div>;
}
</file>

<file path="src/_components/Navbar.tsx">
import { ReactNode, useEffect, useRef, useState } from "react";
import { useLocation } from "react-router-dom";
import { SessionLayout } from "config";
import Icon from "./Icon";
import initializeRouter from "./Router";
import Avatar from "./Avatar";
import { useSession } from "../_providers/SessionProvider";
import { apiRequest } from "src/_sockets/apiRequest";

const navbarItems = [
  {
    init: function InitComponent({  session }: NavbarItemProps) {
      if (!session) { return null }
      return (
        <div className="w-6 h-6">
          <Avatar 
            user={session}
          />
        </div>
      )
    },
  },
  {
    icon: 'close_fullscreen',
    label: 'Close sidebar',
    action: ({ setState }: NavbarItemProps) => {
      setState('folded')
    },
    hideOnFolded: true
  },
  {
    icon: 'open_in_full',
    label: 'Show sidebar',
    action: ({ setState }: NavbarItemProps) => {
      setState('expended')
    },
    hideOnExpended: true
  },
  {
    icon: 'home',
    label: 'Test',
    path: '/test'
  },
  {
    icon: 'settings',
    label: 'Settings',
    path: '/settings'
  },
  {
    icon: 'admin_panel_settings',
    label: 'Admin',
    path: '/admin'
  },
  {
    icon: 'logout',
    label: 'Logout',
    bottom: true,
    action: async () => {
      await apiRequest({ name: 'logout' });
    }
  },
]

const activePopups: HTMLElement[] = [];
const clearPopups = () => {
  for (const popup of activePopups) {
    popup.remove();
  }
  activePopups.length = 0;
};

const displayPopup = ({ element, text }: { element: HTMLElement, text: string }) => {
  const popup = document.createElement('div');
  popup.className = `
    bg-gray-200 text-gray-700 rounded-md p-2 absolute z-50 shadow-lg whitespace-nowrap pointer-events-none
    transform scale-90 opacity-0 transition-all duration-200
  `;

  popup.innerHTML = text;

  const rect = element.getBoundingClientRect();
  if (rect.width == 0 && rect.height == 0) { return };
  
  popup.style.position = 'absolute';
  popup.style.top = `${(rect.top + window.scrollY - 10).toString()}px`;
  popup.style.left = `${(rect.left + window.scrollX + rect.width + 5).toString()}px`;
  document.body.appendChild(popup);

  activePopups.push(popup);
  void popup.offsetHeight;

  popup.classList.remove('scale-90', 'opacity-0');
  popup.classList.add('scale-100', 'opacity-100');

  element.addEventListener('mouseleave', () => { 
    popup.remove(); 
    const index = activePopups.indexOf(popup);
    if (index !== -1) activePopups.splice(index, 1);
  }, { once: true });
};

interface NavbarItemProps {
  item: {
    init?: ({ item, state, setState, pathname, session }: {
      item: NavbarItemProps["item"],
      state: NavbarItemProps["state"],
      setState: NavbarItemProps["setState"],
      pathname: NavbarItemProps["pathname"],
      session: NavbarItemProps["session"],
      router: NavbarItemProps["router"]
    }) => ReactNode,
    icon?: string,
    label?: string,
    path?: string,
    action?: ({ item, state, setState, pathname, session }: { 
      item: NavbarItemProps["item"], 
      state: NavbarItemProps["state"], 
      setState: NavbarItemProps["setState"], 
      pathname: NavbarItemProps["pathname"],
      session: NavbarItemProps["session"],
      router: NavbarItemProps["router"]
    }) => void,
    bottom?: boolean,
    hideOnFolded?: boolean,
    hideOnExpended?: boolean
  },
  state: 'folded' | 'expended',
  setState: (state: 'folded' | 'expended') => void,
  pathname: string,
  session: SessionLayout | null,
  router: (location: string) => Promise<void> | void
}

const NavbarItem = ({ item, state, setState, pathname, session, router }: NavbarItemProps) => {
  const toggleId = useRef<number | null>(null);
  return (
   <div className={`hover:bg-gray-200 hover:text-gray-600 w-full h-10 items-center rounded-sm transition-all duration-100 cursor-pointer gap-2 py-2
      ${state == 'expended' && item.hideOnExpended ? 'hidden' :
        state == 'folded' && item.hideOnFolded ? 'hidden' : 
        'flex'
      }
      ${state == 'folded' ? 'px-2' : 'px-2'}
      ${item.path == pathname ? 'bg-gray-200' : ''}
      ${item.bottom ? 'mt-auto' : ''}
    `}
    onMouseEnter={(e) => {
      if (state == 'expended') { return }
      const target = e.currentTarget as HTMLElement;
      const randomId = Math.floor(Math.random() * 1000000000000000);
      toggleId.current = randomId;
      setTimeout(() => {
        requestAnimationFrame(() => {
          if (item.label == undefined) { return }
          if (toggleId.current != randomId) { return }
          console.log('toggleId', toggleId.current);
          displayPopup({ element: target, text: item.label });
        })
      }, 100);
    }}
    onMouseLeave={() => {
      if (state == 'expended') { return }
      toggleId.current = null;
    }}
    onClick={async () => {
      if (item.action) { item.action({ item, state, setState, pathname, session, router }) }
      else if (item.path) { 
        clearPopups();
        void await router(item.path);
        setState('folded');
      }
    }}>
      {item.init ? 
        item.init({ item, state, setState, pathname, session: session, router })
      :
      <>
        <Icon 
          name={item.icon || ''} 
          size={state === 'folded' ? '18px' : '22px'}
          weight={'lighter'}
          customClasses={"relative left-0.75"}
        />
        {state == 'expended' &&
          <div className="line-clamp-1 select-none">{item.label}</div>
        }
      </>
      }
   </div> 
  ) 
}

export default function Navbar() {

  const [state, setState] = useState<'folded' | 'expended'>('folded');
  const location = useLocation();
  const router = initializeRouter()
  const { session } = useSession();

  useEffect(() => {
    clearPopups();
  }, [location.pathname]);

  const ref = useRef<HTMLDivElement>(null);
  const [parentWidth, setParentWidth] = useState<number>(0);

  useEffect(() => {
    const parent = ref.current?.parentElement;
    if (!parent) return;

    const observer = new ResizeObserver((entries) => {
      for (let entry of entries) {
        setParentWidth(entry.contentRect.width);
      }
    });

    observer.observe(parent);

    return () => observer.disconnect();
  }, []);

  if (!session) { return; }

  return (
    <div ref={ref}>
      {parentWidth < 768 &&
        <>
          <div className="w-full py-2 px-4 bg-white text-black flex justify-between items-center">
            <div className="w-8 h-8">
              <Avatar 
                user={session}
              />
            </div>
            <div className="">
              <Icon
                name={state == 'expended'? 'close_fullscreen' : 'open_in_full'}
                size={'22px'}
                weight={'lighter'}
                onClick={() => {
                  const value = state == 'expended'? 'folded' : 'expended';
                  setState(value)
                }}
              />
            </div>
          </div>
        </>
      }
      <div className={`h-full bg-white text-gray-500 flex flex-col items-center @md:py-4 transition-all duration-200 @md:px-2 absolute z-20 @md:z-0 @md:relative
        ${state == 'folded' ? 
          '@md:w-14 w-0 gap-3' : 
          'w-64 gap-1 px-2'
        }`}>

          {(parentWidth >= 768 || state === 'expended') && (
            <>
              {/* Top items */}
              {navbarItems.filter(item => !item.bottom).map((item, index) => {
                const shouldRender = item.init || (item.icon && item.label);
                if (!shouldRender) return null;

                return (
                  <NavbarItem
                    key={index}
                    pathname={location.pathname}
                    item={item}
                    state={state}
                    setState={setState}
                    session={session}
                    router={router}
                  />
                );
              })}

              {/* Bottom items, inside a mt-auto wrapper */}
              <div className="mt-auto w-full flex flex-col gap-2 items-center">
                {navbarItems.filter(item => item.bottom).map((item, index) => {
                  const shouldRender = item.init || (item.icon && item.label);
                  if (!shouldRender) return null;

                  return (
                    <NavbarItem
                      key={`bottom-${index}`}
                      pathname={location.pathname}
                      item={item}
                      state={state}
                      setState={setState}
                      session={session}
                      router={router}
                    />
                  );
                })}
              </div>
            </>
          )}

      </div>
      <div className={`@md:hidden flex absolute top-0 left-0 z-10 bg-black ${state != 'folded' ? 'opacity-80' : 'opacity-0 pointer-events-none'} transition-all duration-300 w-full h-full`}
        onClick={() => { setState('folded') }}>
      </div>
    </div>
  )
}
</file>

<file path="src/_components/ThemeToggler.tsx">
import { useState } from "react";

export default function ThemeToggler() {

  const [theme, setTheme] = useState<"light" | "dark">("dark");

  //? on default we set the theme to the session of the user but we allow to change it using a useState hook
  //? reason for this is that the settings page can display how it looks in the differnt theme without needing to call the server to update the sesion if the user hasnt clicked save yet
  const updateTheme = (newTheme: string) => {
    setTheme(newTheme == 'light' ? newTheme : "dark");
    document.documentElement.classList.toggle("dark", !(newTheme == "light"));
  };

  return { theme, updateTheme };
}
</file>

<file path="src/_components/TranslationProvider.tsx">
// src/_components/translationProvider.tsx
import { createContext, Dispatch, ReactNode, SetStateAction, useContext, useEffect, useMemo, useState } from "react";
import { useSession } from "../_providers/SessionProvider";
import nlJson from "src/_locales/nl.json";
import enJson from "src/_locales/en.json";
import deJson from "src/_locales/de.json";
import frJson from "src/_locales/fr.json";
import config from "config";

const TranslationContext = createContext<{
  translations: Record<string, any>,
  setLanguage: Dispatch<SetStateAction<'nl' | 'en' | 'de' | 'fr'>>;
} | null>(null);

const getLanguage = (language: string) => {
  switch (language) {
    case "nl": return nlJson;
    case "en": return enJson;
    case "de": return deJson;
    case "fr": return frJson;
    default: return enJson;
  }
};

export const TranslationProvider = ({ children }: { children: ReactNode }) => {
  const { session } = useSession();
  // const language = session?.language || config.defaultLanguage;
  const [language, setLanguage] = useState<'nl' | 'en' | 'de' | 'fr'>((session?.language || config.defaultLanguage) as 'nl' | 'en' | 'de' | 'fr');
  const translations = useMemo(() => getLanguage(language), [language]);

  useEffect(() => {
    if (session?.language) {
      setLanguage(session.language as 'nl' | 'en' | 'de' | 'fr');
    }
  },  [window.location.pathname, session])

  return (
    <TranslationContext.Provider value={{ translations, setLanguage }}>
      {children}
    </TranslationContext.Provider>
  );
};

export const useTranslation = () => {
  const context = useContext(TranslationContext);
  if (!context) {
    throw new Error("useTranslation must be used within a TranslationProvider");
  }
  return context.translations;
};

export const useUpdateLanguage = () => {
  const context = useContext(TranslationContext);
  if (!context) {
    throw new Error("setLanguage must be used within a TranslationProvider");
  }
  return context.setLanguage;
}

// helper function for dynamic translation
export const translate = ({ translationList, key, params }: {
  translationList: Record<string, any>,
  key: string,
  params?: { key: string, value: string | number | boolean }[]
}) => {
  let result = key.split(".").reduce((acc: any, part) => acc?.[part], translationList);
  if (typeof result !== "string") return key;
  if (!params) return result;

  for (const param of params) {
    if (!param.key) continue;
    if (typeof param.value === "undefined") continue;
    const regex = new RegExp(`{{${param.key}}}`, "g");
    result = result.replace(regex, param.value.toString());
  }
  return result;
};
</file>

<file path="src/_functions/confetti.ts">
declare const confetti: (options: { particleCount: number; spread: number; origin: { y: number } }) => void;

//? function makes confetti appear on the screen
export default function launchConfetti(): void {
  if (typeof confetti === 'function') {
    confetti({
      particleCount: 100,
      spread: 70,
      origin: { y: 0.6 },
    });
  } else {
    console.warn("Confetti script is not loaded yet.");
  }
};
</file>

<file path="src/_functions/icon.ts">
// src/icons.ts
export { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
export * from "@fortawesome/free-solid-svg-icons";
// export * from "@fortawesome/free-regular-svg-icons";
// export * from "@fortawesome/free-brands-svg-icons";
</file>

<file path="src/_functions/menuHandler.ts">
import { ReactElement } from 'react';
import { useMenuHandler } from 'src/_components/MenuHandler';

interface MenuOptions {
  dimBackground?: boolean;
  background?: string;
  size?: 'sm' | 'md' | 'lg';
}

let handler: ReturnType<typeof useMenuHandler> | null = null;
export const setMenuHandlerRef = (ref: ReturnType<typeof useMenuHandler>) => {
  handler = ref;
};

export const menuHandler = {
  open: async (component: ReactElement, options?: MenuOptions) => {
    if (!handler) throw new Error('MenuHandler is not initialized');
    return await handler.open(component, options);
  },
  replace: async (component: ReactElement, options?: MenuOptions) => {
    if (!handler) throw new Error('MenuHandler is not initialized');
    return await handler.replace(component, options);
  },
  close: (success?: boolean) => {
    handler?.close();
    return success;
  },
  closeAll: () => handler?.closeAll(),
  logStack: () => handler?.logStack()
};
</file>

<file path="src/_functions/notify.ts">
import { toast } from "sonner";
import { translate } from "src/_components/TranslationProvider";
import nlJson from "src/_locales/nl.json";
import enJson from "src/_locales/en.json";
import deJson from "src/_locales/de.json";
import frJson from "src/_locales/fr.json";
import { getCurrentSession } from "src/_providers/SessionProvider";
// import Translator from "./translator";

const Translator = () => {
  const session = getCurrentSession();
  if (!session) { return }

  switch (session.language) {
    case "nl": return nlJson;
    case "en": return enJson;
    case "de": return deJson;
    case "fr": return frJson;
    default: return enJson;
  }
}

const notify = {
  success: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.success(translate({ translationList, key, params })); }
  },
  error: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.error(translate({ translationList, key, params })); }
  },
  info: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.info(translate({ translationList, key, params })); }
  },
  warning: ({ key, params }: { key: string, params?: { key: string, value: string | number | boolean }[]}) => {
    const translationList = Translator();
    if (translationList) {toast.warning(translate({ translationList, key, params })); }
  },
}

export default notify;
</file>

<file path="src/_functions/sleep.ts">
export default function sleep(ms: number) {
  return new Promise<void>((resolve) => setTimeout(resolve, ms));
}
</file>

<file path="src/_functions/translator.ts">
// useTranslator.ts
import { useTranslation, translate } from "src/_components/TranslationProvider";

export const useTranslator = () => {
  const translations = useTranslation();
  return ({ key, params }: { key: string; params?: { key: string; value: string | number | boolean }[] }) =>
    translate({ translationList: translations, key, params });
};
</file>

<file path="src/_functions/tryCatch.ts">
//? wrap your funcions in this function and check if the first value has a truthy value if it does than there is an error
//? if the first value is null than there is no error and you can access the second value wich is the response of your function
export default async function <T, P>(
  func: (values: P) => Promise<T> | T, 
  params?: P
): Promise<[unknown, T | null]> {
  try {
    const response = await func(params as P);
    return [null, response];
  } catch (error: unknown) {
    return [error, null];
  }
}
</file>

<file path="src/_locales/de.json">
{
  "test": "Hallo {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "FEHLER",
    "404": "Etwas ist schiefgelaufen, versuche es später erneut."
  },
  "middleware": {
    "notAdmin": "Du bist kein Admin."
  },
  "login": {
    "empty": "Keine E-Mail oder kein Passwort angegeben.",
    "emailCharacterLimit": "E-Mail darf nicht länger als 191 Zeichen sein.",
    "passwordCharacterMinimum": "Passwort muss mindestens 8 Zeichen lang sein.",
    "passwordCharacterLimit": "Passwort darf nicht länger als 191 Zeichen sein.",
    "nameCharacterLimit": "Name darf nicht länger als 191 Zeichen sein.",
    "invalidEmailFormat": "Ungültiges E-Mail-Format.",
    "passwordNotMatch": "Passwörter stimmen nicht überein.",
    "emailExists": "E-Mail existiert bereits.",
    "userCreated": "Benutzer erstellt.",
    "createUserFailed": "Fehler beim Erstellen des Benutzers.",
    "userNotFound": "Benutzer nicht gefunden.",
    "wrongPassword": "Passwort stimmt nicht überein.",
    "loggedIn": "Benutzer eingeloggt.",
    "providerNotFound": "Provider nicht gefunden.",
    "noReason": "Kein Grund angegeben."
  },
  "settings": {
    "changeAvatar": "Avatar ändern",
    "changeAvatarDescription": "JPG, GIF oder PNG. Max 4 MB.",
    "language": {
      "title": "Sprache",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Thema",
      "light": "Hell",
      "dark": "Dunkel"
    },
    "saveChanges": "Änderungen speichern",
    "updatedUser": "Benutzer aktualisiert",
    "failedUpdateUser": "Fehler beim Aktualisieren des Benutzers",
    "noChangesMade": "Keine Änderungen vorgenommen",
    "sizeToLarge": "Maximale Uploadgröße ist 4~5 MB, wähle ein kleineres Bild!!",
    "loadingImg": "Foto wird geladen",
    "imgLoaded": "Foto wurde geladen"
  }
}
</file>

<file path="src/_locales/en.json">
{
  "test": "Hallo {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "ERROR",
    "404": "Something went wrong, try again later."
  },
  "middleware": {
    "notAdmin": "You are not an admin."
  },
  "login": {
    "empty": "No email or password provided.",
    "emailCharacterLimit": "Email can't be longer than 191 characters.",
    "passwordCharacterMinimum": "Password must be at least 8 characters long.",
    "passwordCharacterLimit": "Password can't be longer than 191 characters.",
    "nameCharacterLimit": "Name can't be longer than 191 characters.",
    "invalidEmailFormat": "Invalid email format.",
    "passwordNotMatch": "Passwords do not match.",
    "emailExists": "Email already exists.",
    "userCreated": "User created.",
    "createUserFailed": "Failed to create new user.",
    "userNotFound": "User not found.",
    "wrongPassword": "Password does not match.",
    "loggedIn": "User logged in.",
    "providerNotFound": "Provider not found.",
    "noReason": "No reason provided."
  },
  "settings": {
    "changeAvatar": "Change avatar",
    "deleteAvatar": "Delete avatar",
    "changeAvatarDescription": "JPG, GIF or PNG. 4MB max.",
    "language": {
      "title": "Language",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Theme",
      "light": "Light",
      "dark": "Dark"
    },
    "saveChanges": "Save changes",
    "updatedUser": "updated the user",
    "failedUpdateUser": "Failed to update the user",
    "noChangesMade": "No changes made",
    "sizeToLarge": "Max upload size is 4~5 MB, chose a smaller img!!",
    "loadingImg": "Photo is loading",
    "imgLoaded": "Photo has loaded"
  }
}
</file>

<file path="src/_locales/fr.json">
{
  "test": "Bonjour {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "ERREUR",
    "404": "Un problème est survenu, réessayez plus tard."
  },
  "middleware": {
    "notAdmin": "Vous n'êtes pas administrateur."
  },
  "login": {
    "empty": "Aucun e-mail ou mot de passe fourni.",
    "emailCharacterLimit": "L'e-mail ne peut pas dépasser 191 caractères.",
    "passwordCharacterMinimum": "Le mot de passe doit comporter au moins 8 caractères.",
    "passwordCharacterLimit": "Le mot de passe ne peut pas dépasser 191 caractères.",
    "nameCharacterLimit": "Le nom ne peut pas dépasser 191 caractères.",
    "invalidEmailFormat": "Format d'e-mail invalide.",
    "passwordNotMatch": "Les mots de passe ne correspondent pas.",
    "emailExists": "L'e-mail existe déjà.",
    "userCreated": "Utilisateur créé.",
    "createUserFailed": "Échec de la création de l'utilisateur.",
    "userNotFound": "Utilisateur non trouvé.",
    "wrongPassword": "Le mot de passe est incorrect.",
    "loggedIn": "Utilisateur connecté.",
    "providerNotFound": "Fournisseur introuvable.",
    "noReason": "Aucune raison fournie."
  },
  
  "settings": {
    "changeAvatar": "Changer d'avatar",
    "changeAvatarDescription": "JPG, GIF ou PNG. Max 4 Mo.",
    "language": {
      "title": "Langue",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Thème",
      "light": "Clair",
      "dark": "Sombre"
    },
    "saveChanges": "Enregistrer les modifications",
    "updatedUser": "utilisateur mis à jour",
    "failedUpdateUser": "Échec de la mise à jour de l'utilisateur",
    "noChangesMade": "Aucun changement effectué",
    "sizeToLarge": "La taille maximale est de 4~5 Mo, choisissez une image plus petite !!",
    "loadingImg": "La photo est en cours de chargement",
    "imgLoaded": "La photo a été chargée"
  }
}
</file>

<file path="src/_locales/nl.json">
{
  "test": "Hallo {{name}}",
  "common": {
    "whiteSpace": " ",
    "error": "FOUT",
    "404": "Er is iets misgegaan, probeer het later opnieuw."
  },
  "middleware": {
    "notAdmin": "Je bent geen admin."
  },
  "login": {
    "empty": "Geen e-mail of wachtwoord opgegeven.",
    "emailCharacterLimit": "E-mail mag niet langer zijn dan 191 tekens.",
    "passwordCharacterMinimum": "Wachtwoord moet minimaal 8 tekens lang zijn.",
    "passwordCharacterLimit": "Wachtwoord mag niet langer zijn dan 191 tekens.",
    "nameCharacterLimit": "Naam mag niet langer zijn dan 191 tekens.",
    "invalidEmailFormat": "Ongeldig e-mailformaat.",
    "passwordNotMatch": "Wachtwoorden komen niet overeen.",
    "emailExists": "E-mail bestaat al.",
    "userCreated": "Gebruiker aangemaakt.",
    "createUserFailed": "Gebruiker aanmaken mislukt.",
    "userNotFound": "Gebruiker niet gevonden.",
    "wrongPassword": "Wachtwoord komt niet overeen.",
    "loggedIn": "Gebruiker ingelogd.",
    "providerNotFound": "Provider niet gevonden.",
    "noReason": "Geen reden opgegeven."
  },
  "settings": {
    "changeAvatar": "Verander avatar",
    "changeAvatarDescription": "JPG, GIF of PNG. Max 4MB.",
    "language": {
      "title": "Taal",
      "nl": "NL",
      "en": "EN",
      "de": "DE",
      "fr": "FR"
    },
    "theme": {
      "title": "Thema",
      "light": "Licht",
      "dark": "Donker"
    },
    "saveChanges": "Wijzigingen opslaan",
    "updatedUser": "gebruiker bijgewerkt",
    "failedUpdateUser": "Bijwerken gebruiker mislukt",
    "noChangesMade": "Geen wijzigingen gemaakt",
    "sizeToLarge": "Maximale uploadgrootte is 4~5 MB, kies een kleinere afbeelding!!",
    "loadingImg": "Foto word geladen",
    "imgLoaded": "Foto is geladen"
  }
}
</file>

<file path="src/_providers/socketStatusProvider.tsx">
import {
  createContext,
  useContext,
  useState,
  ReactNode,
  Dispatch,
  SetStateAction,
} from "react";

export type SOCKETSTATUS =
  | "CONNECTED"
  | "DISCONNECTED"
  | "RECONNECTING"
  | "STARTUP";

export interface statusContent {
  status: SOCKETSTATUS;
  reconnectAttempt?: number;
  endTime?: number;
}

interface SocketStatusContextType {
  socketStatus: {
    self: statusContent;
    [userId: string]: statusContent;
  };
  setSocketStatus: Dispatch<
    SetStateAction<{
      self: statusContent;
      [userId: string]: statusContent;
    }>
  >;
}

const SocketStatusContext = createContext<SocketStatusContextType | undefined>(
  undefined
);

export const SocketStatusProvider = ({ children }: { children: ReactNode }) => {
  const [socketStatus, setSocketStatus] = useState({
    self: {
      status: "STARTUP" as SOCKETSTATUS,
    },
  });

  return (
    <SocketStatusContext.Provider value={{ socketStatus, setSocketStatus }}>
      {children}
    </SocketStatusContext.Provider>
  );
};

export const useSocketStatus = () => {
  const context = useContext(SocketStatusContext);
  if (!context) {
    throw new Error("useSocketStatus must be used within a SocketStatusProvider");
  }
  return context;
};
</file>

<file path="src/_sockets/apiRequest.ts">
import { dev } from "config";
import { toast } from "sonner";
import { incrementResponseIndex, socket, waitForSocket } from "./socketInitializer";
const env = import.meta.env;

//? if we use apiRequest function and the called api name starts with 1 of the names below we apply a abort controller
const abortControllers = new Map<string, AbortController>();
const abortControllerNames = ['get', 'fetch', 'load', 'is', 'has', 'list', 'all', 'search', 'view', 'retrieve'];

interface apiRequestType {
  name: string;
  data?: object;
}

export interface apiRequestReponse {
  status: 'success' | 'error' | any;
  result?: Record<string, any> | any;
  message?: string;
  messageParams?: Record<string, any>;
}

export const apiRequest = ({ name, data }: apiRequestType) => {
  return new Promise(async (resolve, reject) => {
    if (!name || typeof name !== "string") {
      if (dev) {
        console.error("Invalid name");
        toast.error("Invalid name");
      }
      return resolve(null);
    }

    if (!data || typeof data !== "object") {
      data = {};
    }

    if (!await waitForSocket()) { return resolve(null); }
    if (!socket) { return resolve(null); }
  
    const useAbortController = abortControllerNames.some((tempName) => name.startsWith(tempName)) && env.VITE_SESSION_BASED_TOKEN != 'true';
    const pathname = window.location.pathname;
    const fullname = name != 'session' && name != 'logout' ? `api${pathname}/${name}` : name;
    // example: api/games/boerZoektVrouw/getGameData
  
    let signal: AbortSignal | null = null;
    let abortFunc = () => {};

    if (useAbortController) {
      if (abortControllers.has(fullname)) {
        //? if we have an abort controller we abort it and create a new one
        const prevAbortController = abortControllers.get(fullname);
        prevAbortController?.abort();
      }
      //? here we create a new abort controller and add it to the map with the api fullname as the key
      const abortController = new AbortController();
      abortControllers.set(fullname, abortController);
      abortFunc = () => {
        if (signal) { signal.removeEventListener("abort", abortFunc); }
        reject(`Request ${fullname} aborted`)
      };
      //? here we bind the abortFunc to the abort event so it will be called when the abort controller is aborted
      signal = abortController.signal;
      signal.addEventListener("abort", abortFunc);
    }

    const tempIndex = incrementResponseIndex();
    socket.emit('apiRequest', { name: fullname, data, responseIndex: tempIndex });
    
    if (dev && name != 'session' && name != 'logout') { console.log(`Client API Request(${tempIndex}): `, { name, data }) }
    socket.once(`apiResponse-${tempIndex}`, ({ result, message, status }: {
      result: any;
      message: string;
      status: "success" | "error";
    }) => {
      if (signal && signal.aborted) { return; }

      if (status === "error") {
        if (dev) {
          console.error('message:', message);
          toast.error(message);
        }
        return resolve({
          status,
          message
        })
      }

      if (dev && name != 'session' && name != 'logout') { console.log(`Server API Response(${tempIndex}): `, { name, ...result }) }
      if (dev && name == 'session') { console.log(`Session result(${tempIndex}): `, result) }
      if (dev && name == 'logout') { console.log(`Logout result(${tempIndex}): `, result) }

      if (signal) {
        signal.removeEventListener("abort", abortFunc);
        abortControllers.delete(fullname);
      }
      
      resolve(result)
    });
  })
}
</file>

<file path="src/_sockets/syncRequest.ts">
import { dev, SessionLayout } from "config";
import { toast } from "sonner";
import { incrementResponseIndex, socket, waitForSocket } from "./socketInitializer";
import { statusContent } from "src/_providers/socketStatusProvider";
import { Dispatch, RefObject, SetStateAction } from "react";

const syncEvents: Record<string, ((params: { clientData: any; serverData: any; aditionalData: any }) => void)> = {};

type syncRequestType = {
  name: string;
  data?: object | null;
  receiver: any;
  ignoreSelf?: boolean;
}

export const syncRequest = async ({ name, data, receiver, ignoreSelf }: syncRequestType) => {
  return new Promise(async (resolve) => {
    if (!name || typeof name !== "string") {
      if (dev) {
        console.error("Invalid name for syncRequest");
        toast.error("Invalid name for syncRequest");
      }
      return resolve(null);
    }
  
    if (!data || typeof data !== "object") {
      data = {};
    }
  
    if (!receiver) {
      if (dev) {
        console.error("You need to provide a receiver for syncRequest, this can be either 'all' to trigger all sockets wich we dont recommend or it can be any value such as a code e.g 'Ag2cg4'. this works together with the joinRoom and leaveRoom function");
        toast.error("You need to provide a receiver for syncRequest, this can be either 'all' to trigger all sockets wich we dont recommend or it can be any value such as a code e.g 'Ag2cg4'. this works together with the joinRoom and leaveRoom function");
      }
      return resolve(null);
    }
  
    if (!await waitForSocket()) { return resolve(null); }
    if (!socket) { return resolve(null); }
    
    const tempIndex = incrementResponseIndex();
    const pathname = window.location.pathname;
    const fullName = `sync${pathname}/${name}`;
    //? example: api/games/boerZoektVrouw/getGameData
  
    if (dev) { console.log(`Client Sync Request: `, { name, data, receiver, ignoreSelf }) }
  
    socket.emit('sync', { name: fullName, data, cb: name, receiver, responseIndex: tempIndex, ignoreSelf });

    socket.once(`sync-${tempIndex}`, (data: { status: "success" | "error", message: string }) => {
      if (data.status === "error") {
        if (dev) {
          console.error(`Sync ${name} failed: ${data.message}`);
          toast.error(`Sync ${name} failed: ${data.message}`);
        }
        return resolve(false);
      }
      resolve(data.status == "success");
    });
  })
}

export const useSyncEvents = () => {

  const upsertSyncEventCallback = (name: string, cb: (params: { clientData: any; serverData: any; }) => void) => {
    const path = window.location.pathname;
    syncEvents[`sync${path}/${name}`] = cb;
  }

  return { upsertSyncEventCallback };
}

export const useSyncEventTrigger = () => {

  const triggerSyncEvent = (name: string, clientData: any = {}, serverData: any = {}, aditionalData: any = {}) => {
    const cb = syncEvents[name];
    if (!cb) {
      if (dev) {
        console.log(syncEvents)
        console.error(`Sync event ${name} not found`);
        toast.error(`Sync event ${name} not found`);
      }
      return;
    }
    if (typeof cb == 'function') {
      cb({ clientData, serverData, aditionalData });
    }
  }

  return { triggerSyncEvent }
}

export const initSyncRequest = async ({
  socketStatus, 
  setSocketStatus,
  sessionRef
}: {
  socketStatus: {
    self: statusContent;
    [userId: string]: statusContent;
  };
  setSocketStatus: Dispatch<
    SetStateAction<{
      self: statusContent;
      [userId: string]: statusContent;
    }>
  >;
  sessionRef: RefObject<SessionLayout> | null;
}) => {

  if (!await waitForSocket()) { return; }
  if (!socket) { return; }
  if (!sessionRef) { return; }

  socket.on("connect", () => {
    console.log(socketStatus)
    console.log("Connected to server");
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "CONNECTED",
        // reconnectAttempt: undefined,
      }
    }));
  });

  socket.on("disconnect", () => {
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "DISCONNECTED",
      }
    }));
    console.log("Disconnected, trying to reconnect...");
  });

  socket.on("reconnect_attempt", (attempt) => {
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "RECONNECTING",
        reconnectAttempt: attempt,
      }
    }));
    console.log(`Reconnecting attempt ${attempt}...`);
  });

  //? will not trigger when you call this event
  socket.on("userAfk", ({ userId, endTime }) => {
    if (userId == sessionRef.current?.id) { 
      setSocketStatus(prev => ({
        ...prev,
        self: {
          status: "DISCONNECTED",
          reconnectAttempt: undefined,
          endTime
        }
      }));
    } else {
      setSocketStatus(prev => ({
        ...prev,
        [userId]: {
          status: "DISCONNECTED",
          endTime
        }
      }));
    }
  });

  //? will not trigger when you call this event
  socket.on("userBack", ({ userId }) => {
    console.log("userBack", { userId });
    
    setSocketStatus(prev => {
      const newStatus = { ...prev };
      newStatus[userId] = {
        status: "CONNECTED",
        endTime: undefined,
      };
      return newStatus;
    });
  });

  socket.on("connect_error", (err) => {
    console.log("connect_error", { err });
    setSocketStatus(prev => ({
      ...prev,
      self: {
        ...prev.self,
        status: "DISCONNECTED",
        reconnectAttempt: undefined,
      }
    }));
    if (dev) {
      console.error(`Connection error: ${err.message}`);
      toast.error(`Connection error: ${err.message}`);
    }
  });

}
</file>

<file path="src/login/page.tsx">
import LoginForm from "src/_components/LoginForm";

export const template = 'plain';
export default function App() {
  return (
    <div className="w-full h-full flex flex-col items-center justify-center bg-background">
      <LoginForm formType="login" />
    </div>
  )
}
</file>

<file path="src/main.tsx">
import { createRoot } from 'react-dom/client'
import { createBrowserRouter, RouterProvider } from 'react-router-dom'
import { Toaster } from 'sonner'
import 'src/index.css'
import 'src/scrollbar-dark.css'
import VConsole from 'vconsole';
import { mobileConsole } from 'config'
import LocationProvider from 'src/_components/LocationProvider'
import { MenuHandlerProvider } from './_components/MenuHandler'
import TemplateProvider from './_components/TemplateProvider'
import type { Template } from './_components/TemplateProvider';
import { AvatarProvider } from './_components/AvatarProvider'
import { SessionProvider } from './_providers/SessionProvider'
import { TranslationProvider } from './_components/TranslationProvider'
import { SocketStatusProvider } from './_providers/socketStatusProvider'

type PageWithTemplate = React.ComponentType & { template?: Template };
const getRoutes = (pages: Record<string, { default: PageWithTemplate, template?: Template }>) => {
  const routes = [];

  for (const [path, module] of Object.entries(pages)) {
    const pathSegments = path.split('/');
    if (pathSegments.some(segment => segment.startsWith('_'))) continue;

    const routePath = path.replace('./', '').replace('.tsx', '').toLowerCase() || '/';
    const subPath = routePath.endsWith('/page')
      ? routePath.slice(0, -5)
      : routePath.endsWith('page')
      ? '/'
      : false;
    if (!subPath) continue;

    const template = module.template ?? 'plain';
    const Page = module.default;

    routes.push({
      path: subPath,
      element: (
        <LocationProvider>
            <TemplateProvider key={`${template}-${subPath}`} initialTemplate={template}>
              <Page />
            </TemplateProvider>
        </LocationProvider>
      ),
    });
  }

  return routes;
};

//! eslint will tell you that the as Record<string, { default: React.ComponentType }> is not needed but it is for typescript to know what the type of pages is
const pages = import.meta.glob('./**/*.tsx', { eager: true }) as Record<
  string,
  { default: React.ComponentType; template?: Template }
>;
const router = createBrowserRouter([{
  path: '/',
  children: getRoutes(pages)
}])

if (mobileConsole) { new VConsole(); }

const root = document.getElementById("root");
if (root) {
  createRoot(root).render(
    <div className='w-full h-safe m-0 p-0 overflow-hidden'>
      <Toaster richColors />
        <SocketStatusProvider>
          <SessionProvider>
            <TranslationProvider>
              <AvatarProvider>
                <MenuHandlerProvider>
                    <RouterProvider router={router}/>
                </MenuHandlerProvider>
              </AvatarProvider>
            </TranslationProvider>
          </SessionProvider>
        </SocketStatusProvider>
    </div>
  );
}
</file>

<file path="src/page.tsx">
import config from "config";
import { useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { useSession } from "./_providers/SessionProvider";
const env = import.meta.env;

export const template = 'plain'
export default function App() {
  const navigate = useNavigate();
  const location = useLocation();
  const { session, sessionLoaded } = useSession();

  useEffect(() => {
 
    const params = new URLSearchParams(location.search);
    const token = params.get('token');
    if (token && env.VITE_SESSION_BASED_TOKEN == 'true') {
      sessionStorage.setItem('token', token);
      window.location.href = window.location.pathname;
      return;
    }

    if (sessionLoaded) {
      if (session?.id) {
        navigate(config.loginRedirectUrl);
      } else {
        navigate(config.loginPageUrl);
      }
    }

  }, [navigate, location, session, sessionLoaded]);

  useEffect(() => {
    let timeout = setTimeout(() => {
      if (!sessionLoaded) {
        navigate(config.loginPageUrl)
      }
    }, 1000);
    return () => {
      clearTimeout(timeout)
    }
  }, [sessionLoaded])


  return null;
}
</file>

<file path="src/register/page.tsx">
import LoginForm from "src/_components/LoginForm";

export const template = 'plain';
export default function App() {
    return (
      <div className="w-full h-full flex flex-col items-center justify-center bg-background">
        <LoginForm formType="register" />
      </div>
    )
}
</file>

<file path="src/sandbox/_components/grid/ErrorBoundary.tsx">
import React, { Component, ErrorInfo, ReactNode } from "react";

interface Props {
  children: ReactNode;
  fallback?: (error: Error) => ReactNode;
  resetKey?: any; // Changing this key resets the error boundary
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  public componentDidUpdate(prevProps: Props) {
    if (prevProps.resetKey !== this.props.resetKey) {
      this.setState({ hasError: false, error: null });
    }
  }

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback(this.state.error!);
      }
      return (
        <div className="p-4 bg-red-900/50 border border-wrong rounded text-red-200 overflow-auto">
          <h3 className="font-bold mb-2">Runtime Error</h3>
          <pre className="text-xs">{this.state.error?.message}</pre>
        </div>
      );
    }

    return this.props.children;
  }
}
</file>

<file path="src/sandbox/_components/grid/ScreenRenderer.tsx">
import React, { useEffect, useMemo, useState } from "react";
import { compileTSX, loadModule } from "../../_functions/codeEditor/babel/compiler";
import { ErrorBoundary } from "./ErrorBoundary";

interface ScreenRendererProps {
  code: string;
  id: string;
  name: string;
  className?: string;
  style?: React.CSSProperties;
  onClick?: () => void;
}

export const ScreenRenderer = ({ code, id, className, style, onClick }: ScreenRendererProps) => {
  const [debouncedCode, setDebouncedCode] = useState(code);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedCode(code);
    }, 1000);

    return () => clearTimeout(timer);
  }, [code]);

  const Component = useMemo(() => {
    const compiled = compileTSX(debouncedCode);
    return loadModule(compiled) as React.ComponentType;
  }, [debouncedCode]);

  return (
    <div
      style={style}
      className={className}
      onClick={onClick}
    >
      <ErrorBoundary resetKey={debouncedCode}>
        <Component />
      </ErrorBoundary>
    </div>
  );
};
</file>

<file path="src/sandbox/_components/menus/NoteOptionsMenu.tsx">
import { motion, AnimatePresence } from "framer-motion";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { NoteOptions, NoteOptionsCommands, NoteOptionsIcons, NoteOptionsVisibleState } from "src/sandbox/types/NotesOptionsTypes";
import { useNotes } from "src/sandbox/_providers/NotesContextProvider";
import { useEffect, useState } from "react";

export default function NoteOptionsMenu() {

  const {
    noteOptionsMenuOpen,
    setNoteOptionsMenuOpen,
    noteOptionsMenuPosition,
    lastActiveEditor
  } = useNotes();

  const [searchInput, setSearchInput] = useState("");
  const [selectedIndex, setSelectedIndex] = useState(0);

  const closeMenuAndRestoreFocus = (shouldRestorePosition = true) => {
    setNoteOptionsMenuOpen(NoteOptionsVisibleState.CLOSED);

    // Restore focus to the editor at the saved position
    if (lastActiveEditor && shouldRestorePosition) {
      const { editor, position } = lastActiveEditor;

      // Use setTimeout to ensure menu is closed before focusing
      setTimeout(() => {
        editor.commands.focus();
        editor.commands.setTextSelection(position);
      }, 50);
    }
  };

  useEffect(() => {
    if (noteOptionsMenuOpen != NoteOptionsVisibleState.OPEN) { return; }

    setSearchInput("");
    setSelectedIndex(0);

    const handleClickOutside = (event: MouseEvent) => {
      const menu = document.getElementById("noteOptionsMenu");
      if (menu && !menu.contains(event.target as Node)) {
        closeMenuAndRestoreFocus();
      }
    }

    document.addEventListener("click", handleClickOutside);

    return () => {
      document.removeEventListener("click", handleClickOutside);
    };
  }, [noteOptionsMenuOpen])

  // Handle keyboard navigation
  useEffect(() => {
    if (noteOptionsMenuOpen != NoteOptionsVisibleState.OPEN) { return; }

    const handleKeyDown = (event: KeyboardEvent) => {
      const visibleOptions = Object.values(NoteOptions).filter(option =>
        option.toLowerCase().includes(searchInput.toLowerCase())
      );

      if (event.key === "Escape") {
        event.preventDefault();
        closeMenuAndRestoreFocus();
      } else if (event.key === "ArrowDown") {
        event.preventDefault();
        setSelectedIndex(prev => Math.min(prev + 1, visibleOptions.length - 1));
      } else if (event.key === "ArrowUp") {
        event.preventDefault();
        setSelectedIndex(prev => Math.max(prev - 1, 0));
      } else if (event.key === "Enter") {
        event.preventDefault();
        if (visibleOptions[selectedIndex] && lastActiveEditor) {
          const { editor } = lastActiveEditor;
          const command = NoteOptionsCommands[visibleOptions[selectedIndex]];
          setNoteOptionsMenuOpen(NoteOptionsVisibleState.CLOSED);
          command(editor);
        }
      }
    }

    document.addEventListener("keydown", handleKeyDown);

    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [noteOptionsMenuOpen, searchInput, selectedIndex, lastActiveEditor])

  // Reset selected index when search changes
  useEffect(() => {
    setSelectedIndex(0);
  }, [searchInput])

  if (!noteOptionsMenuPosition) { return null; }
  return (
    <AnimatePresence>
      {noteOptionsMenuOpen == NoteOptionsVisibleState.OPEN && (
        <motion.div
          initial={{ opacity: 0, scale: 0.90, y: -5 }}
          animate={{ opacity: 1, scale: 1, y: 0 }}
          exit={{ opacity: 0, scale: 0.90, y: -5 }}
          transition={{ duration: 0.2 }}
          style={{
            position: "absolute",
            zIndex: 1000,
          }}
        >
          <div
            className="MENU bg-background2 rounded gap-3 flex flex-col w-72 shadow-xl border border-border2 text-text"
            style={{
              position: "absolute",
              left: noteOptionsMenuPosition.x,
              top: noteOptionsMenuPosition.y,
              transform: 'translate(20px, calc(-100px + -50%))',
            }}
            id="noteOptionsMenu"
          >
            <div className="flex flex-col text-sm">

              <div className="py-2 px-4 border-b border-border2">
                <input
                  type="text"
                  className="w-full h-full focus:outline-none"
                  placeholder="Insert block..."
                  autoFocus={true}
                  value={searchInput}
                  onChange={(e) => setSearchInput(e.target.value)}
                ></input>
              </div>


              {/* <div className="text-xs font-bold text-text2 uppercase tracking-wider px-1">
                Create
              </div> */}
              <div className="p-2 gap-2 flex flex-col">
                {Object.values(NoteOptions).map((option, index) => {

                  if (!option.toLowerCase().includes(searchInput.toLowerCase())) {
                    return null;
                  }

                  // Calculate actual visible index
                  const visibleOptions = Object.values(NoteOptions).filter(opt =>
                    opt.toLowerCase().includes(searchInput.toLowerCase())
                  );
                  const visibleIndex = visibleOptions.indexOf(option);
                  const isSelected = visibleIndex === selectedIndex;

                  const Icon = NoteOptionsIcons[option];
                  return (
                    <div
                      key={option}
                      className={`p-1 rounded cursor-pointer ${isSelected ? 'bg-background2-hover' : 'hover:bg-background2-hover'}`}
                      onClick={() => { 
                        if (lastActiveEditor) {
                          const { editor } = lastActiveEditor;
                          const command = NoteOptionsCommands[option];
                          setNoteOptionsMenuOpen(NoteOptionsVisibleState.CLOSED);
                          command(editor);
                        }
                      }}
                      onMouseEnter={() => setSelectedIndex(visibleIndex)}
                    >
                      <FontAwesomeIcon icon={Icon} className="text-muted mr-2" />
                      {option}
                    </div>
                  )
                })}
              </div>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  )
}
</file>

<file path="src/sandbox/_functions/codeEditor/autocompletions/autocompletionHandler.ts">
import * as monaco from "monaco-editor";
import { HTMLTagCloser } from "./JSX";
import { ReactHooksImporter } from "./reactHooks";

export default function loadAutoCompletions(monaco: typeof import("monaco-editor")) {

  const autoCompletions: monaco.IDisposable[] = []

  autoCompletions.push(HTMLTagCloser(monaco));
  autoCompletions.push(ReactHooksImporter(monaco));

  // Clean up on dispose
  return () => {
    autoCompletions.forEach((disposable) => disposable.dispose());
  };
}
</file>

<file path="src/sandbox/_functions/codeEditor/autocompletions/customComponents.ts">

</file>

<file path="src/sandbox/_functions/codeEditor/autocompletions/JSX.ts">
export function HTMLTagCloser(monaco: typeof import("monaco-editor")) {
  return monaco.languages.registerCompletionItemProvider("typescript", {
    triggerCharacters: [">"],
    provideCompletionItems: (model, position) => {
      const lineContent = model.getLineContent(position.lineNumber);
      const tagEndIndex = lineContent.indexOf(">");
      const trimmedLineContext = lineContent.trim();

      if (trimmedLineContext.startsWith("<") && !trimmedLineContext.startsWith("</") && trimmedLineContext.endsWith(">")) {
        const tagName = trimmedLineContext
          .slice(
            1,
            trimmedLineContext.indexOf(" ") > -1
              ? trimmedLineContext.indexOf(" ")
              : trimmedLineContext.indexOf(">")
          )
          .replace(/\/?>$/, "");

        const insertTextClassname = ` className={`+"`$0`"+`}>\n  \n</${tagName}>`;

        return {
          suggestions: [
            {
              label: `Close with className <${tagName}>`,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: insertTextClassname,
              range: new monaco.Range(
                position.lineNumber,
                tagEndIndex + 1,
                position.lineNumber,
                tagEndIndex + 2
              ),
              insertTextRules:
                monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
            },
            {
              label: `Close <${tagName}>`,
              kind: monaco.languages.CompletionItemKind.Snippet,
              insertText: `$0</${tagName}>`,
              range: new monaco.Range(
                position.lineNumber,
                position.column,
                position.lineNumber,
                position.column
              ),
              insertTextRules:
                monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
            },
          ],
        };
      }
      return { suggestions: [] };
    },
  })
}
</file>

<file path="src/sandbox/_functions/codeEditor/babel/compiler.ts">
//@ts-expect-error
import * as Babel from "@babel/standalone";
import React from "react";

export function compileTSX(code: string) {
  try {
    const compiled = Babel.transform(code, {
      presets: [
        ["env", { modules: "commonjs" }],
        "react",
        "typescript",
      ],
      filename: 'file.tsx', // helpful for error reporting
    }).code;
    // console.log('Compiled code:', compiled);
    return compiled;
  } catch (error) {
    console.error('Babel compilation error:', error);
    return '';
  }
}

// export function loadModule(jsCode: string) {
//   const module = { exports: {} };
//   // const fn = new Function("module", "exports", "React", jsCode);
//   const fn = new Function("React", `return ${jsCode}`);
//   return fn(React);
//   // fn(module, module.exports, React);

//   // if ('default' in module.exports) {
//   //   return module.exports.default
//   // } else {
//   //   return module.exports;
//   // }
// }
export function loadModule(code: string) {
  if (!code) return () => React.createElement("div", { style: { color: "red" } }, "Compilation Failed");

  try {
    const module = { exports: {} };
    const fn = new Function("module", "exports", "require", code);
    fn(module, module.exports, (name: string) => {
      if (name === "react") return React;
      throw new Error("Unsupported require: " + name);
    });

    if ('default' in module.exports) {
      return module.exports.default
    } else {
      return module.exports;
    }
  } catch (e) {
    console.error("Module loading error:", e);
    return () => React.createElement("div", { style: { color: "red" } }, "Runtime Error: " + (e as Error).message);
  }
}
</file>

<file path="src/sandbox/_functions/codeEditor/hoverTooltip.ts">
import * as monacoEditor from "monaco-editor";

export default function HoverTooltip(editor: monacoEditor.editor.IStandaloneCodeEditor) {
  editor?.updateOptions({
    hover: {
      above: false //? yes just having this value set to false makes it apprear below or above the line whereever there is more space
    },
  })
}
</file>

<file path="src/sandbox/_functions/codeEditor/tailwindcss/autoSuggestion.ts">
import * as monaco from "monaco-editor";
import { isInsideClassName } from "./classDetector";
import { tailwindcssClasses } from "./classes";

export default function InitAutoSuggestion(
  monacoInstance: typeof monaco,
  extractColorValue: (className: string) => string | null = () => null
) {
  return monacoInstance.languages.registerCompletionItemProvider("typescript", {
    triggerCharacters: ['"', "'", "`", " ", "-"],
    provideCompletionItems: (model, position) => {
      const line = model.getLineContent(position.lineNumber);
      const text = line.substring(0, position.column - 1);

      if (!isInsideClassName(text)) {
        return { suggestions: [] };
      }
      const range = getClassFragmentRange(model, position);

      const suggestions = tailwindcssClasses.map(cls => {
        const color = extractColorValue(cls);

        const shade = cls.split("-").pop()!;
        const sortText = shade.padStart(3, "0"); // 50 -> "050", 400 -> "400"

        return {
          label: cls,
          kind: color
            ? monacoInstance.languages.CompletionItemKind.Color
            : monacoInstance.languages.CompletionItemKind.Keyword,
          insertText: cls,
          documentation: color
            ? {
                value: `Color preview: ${color}`,
              }
            : undefined,
          //? The range of text to replace
          range: range,
          sortText
        };
      });

      return { suggestions };
    },
  });
}

function getClassFragmentRange(model: monaco.editor.ITextModel, position: monaco.Position) {
  const line = model.getLineContent(position.lineNumber);
  const before = line.substring(0, position.column - 1);
  const match = before.match(/[\w:-]+$/);

  const startColumn = match
    ? before.length - match[0].length + 1
    : position.column;

  return new monaco.Range(
    position.lineNumber,
    startColumn,
    position.lineNumber,
    position.column
  );
}
</file>

<file path="src/sandbox/_functions/codeEditor/tailwindcss/classDetector.ts">
export function isInsideClassName(text: string) {
  // 1. Find className=
  const attrMatch = text.match(/className\s*=\s*/);
  if (!attrMatch || attrMatch.index === undefined) return false;

  const afterAttr = text.slice(attrMatch.index + attrMatch[0].length);

  // 2. Check first character after =
  const first = afterAttr.trimStart()[0];

  // Case A: quote directly => className="..."
  if (first === `"` || first === `'` || first === "`") {
    return isInsideUnclosedString(afterAttr);
  }

  // Case B: expression => className={ ... }
  if (first === "{") {
    // We look *inside* the expression for an unclosed string
    const inside = afterAttr.slice(afterAttr.indexOf("{") + 1);
    return isInsideUnclosedString(inside);
  }

  return false;
}

function isInsideUnclosedString(text: string) {
  // Find first quote of any type
  const m = text.match(/["'`]/);
  if (!m) return false;

  const quote = m[0];
  const start = text.indexOf(quote);

  // After the opening quote
  const rest = text.slice(start + 1);

  // If we haven't seen the same quote again -> open string
  return !rest.includes(quote);
}
</file>

<file path="src/sandbox/_functions/codeEditor/tailwindcss/color.js">
import { oklch, formatHex, parse } from "culori";

export const tailwindcssColors = {
  "red-50": formatHex(parse("oklch(97.1% 0.013 17.38")),
  "red-100": formatHex(parse("oklch(93.6% 0.032 17.717")),
  "red-200": formatHex(parse("oklch(88.5% 0.062 18.334")),
  "red-300": formatHex(parse("oklch(80.8% 0.114 19.571")),
  "red-400": formatHex(parse("oklch(70.4% 0.191 22.216")),
  "red-500": formatHex(parse("oklch(63.7% 0.237 25.331")),
  "red-600": formatHex(parse("oklch(57.7% 0.245 27.325")),
  "red-700": formatHex(parse("oklch(50.5% 0.213 27.518")),
  "red-800": formatHex(parse("oklch(44.4% 0.177 26.899")),
  "red-900": formatHex(parse("oklch(39.6% 0.141 25.723")),
  "red-950": formatHex(parse("oklch(25.8% 0.092 26.042")),

  "orange-50": formatHex(parse("oklch(98% 0.016 73.684")),
  "orange-100": formatHex(parse("oklch(95.4% 0.038 75.164")),
  "orange-200": formatHex(parse("oklch(90.1% 0.076 70.697")),
  "orange-300": formatHex(parse("oklch(83.7% 0.128 66.29")),
  "orange-400": formatHex(parse("oklch(75% 0.183 55.934")),
  "orange-500": formatHex(parse("oklch(70.5% 0.213 47.604")),
  "orange-600": formatHex(parse("oklch(64.6% 0.222 41.116")),
  "orange-700": formatHex(parse("oklch(55.3% 0.195 38.402")),
  "orange-800": formatHex(parse("oklch(47% 0.157 37.304")),
  "orange-900": formatHex(parse("oklch(40.8% 0.123 38.172")),
  "orange-950": formatHex(parse("oklch(26.6% 0.079 36.259")),

  "amber-50": formatHex(parse("oklch(98.7% 0.022 95.277")),
  "amber-100": formatHex(parse("oklch(96.2% 0.059 95.617")),
  "amber-200": formatHex(parse("oklch(92.4% 0.12 95.746")),
  "amber-300": formatHex(parse("oklch(87.9% 0.169 91.605")),
  "amber-400": formatHex(parse("oklch(82.8% 0.189 84.429")),
  "amber-500": formatHex(parse("oklch(76.9% 0.188 70.08")),
  "amber-600": formatHex(parse("oklch(66.6% 0.179 58.318")),
  "amber-700": formatHex(parse("oklch(55.5% 0.163 48.998")),
  "amber-800": formatHex(parse("oklch(47.3% 0.137 46.201")),
  "amber-900": formatHex(parse("oklch(41.4% 0.112 45.904")),
  "amber-950": formatHex(parse("oklch(27.9% 0.077 45.635")),

  "yellow-50": formatHex(parse("oklch(98.7% 0.026 102.212")),
  "yellow-100": formatHex(parse("oklch(97.3% 0.071 103.193")),
  "yellow-200": formatHex(parse("oklch(94.5% 0.129 101.54")),
  "yellow-300": formatHex(parse("oklch(90.5% 0.182 98.111")),
  "yellow-400": formatHex(parse("oklch(85.2% 0.199 91.936")),
  "yellow-500": formatHex(parse("oklch(79.5% 0.184 86.047")),
  "yellow-600": formatHex(parse("oklch(68.1% 0.162 75.834")),
  "yellow-700": formatHex(parse("oklch(55.4% 0.135 66.442")),
  "yellow-800": formatHex(parse("oklch(47.6% 0.114 61.907")),
  "yellow-900": formatHex(parse("oklch(42.1% 0.095 57.708")),
  "yellow-950": formatHex(parse("oklch(28.6% 0.066 53.813")),

  "lime-50": formatHex(parse("oklch(98.6% 0.031 120.757")),
  "lime-100": formatHex(parse("oklch(96.7% 0.067 122.328")),
  "lime-200": formatHex(parse("oklch(93.8% 0.127 124.321")),
  "lime-300": formatHex(parse("oklch(89.7% 0.196 126.665")),
  "lime-400": formatHex(parse("oklch(84.1% 0.238 128.85")),
  "lime-500": formatHex(parse("oklch(76.8% 0.233 130.85")),
  "lime-600": formatHex(parse("oklch(64.8% 0.2 131.684")),
  "lime-700": formatHex(parse("oklch(53.2% 0.157 131.589")),
  "lime-800": formatHex(parse("oklch(45.3% 0.124 130.933")),
  "lime-900": formatHex(parse("oklch(40.5% 0.101 131.063")),
  "lime-950": formatHex(parse("oklch(27.4% 0.072 132.109")),

  "green-50": formatHex(parse("oklch(98.2% 0.018 155.826")),
  "green-100": formatHex(parse("oklch(96.2% 0.044 156.743")),
  "green-200": formatHex(parse("oklch(92.5% 0.084 155.995")),
  "green-300": formatHex(parse("oklch(87.1% 0.15 154.449")),
  "green-400": formatHex(parse("oklch(79.2% 0.209 151.711")),
  "green-500": formatHex(parse("oklch(72.3% 0.219 149.579")),
  "green-600": formatHex(parse("oklch(62.7% 0.194 149.214")),
  "green-700": formatHex(parse("oklch(52.7% 0.154 150.069")),
  "green-800": formatHex(parse("oklch(44.8% 0.119 151.328")),
  "green-900": formatHex(parse("oklch(39.3% 0.095 152.535")),
  "green-950": formatHex(parse("oklch(26.6% 0.065 152.934")),

  "emerald-50": formatHex(parse("oklch(97.9% 0.021 166.113")),
  "emerald-100": formatHex(parse("oklch(95% 0.052 163.051")),
  "emerald-200": formatHex(parse("oklch(90.5% 0.093 164.15")),
  "emerald-300": formatHex(parse("oklch(84.5% 0.143 164.978")),
  "emerald-400": formatHex(parse("oklch(76.5% 0.177 163.223")),
  "emerald-500": formatHex(parse("oklch(69.6% 0.17 162.48")),
  "emerald-600": formatHex(parse("oklch(59.6% 0.145 163.225")),
  "emerald-700": formatHex(parse("oklch(50.8% 0.118 165.612")),
  "emerald-800": formatHex(parse("oklch(43.2% 0.095 166.913")),
  "emerald-900": formatHex(parse("oklch(37.8% 0.077 168.94")),
  "emerald-950": formatHex(parse("oklch(26.2% 0.051 172.552")),

  "teal-50": formatHex(parse("oklch(98.4% 0.014 180.72")),
  "teal-100": formatHex(parse("oklch(95.3% 0.051 180.801")),
  "teal-200": formatHex(parse("oklch(91% 0.096 180.426")),
  "teal-300": formatHex(parse("oklch(85.5% 0.138 181.071")),
  "teal-400": formatHex(parse("oklch(77.7% 0.152 181.912")),
  "teal-500": formatHex(parse("oklch(70.4% 0.14 182.503")),
  "teal-600": formatHex(parse("oklch(60% 0.118 184.704")),
  "teal-700": formatHex(parse("oklch(51.1% 0.096 186.391")),
  "teal-800": formatHex(parse("oklch(43.7% 0.078 188.216")),
  "teal-900": formatHex(parse("oklch(38.6% 0.063 188.416")),
  "teal-950": formatHex(parse("oklch(27.7% 0.046 192.524")),

  "cyan-50": formatHex(parse("oklch(98.4% 0.019 200.873")),
  "cyan-100": formatHex(parse("oklch(95.6% 0.045 203.388")),
  "cyan-200": formatHex(parse("oklch(91.7% 0.08 205.041")),
  "cyan-300": formatHex(parse("oklch(86.5% 0.127 207.078")),
  "cyan-400": formatHex(parse("oklch(78.9% 0.154 211.53")),
  "cyan-500": formatHex(parse("oklch(71.5% 0.143 215.221")),
  "cyan-600": formatHex(parse("oklch(60.9% 0.126 221.723")),
  "cyan-700": formatHex(parse("oklch(52% 0.105 223.128")),
  "cyan-800": formatHex(parse("oklch(45% 0.085 224.283")),
  "cyan-900": formatHex(parse("oklch(39.8% 0.07 227.392")),
  "cyan-950": formatHex(parse("oklch(30.2% 0.056 229.695")),

  "sky-50": formatHex(parse("oklch(97.7% 0.013 236.62")),
  "sky-100": formatHex(parse("oklch(95.1% 0.026 236.824")),
  "sky-200": formatHex(parse("oklch(90.1% 0.058 230.902")),
  "sky-300": formatHex(parse("oklch(82.8% 0.111 230.318")),
  "sky-400": formatHex(parse("oklch(74.6% 0.16 232.661")),
  "sky-500": formatHex(parse("oklch(68.5% 0.169 237.323")),
  "sky-600": formatHex(parse("oklch(58.8% 0.158 241.966")),
  "sky-700": formatHex(parse("oklch(50% 0.134 242.749")),
  "sky-800": formatHex(parse("oklch(44.3% 0.11 240.79")),
  "sky-900": formatHex(parse("oklch(39.1% 0.09 240.876")),
  "sky-950": formatHex(parse("oklch(29.3% 0.066 243.157")),

  "blue-50": formatHex(parse("oklch(97% 0.014 254.604")),
  "blue-100": formatHex(parse("oklch(93.2% 0.032 255.585")),
  "blue-200": formatHex(parse("oklch(88.2% 0.059 254.128")),
  "blue-300": formatHex(parse("oklch(80.9% 0.105 251.813")),
  "blue-400": formatHex(parse("oklch(70.7% 0.165 254.624")),
  "blue-500": formatHex(parse("oklch(62.3% 0.214 259.815")),
  "blue-600": formatHex(parse("oklch(54.6% 0.245 262.881")),
  "blue-700": formatHex(parse("oklch(48.8% 0.243 264.376")),
  "blue-800": formatHex(parse("oklch(42.4% 0.199 265.638")),
  "blue-900": formatHex(parse("oklch(37.9% 0.146 265.522")),
  "blue-950": formatHex(parse("oklch(28.2% 0.091 267.935")),

  "indigo-50": formatHex(parse("oklch(96.2% 0.018 272.314")),
  "indigo-100": formatHex(parse("oklch(93% 0.034 272.788")),
  "indigo-200": formatHex(parse("oklch(87% 0.065 274.039")),
  "indigo-300": formatHex(parse("oklch(78.5% 0.115 274.713")),
  "indigo-400": formatHex(parse("oklch(67.3% 0.182 276.935")),
  "indigo-500": formatHex(parse("oklch(58.5% 0.233 277.117")),
  "indigo-600": formatHex(parse("oklch(51.1% 0.262 276.966")),
  "indigo-700": formatHex(parse("oklch(45.7% 0.24 277.023")),
  "indigo-800": formatHex(parse("oklch(39.8% 0.195 277.366")),
  "indigo-900": formatHex(parse("oklch(35.9% 0.144 278.697")),
  "indigo-950": formatHex(parse("oklch(25.7% 0.09 281.288")),

  "violet-50": formatHex(parse("oklch(96.9% 0.016 293.756")),
  "violet-100": formatHex(parse("oklch(94.3% 0.029 294.588")),
  "violet-200": formatHex(parse("oklch(89.4% 0.057 293.283")),
  "violet-300": formatHex(parse("oklch(81.1% 0.111 293.571")),
  "violet-400": formatHex(parse("oklch(70.2% 0.183 293.541")),
  "violet-500": formatHex(parse("oklch(60.6% 0.25 292.717")),
  "violet-600": formatHex(parse("oklch(54.1% 0.281 293.009")),
  "violet-700": formatHex(parse("oklch(49.1% 0.27 292.581")),
  "violet-800": formatHex(parse("oklch(43.2% 0.232 292.759")),
  "violet-900": formatHex(parse("oklch(38% 0.189 293.745")),
  "violet-950": formatHex(parse("oklch(28.3% 0.141 291.089")),

  "purple-50": formatHex(parse("oklch(97.7% 0.014 308.299")),
  "purple-100": formatHex(parse("oklch(94.6% 0.033 307.174")),
  "purple-200": formatHex(parse("oklch(90.2% 0.063 306.703")),
  "purple-300": formatHex(parse("oklch(82.7% 0.119 306.383")),
  "purple-400": formatHex(parse("oklch(71.4% 0.203 305.504")),
  "purple-500": formatHex(parse("oklch(62.7% 0.265 303.9")),
  "purple-600": formatHex(parse("oklch(55.8% 0.288 302.321")),
  "purple-700": formatHex(parse("oklch(49.6% 0.265 301.924")),
  "purple-800": formatHex(parse("oklch(43.8% 0.218 303.724")),
  "purple-900": formatHex(parse("oklch(38.1% 0.176 304.987")),
  "purple-950": formatHex(parse("oklch(29.1% 0.149 302.717")),

  "fuchsia-50": formatHex(parse("oklch(97.7% 0.017 320.058")),
  "fuchsia-100": formatHex(parse("oklch(95.2% 0.037 318.852")),
  "fuchsia-200": formatHex(parse("oklch(90.3% 0.076 319.62")),
  "fuchsia-300": formatHex(parse("oklch(83.3% 0.145 321.434")),
  "fuchsia-400": formatHex(parse("oklch(74% 0.238 322.16")),
  "fuchsia-500": formatHex(parse("oklch(66.7% 0.295 322.15")),
  "fuchsia-600": formatHex(parse("oklch(59.1% 0.293 322.896")),
  "fuchsia-700": formatHex(parse("oklch(51.8% 0.253 323.949")),
  "fuchsia-800": formatHex(parse("oklch(45.2% 0.211 324.591")),
  "fuchsia-900": formatHex(parse("oklch(40.1% 0.17 325.612")),
  "fuchsia-950": formatHex(parse("oklch(29.3% 0.136 325.661")),

  "pink-50": formatHex(parse("oklch(97.1% 0.014 343.198")),
  "pink-100": formatHex(parse("oklch(94.8% 0.028 342.258")),
  "pink-200": formatHex(parse("oklch(89.9% 0.061 343.231")),
  "pink-300": formatHex(parse("oklch(82.3% 0.12 346.018")),
  "pink-400": formatHex(parse("oklch(71.8% 0.202 349.761")),
  "pink-500": formatHex(parse("oklch(65.6% 0.241 354.308")),
  "pink-600": formatHex(parse("oklch(59.2% 0.249 0.584")),
  "pink-700": formatHex(parse("oklch(52.5% 0.223 3.958")),
  "pink-800": formatHex(parse("oklch(45.9% 0.187 3.815")),
  "pink-900": formatHex(parse("oklch(40.8% 0.153 2.432")),
  "pink-950": formatHex(parse("oklch(28.4% 0.109 3.907")),

  "rose-50": formatHex(parse("oklch(96.9% 0.015 12.422")),
  "rose-100": formatHex(parse("oklch(94.1% 0.03 12.58")),
  "rose-200": formatHex(parse("oklch(89.2% 0.058 10.001")),
  "rose-300": formatHex(parse("oklch(81% 0.117 11.638")),
  "rose-400": formatHex(parse("oklch(71.2% 0.194 13.428")),
  "rose-500": formatHex(parse("oklch(64.5% 0.246 16.439")),
  "rose-600": formatHex(parse("oklch(58.6% 0.253 17.585")),
  "rose-700": formatHex(parse("oklch(51.4% 0.222 16.935")),
  "rose-800": formatHex(parse("oklch(45.5% 0.188 13.697")),
  "rose-900": formatHex(parse("oklch(41% 0.159 10.272")),
  "rose-950": formatHex(parse("oklch(27.1% 0.105 12.094")),

  "slate-50": formatHex(parse("oklch(98.4% 0.003 247.858")),
  "slate-100": formatHex(parse("oklch(96.8% 0.007 247.896")),
  "slate-200": formatHex(parse("oklch(92.9% 0.013 255.508")),
  "slate-300": formatHex(parse("oklch(86.9% 0.022 252.894")),
  "slate-400": formatHex(parse("oklch(70.4% 0.04 256.788")),
  "slate-500": formatHex(parse("oklch(55.4% 0.046 257.417")),
  "slate-600": formatHex(parse("oklch(44.6% 0.043 257.281")),
  "slate-700": formatHex(parse("oklch(37.2% 0.044 257.287")),
  "slate-800": formatHex(parse("oklch(27.9% 0.041 260.031")),
  "slate-900": formatHex(parse("oklch(20.8% 0.042 265.755")),
  "slate-950": formatHex(parse("oklch(12.9% 0.042 264.695")),

  "gray-50": formatHex(parse("oklch(98.5% 0.002 247.839")),
  "gray-100": formatHex(parse("oklch(96.7% 0.003 264.542")),
  "gray-200": formatHex(parse("oklch(92.8% 0.006 264.531")),
  "gray-300": formatHex(parse("oklch(87.2% 0.01 258.338")),
  "gray-400": formatHex(parse("oklch(70.7% 0.022 261.325")),
  "gray-500": formatHex(parse("oklch(55.1% 0.027 264.364")),
  "gray-600": formatHex(parse("oklch(44.6% 0.03 256.802")),
  "gray-700": formatHex(parse("oklch(37.3% 0.034 259.733")),
  "gray-800": formatHex(parse("oklch(27.8% 0.033 256.848")),
  "gray-900": formatHex(parse("oklch(21% 0.034 264.665")),
  "gray-950": formatHex(parse("oklch(13% 0.028 261.692")),

  "zinc-50": formatHex(parse("oklch(98.5% 0 0")),
  "zinc-100": formatHex(parse("oklch(96.7% 0.001 286.375")),
  "zinc-200": formatHex(parse("oklch(92% 0.004 286.32")),
  "zinc-300": formatHex(parse("oklch(87.1% 0.006 286.286")),
  "zinc-400": formatHex(parse("oklch(70.5% 0.015 286.067")),
  "zinc-500": formatHex(parse("oklch(55.2% 0.016 285.938")),
  "zinc-600": formatHex(parse("oklch(44.2% 0.017 285.786")),
  "zinc-700": formatHex(parse("oklch(37% 0.013 285.805")),
  "zinc-800": formatHex(parse("oklch(27.4% 0.006 286.033")),
  "zinc-900": formatHex(parse("oklch(21% 0.006 285.885")),
  "zinc-950": formatHex(parse("oklch(14.1% 0.005 285.823")),

  "neutral-50": formatHex(parse("oklch(98.5% 0 0")),
  "neutral-100": formatHex(parse("oklch(97% 0 0")),
  "neutral-200": formatHex(parse("oklch(92.2% 0 0")),
  "neutral-300": formatHex(parse("oklch(87% 0 0")),
  "neutral-400": formatHex(parse("oklch(70.8% 0 0")),
  "neutral-500": formatHex(parse("oklch(55.6% 0 0")),
  "neutral-600": formatHex(parse("oklch(43.9% 0 0")),
  "neutral-700": formatHex(parse("oklch(37.1% 0 0")),
  "neutral-800": formatHex(parse("oklch(26.9% 0 0")),
  "neutral-900": formatHex(parse("oklch(20.5% 0 0")),
  "neutral-950": formatHex(parse("oklch(14.5% 0 0")),

  "stone-50": formatHex(parse("oklch(98.5% 0.001 106.423")),
  "stone-100": formatHex(parse("oklch(97% 0.001 106.424")),
  "stone-200": formatHex(parse("oklch(92.3% 0.003 48.717")),
  "stone-300": formatHex(parse("oklch(86.9% 0.005 56.366")),
  "stone-400": formatHex(parse("oklch(70.9% 0.01 56.259")),
  "stone-500": formatHex(parse("oklch(55.3% 0.013 58.071")),
  "stone-600": formatHex(parse("oklch(44.4% 0.011 73.639")),
  "stone-700": formatHex(parse("oklch(37.4% 0.01 67.558")),
  "stone-800": formatHex(parse("oklch(26.8% 0.007 34.298")),
  "stone-900": formatHex(parse("oklch(21.6% 0.006 56.043")),
  "stone-950": formatHex(parse("oklch(14.7% 0.004 49.25")),
}
</file>

<file path="src/sandbox/_functions/codeEditor/tailwindcss/tailwindcss.ts">
import InitAutoSuggestion from "./autoSuggestion";
import * as monaco from "monaco-editor";
import { tailwindcssColors } from "./color";
import InitInlineColorIcon from "./inlineColorIcon";

export default function InitTailwindcss(monacoInstance: typeof import("monaco-editor"), editorInstance: monaco.editor.IStandaloneCodeEditor) {

  const autoSuggestionsHandler = InitAutoSuggestion(monacoInstance, extractColorValue);
  const inlineColorIcons = InitInlineColorIcon(editorInstance, extractColorValue);
  
  return () => {
    autoSuggestionsHandler.dispose();
    inlineColorIcons.dispose();
  }
} 

function extractColorValue(className: string): string | null {
  const match = className.match(/(?:text|decoration|bg|divide|outline|ring|shadow|accent|caret|fill|stroke|border|border-t|border-b|border-l|border-r|border-x|border-y)-([a-z]+-\d{1,3})/);
  if (!match) return null;
  const base = match[1];
  return tailwindcssColors[base as keyof typeof tailwindcssColors] || null;
}
</file>

<file path="src/sandbox/_functions/codeEditor/themes/textmate/theme-converter.ts">
import type { editor } from 'monaco-editor';

interface IVScodeTheme {
  $schema: string;
  name?: string | undefined;
  include?: string | undefined;
  type: ThemeType | string;
  tokenColors: TokenColor[];
  colors?:
    | {
        [name: string]: string;
      }
    | undefined;
}

interface TokenColor {
  name?: string;
  scope: string[] | string;
  settings: {
    foreground?: string;
    background?: string;
    fontStyle?: string;
  };
}

type ThemeType = 'light' | 'dark' | 'hcLight' | 'hcDark';

function convertTheme(theme: IVScodeTheme): editor.IStandaloneThemeData {
  const rules = [];
  for (const rule of theme.tokenColors) {
    if (typeof rule.scope === 'string') {
      rules.push({
        token: rule.scope,
        foreground: rule.settings.foreground,
      });
    } else {
      for (const scope of rule.scope) {
        rules.push({
          token: scope,
          foreground: rule.settings.foreground,
        });
      }
    }
  }

  return {
    base:
      theme.type === 'light'
        ? 'vs'
        : theme.type === 'hcLight'
        ? 'hc-light'
        : theme.type === 'hcDark'
        ? 'hc-black'
        : 'vs-dark',
    inherit: false,
    rules,
    colors: theme.colors || {},
  };
}

export { convertTheme };
export type { IVScodeTheme, TokenColor };
</file>

<file path="src/sandbox/_functions/codeEditor/themes/textmate/tm-to-monaco-token.ts">
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// This file has been modified by adding the convenience function TMToMonacoToken.
// See the original file at https://github.com/microsoft/vscode/blob/main/src/vs/workbench/services/textMate/common/TMHelper.ts

export interface IColorTheme {
  readonly tokenColors: ITokenColorizationRule[];
}

export interface ITokenColorizationRule {
  name?: string;
  scope?: string | string[];
  settings: ITokenColorizationSetting;
}

export interface ITokenColorizationSetting {
  foreground?: string;
  background?: string;
  fontStyle?: string; // italic, underline, strikethrough, bold
}

export function findMatchingThemeRule(
  theme: IColorTheme,
  scopes: string[],
  onlyColorRules: boolean = true
): ThemeRule | null {
  for (let i = scopes.length - 1; i >= 0; i--) {
    const parentScopes = scopes.slice(0, i);
    const scope = scopes[i];
    const r = findMatchingThemeRule2(
      theme,
      scope,
      parentScopes,
      onlyColorRules
    );
    if (r) {
      return r;
    }
  }
  return null;
}

function findMatchingThemeRule2(
  theme: IColorTheme,
  scope: string,
  parentScopes: string[],
  onlyColorRules: boolean
): ThemeRule | null {
  let result: ThemeRule | null = null;

  // Loop backwards, to ensure the last most specific rule wins
  for (let i = theme.tokenColors.length - 1; i >= 0; i--) {
    const rule = theme.tokenColors[i];
    if (onlyColorRules && !rule.settings.foreground) {
      continue;
    }

    let selectors: string[];
    if (typeof rule.scope === 'string') {
      selectors = rule.scope.split(/,/).map((scope) => scope.trim());
    } else if (Array.isArray(rule.scope)) {
      selectors = rule.scope;
    } else {
      continue;
    }

    for (let j = 0, lenJ = selectors.length; j < lenJ; j++) {
      const rawSelector = selectors[j];

      const themeRule = new ThemeRule(rawSelector, rule.settings);
      if (themeRule.matches(scope, parentScopes)) {
        if (themeRule.isMoreSpecific(result)) {
          result = themeRule;
        }
      }
    }
  }

  return result;
}

export class ThemeRule {
  readonly rawSelector: string;
  readonly settings: ITokenColorizationSetting;
  readonly scope: string;
  readonly parentScopes: string[];

  constructor(rawSelector: string, settings: ITokenColorizationSetting) {
    this.rawSelector = rawSelector;
    this.settings = settings;
    const rawSelectorPieces = this.rawSelector.split(/ /);
    this.scope = rawSelectorPieces[rawSelectorPieces.length - 1];
    this.parentScopes = rawSelectorPieces.slice(
      0,
      rawSelectorPieces.length - 1
    );
  }

  public matches(scope: string, parentScopes: string[]): boolean {
    return ThemeRule._matches(
      this.scope,
      this.parentScopes,
      scope,
      parentScopes
    );
  }

  private static _cmp(a: ThemeRule | null, b: ThemeRule | null): number {
    if (a === null && b === null) {
      return 0;
    }
    if (a === null) {
      // b > a
      return -1;
    }
    if (b === null) {
      // a > b
      return 1;
    }
    if (a.scope.length !== b.scope.length) {
      // longer scope length > shorter scope length
      return a.scope.length - b.scope.length;
    }
    const aParentScopesLen = a.parentScopes.length;
    const bParentScopesLen = b.parentScopes.length;
    if (aParentScopesLen !== bParentScopesLen) {
      // more parents > less parents
      return aParentScopesLen - bParentScopesLen;
    }
    for (let i = 0; i < aParentScopesLen; i++) {
      const aLen = a.parentScopes[i].length;
      const bLen = b.parentScopes[i].length;
      if (aLen !== bLen) {
        return aLen - bLen;
      }
    }
    return 0;
  }

  public isMoreSpecific(other: ThemeRule | null): boolean {
    return ThemeRule._cmp(this, other) > 0;
  }

  private static _matchesOne(selectorScope: string, scope: string): boolean {
    const selectorPrefix = selectorScope + '.';
    if (
      selectorScope === scope ||
      scope.substring(0, selectorPrefix.length) === selectorPrefix
    ) {
      return true;
    }
    return false;
  }

  private static _matches(
    selectorScope: string,
    selectorParentScopes: string[],
    scope: string,
    parentScopes: string[]
  ): boolean {
    if (!this._matchesOne(selectorScope, scope)) {
      return false;
    }

    let selectorParentIndex = selectorParentScopes.length - 1;
    let parentIndex = parentScopes.length - 1;
    while (selectorParentIndex >= 0 && parentIndex >= 0) {
      if (
        this._matchesOne(
          selectorParentScopes[selectorParentIndex],
          parentScopes[parentIndex]
        )
      ) {
        selectorParentIndex--;
      }
      parentIndex--;
    }

    if (selectorParentIndex === -1) {
      return true;
    }
    return false;
  }
}

// export const TMToMonacoToken = (theme: IColorTheme, scopes: string[]) => {
//   const themeRule = findMatchingThemeRule(theme, scopes, true);
//   return themeRule ? themeRule.scope : '';
// };
export const TMToMonacoToken = (theme: IColorTheme, scopes: string[]): string => {
  const themeRule = findMatchingThemeRule(theme, scopes, true);
  if (!themeRule) {
    // fallback: use the editor foreground color or white
    const fallback = (theme as any).colors?.["editor.foreground"] || "#FFFFFF";
    return fallback;
  }

  // return the color, not the scope
  return themeRule.settings.foreground || "#FFFFFF";
};
</file>

<file path="src/sandbox/_functions/codeEditor/themes/themes.ts">
import * as monaco from 'monaco-editor';

export default function generateThemes(monaco: typeof import("monaco-editor")) {
  traeDarkTheme(monaco);
}

const scopeMap: Record<string, string> = {

  "variable": "identifier",

  // Types
  "entity.name.type": "type",

  // Keywords
  "constant.numeric": "number",

  // Comments
  "comment": "comment",
};

const colorParser = (tokens: any[]) => {
  const tokenColors: monaco.editor.ITokenThemeRule[] = [];

  for (const token of tokens) {
    if (!token.scope) continue; // skip tokens without a scope
    const scopes = Array.isArray(token.scope) ? token.scope : [token.scope];
    for (const scope of scopes) {
      tokenColors.push({
        // token: scope,
        token: scopeMap[scope] || scope,
        foreground: token.settings.foreground?.replace("#", ""),
        fontStyle: token.settings.fontStyle,
      });
    }
  }

  return tokenColors;
};


import traeDarkColor from "./trae_dark_color.json"
import traeDarkPlus from "./trae_dark_plus.json"
import traeDarkVs from "./trae_dark_vs.json"

export const traeDarkTheme = (monaco: typeof import("monaco-editor")) => {
  // Combine tokenColors from both VSCode files
  const tokenColors = [
    ...colorParser(traeDarkVs.tokenColors || []),
    ...colorParser(traeDarkPlus.tokenColors || []),
  ];

  // Merge editor colors
  const colors = {
    ...(traeDarkColor.colors || {}),
    ...(traeDarkVs.colors || {}),
  };

  // Define Monaco theme
  monaco.editor.defineTheme("trae-dark", {
    base: "vs-dark",
    inherit: true,
    rules: tokenColors,
    colors,
    encodedTokensColors: [],
  });
};
</file>

<file path="src/sandbox/_functions/codeEditor/themes/trae_dark_color.json">
{
  "$schema": "vscode://schemas/color-theme",
  "name": "Trae Dark",
  "colors": {
    "editor.background": "#171B26",
    "editor.foreground": "#DADDE5",
    "editorCursor.foreground": "#DADDE5",
    "editor.selectionBackground": "#c2caf229",
    "editor.lineHighlightBackground": "#C2CAF214",
    
    "activityBar.background": "#24262B",
    "activityBar.foreground": "#DADDE5",
    "activityBar.inactiveForeground": "#9599A6",
    "activityBarBadge.background": "#387BFF",
    "activityBarBadge.foreground": "#FFFFFF",
    
    "sideBar.background": "#24262B",
    "sideBar.foreground": "#DADDE5",
    "sideBarTitle.foreground": "#9599A6",
    "sideBarSectionHeader.background": "#33363D",
    "sideBarSectionHeader.foreground": "#DADDE5",
    
    "tab.activeBackground": "#171B26",
    "tab.activeForeground": "#DADDE5",
    "tab.inactiveBackground": "#24262B",
    "tab.inactiveForeground": "#9599A6",
    "editorGroupHeader.tabsBackground": "#24262B",
    
    "statusBar.background": "#24262B",
    "statusBar.foreground": "#DADDE5",
    "statusBar.debuggingBackground": "#387BFF",
    "statusBar.debuggingForeground": "#FFFFFF",
    "statusBar.noFolderBackground": "#24262B",
    
    "titleBar.activeBackground": "#24262B",
    "titleBar.activeForeground": "#DADDE5",
    "titleBar.inactiveBackground": "#24262B",
    "titleBar.inactiveForeground": "#9599A6",
    
    "input.background": "#33363D",
    "input.foreground": "#DADDE5",
    "input.placeholderForeground": "#9599A6",
    "inputOption.activeBorder": "#387BFF",
    
    "dropdown.background": "#33363D",
    "dropdown.foreground": "#DADDE5",
    "dropdown.border": "#C2CAF229",
    
    "list.activeSelectionBackground": "#C2CAF229",
    "list.activeSelectionForeground": "#DADDE5",
    "list.hoverBackground": "#C2CAF214",
    "list.hoverForeground": "#DADDE5",
    "list.inactiveSelectionBackground": "#C2CAF214",
    "list.inactiveSelectionForeground": "#DADDE5",
    
    "button.background": "#387BFF",
    "button.foreground": "#FFFFFF",
    "button.hoverBackground": "#78A5FF",
    
    "scrollbarSlider.background": "#DDE2E940",
    "scrollbarSlider.hoverBackground": "#DDE2E959",
    "scrollbarSlider.activeBackground": "#DDE2E980",
    
    "editorGroup.border": "#3A3D45",
    "panel.border": "#3A3D45",
    "sideBar.border": "#3A3D45",
    
    "focusBorder": "#C2CAF229",
    "foreground": "#DADDE5",
    "widget.shadow": "#00000029",
    "selection.background": "#C2CAF229"
  }
}
</file>

<file path="src/sandbox/_functions/codeEditor/themes/trae_dark_plus.json">
{"$schema":"vscode://schemas/color-theme","name":"Dark+","include":"./dark_vs.json","tokenColors":[{"name":"Function declarations","scope":["entity.name.function","support.function","support.constant.handlebars","source.powershell variable.other.member","entity.name.operator.custom-literal"],"settings":{"foreground":"#F29D79"}},{"name":"Types declaration and references","scope":["support.class","support.type","entity.name.type","entity.name.namespace","entity.other.attribute","entity.name.scope-resolution","entity.name.class","storage.type.numeric.go","storage.type.byte.go","storage.type.boolean.go","storage.type.string.go","storage.type.uintptr.go","storage.type.error.go","storage.type.rune.go","storage.type.cs","storage.type.generic.cs","storage.type.modifier.cs","storage.type.variable.cs","storage.type.annotation.java","storage.type.generic.java","storage.type.java","storage.type.object.array.java","storage.type.primitive.array.java","storage.type.primitive.java","storage.type.token.java","storage.type.groovy","storage.type.annotation.groovy","storage.type.parameters.groovy","storage.type.generic.groovy","storage.type.object.array.groovy","storage.type.primitive.array.groovy","storage.type.primitive.groovy"],"settings":{"foreground":"#81CFE0"}},{"name":"Types declaration and references, TS grammar specific","scope":["meta.type.cast.expr","meta.type.new.expr","support.constant.math","support.constant.dom","support.constant.json","entity.other.inherited-class","punctuation.separator.namespace.ruby"],"settings":{"foreground":"#B38CFF"}},{"name":"Control flow / Special keywords","scope":["keyword.control","source.cpp keyword.operator.new","keyword.operator.delete","keyword.other.using","keyword.other.directive.using","keyword.other.operator","entity.name.operator"],"settings":{"foreground":"#B38CFF"}},{"name":"Variable and parameter name","scope":["variable","meta.definition.variable.name","support.variable","entity.name.variable","constant.other.placeholder"],"settings":{"foreground":"#DED47E"}},{"name":"Constants and enums","scope":["variable.other.constant","variable.other.enummember"],"settings":{"foreground":"#80BBFF"}},{"name":"Object keys, TS grammar specific","scope":["meta.object-literal.key"],"settings":{"foreground":"#E0E3EE"}},{"name":"CSS property value","scope":["support.constant.property-value","support.constant.font-name","support.constant.media-type","support.constant.media","constant.other.color.rgb-value","constant.other.rgb-value","support.constant.color"],"settings":{"foreground":"#82D99F"}},{"name":"Regular expression groups","scope":["punctuation.definition.group.regexp","punctuation.definition.group.assertion.regexp","punctuation.definition.character-class.regexp","punctuation.character.set.begin.regexp","punctuation.character.set.end.regexp","keyword.operator.negation.regexp","support.other.parenthesis.regexp"],"settings":{"foreground":"#DED47E"}},{"scope":["constant.character.character-class.regexp","constant.other.character-class.set.regexp","constant.other.character-class.regexp","constant.character.set.regexp"],"settings":{"foreground":"#82D99F"}},{"scope":["keyword.operator.or.regexp","keyword.control.anchor.regexp"],"settings":{"foreground":"#E0E3EE"}},{"scope":"keyword.operator.quantifier.regexp","settings":{"foreground":"#E0E3EE"}},{"scope":["constant.character","constant.other.option"],"settings":{"foreground":"#80BBFF"}},{"scope":"constant.character.escape","settings":{"foreground":"#80BBFF"}},{"scope":"entity.name.label","settings":{"foreground":"#82D99F"}},{"scope":"variable.other.property","settings":{"foreground":"#E0E3EE"}}],"semanticTokenColors":{"newOperator":"#E0E3EE","stringLiteral":"#82D99F","customLiteral":"#E0E3EE","numberLiteral":"#F48CCA"}}
</file>

<file path="src/sandbox/_functions/drawing/clientToWorld.ts">
export const clientToWorld = (
  clientX: number,
  clientY: number,
  overlayEl: SVGSVGElement | null,
  offset: { x: number, y: number },
  zoom: number
) => {
  if (!overlayEl) return { x: 0, y: 0 }
  const rect = overlayEl.getBoundingClientRect()
  const screenX = clientX - rect.left
  const screenY = clientY - rect.top
  return {
    x: (screenX - offset.x) / zoom,
    y: (screenY - offset.y) / zoom,
  }
}
</file>

<file path="src/sandbox/_functions/drawing/clipUtils.ts">
import { StrokeData, DrawingPoint } from "src/sandbox/_providers/DrawingContextProvider";

type Rect = { x: number, y: number, width: number, height: number };

/**
 * Clips a single segment (p1 -> p2) against a rectangle.
 * Returns null if strictly outside, or [start, end] points of the visible segment.
 * Note: simplistic Sutherland-Hodgman or Cohen-Sutherland approach for a single segment.
 */
function clipSegment(p1: DrawingPoint, p2: DrawingPoint, rect: Rect): [DrawingPoint, DrawingPoint] | null {
  let x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
  const minX = Math.min(rect.x, rect.x + rect.width);
  const maxX = Math.max(rect.x, rect.x + rect.width);
  const minY = Math.min(rect.y, rect.y + rect.height);
  const maxY = Math.max(rect.y, rect.y + rect.height);

  const INSIDE = 0; // 0000
  const LEFT = 1;   // 0001
  const RIGHT = 2;  // 0010
  const BOTTOM = 4; // 0100
  const TOP = 8;    // 1000

  const computeOutCode = (x: number, y: number) => {
    let code = INSIDE;
    if (x < minX) code |= LEFT;
    else if (x > maxX) code |= RIGHT;
    if (y < minY) code |= TOP; // Note: Ensure Y coordinates match system (Top < Bottom?) Usually screen coords: Top is smaller Y.
    // Wait, in standard math Y goes up. In screen, Y goes down.
    // If Y goes down (0 at top), then "Top" of rect (visually) is minY. 
    // If y < minY, it is ABOVE the rect. In code names, this is often called TOP or BOTTOM depending on convention.
    // Let's stick to numerical checks.
    // y < minY -> "Above" (Top)
    else if (y > maxY) code |= BOTTOM; // "Below"
    return code;
  };

  let outcode1 = computeOutCode(x1, y1);
  let outcode2 = computeOutCode(x2, y2);
  let accept = false;

  while (true) {
    if (!(outcode1 | outcode2)) {
      // Bitwise OR is 0. Trivially accept and exit.
      accept = true;
      break;
    } else if (outcode1 & outcode2) {
      // Bitwise AND is not 0. Trivially reject and exit.
      break;
    } else {
      // Failed both tests, so calculate the line segment to clip
      // from an outside point to an intersection with clip edge
      let x = 0, y = 0;

      // At least one endpoint is outside the clip rectangle; pick it.
      const outcodeOut = outcode1 ? outcode1 : outcode2;

      // Find intersection point;
      // using formulas y = y1 + slope * (x - x1), x = x1 + (1 / slope) * (y - y1)
      if (outcodeOut & BOTTOM) {           // point is below the clip rect
        x = x1 + (x2 - x1) * (maxY - y1) / (y2 - y1);
        y = maxY;
      } else if (outcodeOut & TOP) { // point is above the clip rect
        x = x1 + (x2 - x1) * (minY - y1) / (y2 - y1);
        y = minY;
      } else if (outcodeOut & RIGHT) {  // point is to the right of clip rect
        y = y1 + (y2 - y1) * (maxX - x1) / (x2 - x1);
        x = maxX;
      } else if (outcodeOut & LEFT) {   // point is to the left of clip rect
        y = y1 + (y2 - y1) * (minX - x1) / (x2 - x1);
        x = minX;
      }

      // Now we move outside point to intersection point to clip
      // and ready for next pass.
      if (outcodeOut === outcode1) {
        x1 = x; y1 = y;
        outcode1 = computeOutCode(x1, y1);
      } else {
        x2 = x; y2 = y;
        outcode2 = computeOutCode(x2, y2);
      }
    }
  }

  if (accept) {
    // Interpolate attributes (size, color)
    // Simple linear interpolation based on distance ratio?
    // Or just inherit from p1/p2.
    // For 'perfect-freehand', color/size per point matters.
    // We'll just clone p1 props for start, p2 props for end for simplicity, 
    // or better: interpolate size.

    // Accurate approach:
    // If x1 != p1.x, x1 is an intersection.
    // We construct new points.

    const newP1 = { ...p1, x: x1, y: y1 };
    const newP2 = { ...p2, x: x2, y: y2 };

    // We should strictly interpolate size if possible, to avoid "popping" thickness.
    const distTotal = Math.hypot(p2.x - p1.x, p2.y - p1.y);
    const dist1 = Math.hypot(x1 - p1.x, y1 - p1.y);
    const dist2 = Math.hypot(x2 - p1.x, y2 - p1.y);

    if (distTotal > 0) {
      newP1.size = p1.size + (p2.size - p1.size) * (dist1 / distTotal);
      newP2.size = p1.size + (p2.size - p1.size) * (dist2 / distTotal);
    }

    return [newP1, newP2];
  }

  return null;
}

export function clipStrokesToRect(strokes: StrokeData[], rect: Rect): StrokeData[] {
  const finalStrokes: StrokeData[] = [];

  strokes.forEach(stroke => {
    // Optimization: Intersect bounding box first? 
    // We already have hit testing for that, but let's just do point by point.

    if (stroke.points.length < 2) {
      // Single point: check point in rect
      if (stroke.points.length === 1) {
        const p = stroke.points[0];
        if (p.x >= rect.x && p.x <= rect.x + rect.width &&
          p.y >= rect.y && p.y <= rect.y + rect.height) {
          finalStrokes.push(stroke);
        }
      }
      return;
    }

    let currentPoints: DrawingPoint[] = [];

    for (let i = 0; i < stroke.points.length - 1; i++) {
      const p1 = stroke.points[i];
      const p2 = stroke.points[i + 1];

      const clipped = clipSegment(p1, p2, rect);

      if (clipped) {
        const [c1, c2] = clipped;

        // If currentPoints is empty, start new strip
        if (currentPoints.length === 0) {
          currentPoints.push(c1);
        } else {
          // Check continuity. 
          // If last point of current strip is same as c1 (visual equality or microscopic tolerance)
          const last = currentPoints[currentPoints.length - 1];
          if (Math.abs(last.x - c1.x) < 0.001 && Math.abs(last.y - c1.y) < 0.001) {
            // connected
          } else {
            // Discontinuity (gap bridged by outside segment, but we shouldn't bridge it)
            // Wait, if we are here, clipSegment returned a segment efficiently.
            // If there was a gap, clipSegment would have returned different coordinates?
            // Actually, if we skip an "outside" segment, we enter this block with a NEW c1.
            // So we must flush currentPoints to a stroke and start new.

            // Case: p1-p2 IN. p2-p3 OUT. p3-p4 IN.
            // i=0: p1-p2 -> c1=p1, c2=p2. currentPoints: [p1, p2].
            // i=1: p2-p3 -> null (outside). Loop continues.
            // i=2: p3-p4 -> c1=p3, c2=p4. 
            // currentPoints has [p1, p2].
            // We check last (p2) vs c1 (p3). Dist > 0.
            // This is a GAP.
            // So we must save [p1, p2] as a stroke and start new [p3...].

            // Add stroke
            if (currentPoints.length > 0) {
              // Don't add if single point? (Unless dots)
              // Drawing needs at least 1 point (rendered as dot) or 2?
              finalStrokes.push({
                ...stroke,
                id: crypto.randomUUID(),
                points: [...currentPoints]
              });
            }
            currentPoints = [c1];
          }
        }

        // Add end point
        currentPoints.push(c2);

      } else {
        // Segment fully outside.
        // If we have accumulated points, we effectively "cut" here.
        if (currentPoints.length > 0) {
          finalStrokes.push({
            ...stroke,
            id: crypto.randomUUID(),
            points: [...currentPoints]
          });
          currentPoints = [];
        }
      }
    }

    // Flush remaining
    if (currentPoints.length > 0) {
      finalStrokes.push({
        ...stroke,
        id: crypto.randomUUID(), // New ID to avoid conflicts
        points: [...currentPoints]
      });
    }
  });

  return finalStrokes;
}
</file>

<file path="src/sandbox/_functions/drawing/exportUtils.ts">
import { StrokeData } from "src/sandbox/_providers/DrawingContextProvider";
import { getStroke } from 'perfect-freehand'
import { getSvgPathFromStroke } from './getSvgPathFromStroke'
import { getStrokesBoundingBox } from './selectionUtils'

// Shared options for getStroke to ensure consistent rendering
const getStrokeOptions = (pointSize: number) => ({
  size: Math.min(20, 12) * (pointSize / 10),
  thinning: 0,
  smoothing: 0.5,
  streamline: 0.5,
  easing: (t: number) => t,
  last: true,
});

// Shared bounds logic
const calculateViewBox = (strokes: StrokeData[], customBounds?: { x: number, y: number, width: number, height: number }) => {
  if (customBounds) {
    return {
      minX: customBounds.x,
      minY: customBounds.y,
      width: customBounds.width,
      height: customBounds.height
    };
  }

  const bounds = getStrokesBoundingBox(strokes);
  if (!bounds) return null;

  return {
    minX: bounds.minX,
    minY: bounds.minY,
    width: bounds.maxX - bounds.minX,
    height: bounds.maxY - bounds.minY
  };
}

export const downloadSvg = (strokes: StrokeData[], customBounds?: { x: number, y: number, width: number, height: number }) => {
  if (strokes.length === 0) return;

  const viewBox = calculateViewBox(strokes, customBounds);
  if (!viewBox) return;

  // 2. Generate SVG Content
  let svgContent = `<svg viewBox="${viewBox.minX} ${viewBox.minY} ${viewBox.width} ${viewBox.height}" xmlns="http://www.w3.org/2000/svg" style="background-color: transparent;">`;

  strokes.forEach(s => {
    if (s.points.length > 0) {
      // Freehand / Shape
      const stroke = getStroke(s.points, getStrokeOptions(s.points[0].size))
      const pathData = getSvgPathFromStroke(stroke)

      // Fill
      if (s.fill) {
        const fillPath = `M ${s.points.map(p => `${p.x},${p.y}`).join(' L ')} Z`;
        svgContent += `<path d="${fillPath}" fill="${s.fill}" stroke="none" />`;
      }

      // Stroke
      svgContent += `<path d="${pathData}" fill="${s.points[0].color}" stroke="none" />`;
    }
  });

  svgContent += `</svg>`;

  // 3. Trigger Download
  const blob = new Blob([svgContent], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  triggerDownload(url, 'drawing.svg');
  URL.revokeObjectURL(url);
}

export const downloadPng = (strokes: StrokeData[], customBounds?: { x: number, y: number, width: number, height: number }) => {
  if (strokes.length === 0) return;

  const viewBox = calculateViewBox(strokes, customBounds);
  if (!viewBox) return;

  // Generate SVG string
  let svgContent = `<svg viewBox="${viewBox.minX} ${viewBox.minY} ${viewBox.width} ${viewBox.height}" xmlns="http://www.w3.org/2000/svg" width="${viewBox.width}" height="${viewBox.height}">`;

  strokes.forEach(s => {
    if (s.points.length > 0) {
      const stroke = getStroke(s.points, getStrokeOptions(s.points[0].size))
      const pathData = getSvgPathFromStroke(stroke)

      if (s.fill) {
        const fillPath = `M ${s.points.map(p => `${p.x},${p.y}`).join(' L ')} Z`;
        svgContent += `<path d="${fillPath}" fill="${s.fill}" stroke="none" />`;
      }

      svgContent += `<path d="${pathData}" fill="${s.points[0].color}" stroke="none" />`;
    }
  });
  svgContent += `</svg>`;

  const img = new Image();
  const blob = new Blob([svgContent], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);

  img.onload = () => {
    const canvas = document.createElement('canvas');
    canvas.width = viewBox.width;
    canvas.height = viewBox.height;
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.drawImage(img, 0, 0);
      const pngUrl = canvas.toDataURL('image/png');
      triggerDownload(pngUrl, 'drawing.png');
    }
    URL.revokeObjectURL(url);
  };

  img.src = url;
}

const triggerDownload = (url: string, filename: string) => {
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}
</file>

<file path="src/sandbox/_functions/drawing/generateShapePoints.ts">
import { DrawingPoint, ShapeType } from "src/sandbox/_providers/DrawingContextProvider";

export function generateShapePoints(
  start: { x: number, y: number },
  end: { x: number, y: number },
  shapeType: ShapeType,
  brushSize: number,
  color: string
): DrawingPoint[] {
  const points: DrawingPoint[] = [];
  // Use a higher density step to smooth out shapes and ensure corners are good.
  // Previously: Math.max(1, brushSize / 4).
  // New: Math.max(1, brushSize / 10) ensures at least 10 "stamps" per brush diameter.
  const step = Math.max(1, brushSize / 10);

  const minX = Math.min(start.x, end.x);
  const maxX = Math.max(start.x, end.x);
  const minY = Math.min(start.y, end.y);
  const maxY = Math.max(start.y, end.y);

  const width = maxX - minX;
  const height = maxY - minY;

  const addPoint = (x: number, y: number) => {
    points.push({ x, y, color, size: brushSize });
  };

  if (shapeType === 'square') {
    // We use interpolation for edges to guarantee we hit the corners exactly,
    // regardless of whether the side length is divisible by the step size.

    // Top edge (minX, minY) -> (maxX, minY)
    const distTop = width;
    const stepsTop = Math.max(1, Math.ceil(distTop / step));
    for (let i = 0; i <= stepsTop; i++) {
      const t = i / stepsTop;
      addPoint(minX + (maxX - minX) * t, minY);
    }

    // Right edge (maxX, minY) -> (maxX, maxY)
    const distRight = height;
    const stepsRight = Math.max(1, Math.ceil(distRight / step));
    for (let i = 0; i <= stepsRight; i++) {
      const t = i / stepsRight;
      addPoint(maxX, minY + (maxY - minY) * t);
    }

    // Bottom edge (maxX, maxY) -> (minX, maxY)
    // Note: iterating backwards or just swapping start/end logic
    const distBottom = width;
    const stepsBottom = Math.max(1, Math.ceil(distBottom / step));
    for (let i = 0; i <= stepsBottom; i++) {
      const t = i / stepsBottom;
      addPoint(maxX - (maxX - minX) * t, maxY);
    }

    // Left edge (minX, maxY) -> (minX, minY)
    const distLeft = height;
    const stepsLeft = Math.max(1, Math.ceil(distLeft / step));
    for (let i = 0; i <= stepsLeft; i++) {
      const t = i / stepsLeft;
      addPoint(minX, maxY - (maxY - minY) * t);
    }

  } else if (shapeType === 'circle') {
    const centerX = minX + width / 2;
    const centerY = minY + height / 2;
    const radiusX = width / 2;
    const radiusY = height / 2;

    // Circumference approximation to determine steps
    const circumference = 2 * Math.PI * Math.sqrt((radiusX * radiusX + radiusY * radiusY) / 2);
    // Ensure accurate curvature even for small circles with large brushes
    const steps = Math.max(10, Math.ceil(circumference / step));

    for (let i = 0; i <= steps; i++) {
      const theta = (i / steps) * 2 * Math.PI;
      const x = centerX + radiusX * Math.cos(theta);
      const y = centerY + radiusY * Math.sin(theta);
      addPoint(x, y);
    }
  } else if (shapeType === 'diamond') {
    const midX = minX + width / 2;
    const midY = minY + height / 2;

    // Top to Right
    const d1 = Math.sqrt(Math.pow(maxX - midX, 2) + Math.pow(midY - minY, 2));
    const steps1 = Math.max(1, Math.ceil(d1 / step));
    for (let i = 0; i <= steps1; i++) {
      const t = i / steps1;
      addPoint(midX + (maxX - midX) * t, minY + (midY - minY) * t);
    }

    // Right to Bottom
    const d2 = Math.sqrt(Math.pow(midX - maxX, 2) + Math.pow(maxY - midY, 2));
    const steps2 = Math.max(1, Math.ceil(d2 / step));
    for (let i = 0; i <= steps2; i++) {
      const t = i / steps2;
      addPoint(maxX + (midX - maxX) * t, midY + (maxY - midY) * t);
    }

    // Bottom to Left
    const d3 = Math.sqrt(Math.pow(minX - midX, 2) + Math.pow(midY - maxY, 2));
    const steps3 = Math.max(1, Math.ceil(d3 / step));
    for (let i = 0; i <= steps3; i++) {
      const t = i / steps3;
      addPoint(midX + (minX - midX) * t, maxY + (midY - maxY) * t);
    }

    // Left to Top
    const d4 = Math.sqrt(Math.pow(midX - minX, 2) + Math.pow(minY - midY, 2));
    const steps4 = Math.max(1, Math.ceil(d4 / step));
    for (let i = 0; i <= steps4; i++) {
      const t = i / steps4;
      addPoint(minX + (midX - minX) * t, midY + (minY - midY) * t);
    }
  } else if (shapeType === 'line') {
    const dist = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
    const steps = Math.max(1, Math.ceil(dist / step));
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      addPoint(start.x + (end.x - start.x) * t, start.y + (end.y - start.y) * t);
    }
  } else if (shapeType === 'arrow') {
    // 1. Draw shaft (Start -> End)
    const dist = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
    const steps = Math.max(1, Math.ceil(dist / step));
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      addPoint(start.x + (end.x - start.x) * t, start.y + (end.y - start.y) * t);
    }

    // 2. Draw Arrowhead
    // Angle of the line
    const angle = Math.atan2(end.y - start.y, end.x - start.x);

    // Length of wings (approx 20% of length or capped min/max?)
    // Let's use a fixed reasonable size for predictability, scaled by brush size slightly
    const headLength = Math.min(dist / 3, 20 + brushSize * 2);
    const wingAngle = Math.PI / 6; // 30 degrees

    // Wing 1
    const x1 = end.x - headLength * Math.cos(angle - wingAngle);
    const y1 = end.y - headLength * Math.sin(angle - wingAngle);

    const distWing1 = Math.sqrt(Math.pow(end.x - x1, 2) + Math.pow(end.y - y1, 2));
    const stepsWing1 = Math.max(1, Math.ceil(distWing1 / step));
    for (let i = 0; i <= stepsWing1; i++) {
      const t = i / stepsWing1;
      // From End to x1,y1
      addPoint(end.x + (x1 - end.x) * t, end.y + (y1 - end.y) * t);
    }

    // Wing 2
    const x2 = end.x - headLength * Math.cos(angle + wingAngle);
    const y2 = end.y - headLength * Math.sin(angle + wingAngle);

    const distWing2 = Math.sqrt(Math.pow(end.x - x2, 2) + Math.pow(end.y - y2, 2));
    const stepsWing2 = Math.max(1, Math.ceil(distWing2 / step));
    for (let i = 0; i <= stepsWing2; i++) {
      const t = i / stepsWing2;
      // From End to x2,y2
      addPoint(end.x + (x2 - end.x) * t, end.y + (y2 - end.y) * t);
    }
  }

  return points;
}
</file>

<file path="src/sandbox/_functions/drawing/getSvgPathFromStroke.ts">
export function getSvgPathFromStroke(stroke: number[][]): string {
  if (!stroke.length) return ''
  const d = stroke.reduce(
    (acc, [x0, y0], i, arr) => {
      const [x1, y1] = arr[(i + 1) % arr.length]
      acc.push(`${i === 0 ? 'M' : 'L'} ${x0.toFixed(2)} ${y0.toFixed(2)}`)
      if (i === arr.length - 1) acc.push(`Z`)
      return acc
    },
    [] as string[]
  )
  return d.join(' ')
}
</file>

<file path="src/sandbox/_functions/drawing/selectionUtils.ts">
import { DrawingPoint, StrokeData } from "src/sandbox/_providers/DrawingContextProvider";
import { measureTextDimensions } from "./sharedUtils";

/**
 * Calculates the distance between a point (p) and a line segment (v - w).
 */
function distToSegmentSquared(p: { x: number, y: number }, v: { x: number, y: number }, w: { x: number, y: number }) {
  const l2 = ((v.x - w.x) * (v.x - w.x)) + ((v.y - w.y) * (v.y - w.y));
  if (l2 === 0) return ((p.x - v.x) * (p.x - v.x)) + ((p.y - v.y) * (p.y - v.y));
  let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
  t = Math.max(0, Math.min(1, t));
  return ((p.x - v.x - t * (w.x - v.x)) * (p.x - v.x - t * (w.x - v.x))) +
    ((p.y - v.y - t * (w.y - v.y)) * (p.y - v.y - t * (w.y - v.y)));
}

function distToSegment(p: { x: number, y: number }, v: { x: number, y: number }, w: { x: number, y: number }) {
  return Math.sqrt(distToSegmentSquared(p, v, w));
}

/**
 * Checks if a point is close enough to any segment in the stroke.
 */
export function hitTestStroke(point: { x: number, y: number }, stroke: StrokeData, zoom: number): boolean {
  // TEXT HIT TEST
  if (stroke.text !== undefined) {
    if (stroke.points.length === 0) return false;
    const p = stroke.points[0];
    const fontSize = p.size || 20;

    const { width: w, height: h } = measureTextDimensions(stroke.text, fontSize);

    const padding = 10 / zoom; // Generous padding for easier selection
    return point.x >= p.x - padding && point.x <= p.x + w + padding &&
      point.y >= p.y - padding && point.y <= p.y + h + padding;
  }

  const { points } = stroke;
  if (points.length === 0) return false;

  // Base threshold, adjusted by zoom. Use largest point size in stroke as rough thickness guide?
  // Or just a fixed "comfortable" click radius.
  // Prompt says: "close enough to the rendered vector path".
  // Let's use a base pixel threshold + stroke width logic.

  // Average stroke width for this stroke? Or max?
  const strokeWidth = points[0]?.size || 10;
  const hitThreshold = (strokeWidth / 2) + (10 / zoom); // 10 screen pixels tolerance

  if (points.length === 1) {
    const p = points[0];
    const dist = Math.sqrt(Math.pow(point.x - p.x, 2) + Math.pow(point.y - p.y, 2));
    return dist <= hitThreshold;
  }

  for (let i = 0; i < points.length - 1; i++) {
    const p1 = points[i];
    const p2 = points[i + 1];
    if (distToSegment(point, p1, p2) <= hitThreshold) {
      return true;
    }
  }

  return false;
}

/**
 * Returns true if the stroke is considered "inside" the selection box.
 * Criteria: > 40% of points inside.
 */
export function isStrokeInRect(stroke: StrokeData, rect: { x: number, y: number, width: number, height: number }): boolean {
  const { points } = stroke;
  if (points.length === 0) return false;

  // Handle negative width/height by normalizing rect
  const rX = rect.width < 0 ? rect.x + rect.width : rect.x;
  const rY = rect.height < 0 ? rect.y + rect.height : rect.y;
  const rW = Math.abs(rect.width);
  const rH = Math.abs(rect.height);

  let pointsInside = 0;
  for (const p of points) {
    if (p.x >= rX && p.x <= rX + rW && p.y >= rY && p.y <= rY + rH) {
      pointsInside++;
    }
  }

  return (pointsInside / points.length) >= 0.4;
}

/**
 * Returns true if the stroke intersects with the selection box (even partially).
 * Uses simple AABB intersection.
 */
export function isStrokeIntersectingRect(stroke: StrokeData, rect: { x: number, y: number, width: number, height: number }): boolean {
  const bounds = getStrokesBoundingBox([stroke]);
  if (!bounds) return false;

  const rX = rect.width < 0 ? rect.x + rect.width : rect.x;
  const rY = rect.height < 0 ? rect.y + rect.height : rect.y;
  const rW = Math.abs(rect.width);
  const rH = Math.abs(rect.height);

  // Check AABB intersection
  return (bounds.minX < rX + rW &&
    bounds.maxX > rX &&
    bounds.minY < rY + rH &&
    bounds.maxY > rY);
}

/**
 * Returns true if a point is inside the given rectangle bounds.
 */
export function isPointInRect(point: { x: number, y: number }, rect: { minX: number, minY: number, maxX: number, maxY: number }): boolean {
  return point.x >= rect.minX && point.x <= rect.maxX && point.y >= rect.minY && point.y <= rect.maxY;
}

/**
 * Calculates the bounding box of a set of strokes.
 */
export function getStrokesBoundingBox(strokes: StrokeData[]): { minX: number, minY: number, maxX: number, maxY: number } | null {
  if (strokes.length === 0) return null;

  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;

  let maxStrokeWidth = 0;
  let hasPoints = false;

  for (const stroke of strokes) {
    if (stroke.text !== undefined) {
      // HANDLE TEXT - Calculate dimensions dynamically
      if (stroke.points.length > 0) {
        hasPoints = true;
        const p = stroke.points[0];
        const fontSize = p.size || 20;

        const { width: w, height: h } = measureTextDimensions(stroke.text, fontSize);

        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.x + w > maxX) maxX = p.x + w;
        if (p.y + h > maxY) maxY = p.y + h;
      }
    } else {
      // HANDLE NORMAL STROKES
      for (const p of stroke.points) {
        hasPoints = true;
        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x;
        if (p.y > maxY) maxY = p.y;
        if (p.size > maxStrokeWidth) maxStrokeWidth = p.size;
      }
    }
  }

  if (!hasPoints) return null;

  // Add padding: Half the max stroke width (to cover the stroke thickness) + 5px visual clearance
  const padding = (maxStrokeWidth / 2) + 5;
  return {
    minX: minX - padding,
    minY: minY - padding,
    maxX: maxX + padding,
    maxY: maxY + padding
  };
}
/**
 * Returns the resize handle that was hit, or null.
 * Handles: 'nw', 'ne', 'sw', 'se'
 */
export function hitTestResizeHandle(point: { x: number, y: number }, bounds: { minX: number, minY: number, maxX: number, maxY: number }, zoom: number): 'nw' | 'ne' | 'sw' | 'se' | null {
  const handleSize = 8 / zoom;
  const halfHandle = handleSize / 2;
  const tolerance = handleSize; // generous hit area

  const check = (x: number, y: number) => {
    return Math.abs(point.x - x) <= tolerance && Math.abs(point.y - y) <= tolerance;
  }

  // Corners (visual positions are shifted by half handle size, but we check center/corner)
  // Actually in DrawingLayer we render: x={minX - 4/zoom} ...
  // So center of handle is at minX, minY.

  if (check(bounds.minX, bounds.minY)) return 'nw';
  if (check(bounds.maxX, bounds.minY)) return 'ne';
  if (check(bounds.maxX, bounds.maxY)) return 'se';
  if (check(bounds.minX, bounds.maxY)) return 'sw';

  return null;
}
</file>

<file path="src/sandbox/_functions/drawing/sharedUtils.ts">
/**
 * Shared utilities for drawing operations.
 * Consolidates duplicate geometry and text measurement logic.
 */

/**
 * Ray casting algorithm to check if a point is inside a polygon.
 * Used by fill tool and eraser on filled shapes.
 */
export const isPointInPolygon = (
  point: { x: number; y: number },
  polygon: { x: number; y: number }[]
): boolean => {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x, yi = polygon[i].y;
    const xj = polygon[j].x, yj = polygon[j].y;
    const intersect = ((yi > point.y) !== (yj > point.y))
      && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
};

/**
 * Measures the dimensions of text content using canvas.
 * Returns { width, height } for the text at given font size.
 */
export const measureTextDimensions = (
  text: string | undefined,
  fontSize: number
): { width: number; height: number } => {
  let width = 100;
  let height = fontSize * 1.5;

  if (text) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.font = `${fontSize}px sans-serif`;
      const lines = text.split('\n');
      let maxWidth = 0;
      lines.forEach((line: string) => {
        const lineWidth = ctx.measureText(line).width;
        if (lineWidth > maxWidth) maxWidth = lineWidth;
      });
      width = Math.max(50, maxWidth + 20); // padding
      height = Math.max(fontSize * 1.5, lines.length * fontSize * 1.2 + 10);
    }
  }

  return { width, height };
};
</file>

<file path="src/sandbox/_functions/drawing/snappingUtils.ts">
import { StrokeData } from "src/sandbox/_providers/DrawingContextProvider";
import { getStrokesBoundingBox } from "./selectionUtils";

export type SnappingGuide = {
  type: 'horizontal' | 'vertical' | 'gap-horizontal' | 'gap-vertical';
  orientation: 'horizontal' | 'vertical';
  position: number; // For line guides
  start: number;
  end: number;
  gapSize?: number; // For gap guides
};

/**
 * Calculates snapping offsets and guides for a moving set of objects.
 */
export function getSnappingGuides(
  movingStrokes: StrokeData[],
  otherStrokes: StrokeData[],
  dragOffset: { x: number, y: number },
  zoom: number
): { dx: number, dy: number, guides: SnappingGuide[] } {

  const SNAP_THRESHOLD = 8 / zoom; // Slightly larger threshold for better feel

  // 1. Calculate bounding box of moving strokes with current dragOffset
  const initialBounds = getStrokesBoundingBox(movingStrokes);
  if (!initialBounds) return { dx: dragOffset.x, dy: dragOffset.y, guides: [] };

  const currentBounds = {
    minX: initialBounds.minX + dragOffset.x,
    minY: initialBounds.minY + dragOffset.y,
    maxX: initialBounds.maxX + dragOffset.x,
    maxY: initialBounds.maxY + dragOffset.y,
    centerX: initialBounds.minX + dragOffset.x + (initialBounds.maxX - initialBounds.minX) / 2,
    centerY: initialBounds.minY + dragOffset.y + (initialBounds.maxY - initialBounds.minY) / 2,
    width: initialBounds.maxX - initialBounds.minX,
    height: initialBounds.maxY - initialBounds.minY
  };

  const movingPoints = {
    left: currentBounds.minX,
    right: currentBounds.maxX,
    top: currentBounds.minY,
    bottom: currentBounds.maxY,
    centerX: currentBounds.centerX,
    centerY: currentBounds.centerY
  };

  // 2. Identify candidate snap lines AND gap intervals from other strokes
  const candidatesX: number[] = [];
  const candidatesY: number[] = [];

  // Store bounds for gap analysis
  const otherBounds: { minX: number, maxX: number, minY: number, maxY: number, centerX: number, centerY: number }[] = [];

  for (const s of otherStrokes) {
    const b = getStrokesBoundingBox([s]);
    if (b) {
      candidatesX.push(b.minX, b.maxX, b.minX + (b.maxX - b.minX) / 2);
      candidatesY.push(b.minY, b.maxY, b.minY + (b.maxY - b.minY) / 2);
      otherBounds.push({
        minX: b.minX, maxX: b.maxX, minY: b.minY, maxY: b.maxY,
        centerX: b.minX + (b.maxX - b.minX) / 2,
        centerY: b.minY + (b.maxY - b.minY) / 2
      });
    }
  }

  // 3. Find closest snaps (Alignment)
  let snapDx = 0;
  let snapDy = 0;
  let minDistX = SNAP_THRESHOLD;
  let minDistY = SNAP_THRESHOLD;
  const guides: SnappingGuide[] = [];

  // --- Alignment Snapping ---

  // Snap X
  for (const targetX of candidatesX) {
    const checkX = (current: number) => {
      const d = targetX - current;
      if (Math.abs(d) < minDistX) { minDistX = Math.abs(d); snapDx = d; }
    };
    checkX(movingPoints.left);
    checkX(movingPoints.right);
    checkX(movingPoints.centerX);
  }

  // Snap Y
  for (const targetY of candidatesY) {
    const checkY = (current: number) => {
      const d = targetY - current;
      if (Math.abs(d) < minDistY) { minDistY = Math.abs(d); snapDy = d; }
    };
    checkY(movingPoints.top);
    checkY(movingPoints.bottom);
    checkY(movingPoints.centerY);
  }

  // --- Gap Snapping ---
  // Only check if we haven't found a strong alignment snap, OR try to combine?
  // Usually Gap snapping is subtle. Let's prioritize alignment, but if alignment is loose, check gaps.
  // Actually, gap snapping should also adjust snapDx/snapDy.

  // We look for gaps between 'moving' and 'A', matching gap between 'A' and 'B'.

  // Horizontal Gaps
  // We need to sort objects by X to find neighbors? Not strict, but helps.
  // Brute force: match (Moving <-> A) distance to (A <-> B) distance.

  let gapSnapDx = 0;
  let gapSnapDy = 0;
  let minGapDistX = SNAP_THRESHOLD;
  let minGapDistY = SNAP_THRESHOLD;

  if (minDistX === SNAP_THRESHOLD) { // Only try gap snap if no strong alignment snap
    // Look for X gaps
    // 1. Moving is Right of A: Gap = Moving.Left - A.Right. Match with A.Left - B.Right?
    // 2. Moving is Left of A: Gap = A.Left - Moving.Right.

    for (const A of otherBounds) {
      // Check gaps between A and other B's
      // We only care about X gaps if they are vertically aligned (loosely) ?
      // For simplicity, just check pure X projection gaps first, or require overlap in Y?
      // Standard design tools usually require some overlap in orthogonal axis.
      const isVerticallyOverlapping = (Math.max(currentBounds.minY, A.minY) < Math.min(currentBounds.maxY, A.maxY));

      if (!isVerticallyOverlapping) continue;

      // Case 1: Moving is on the Right of A ( A [gap] Moving )
      // We want Gap(A, Moving) == Gap(B, A)
      // => Moving.Left - A.Right == A.Left - B.Right
      // => Moving.Left = A.Right + (A.Left - B.Right)

      for (const B of otherBounds) {
        if (A === B) continue;
        const isVerticallyOverlappingB = (Math.max(A.minY, B.minY) < Math.min(A.maxY, B.maxY));
        if (!isVerticallyOverlappingB) continue;

        // If B is left of A ( B [gap] A )
        if (B.maxX < A.minX) {
          const existingGap = A.minX - B.maxX;
          const targetLeft = A.maxX + existingGap;
          const diff = targetLeft - movingPoints.left; // Adjust moving so Left hits target

          if (Math.abs(diff) < minGapDistX) {
            minGapDistX = Math.abs(diff);
            gapSnapDx = diff;
            // Don't add guide yet, wait for best.
          }
        }
        // If B is right of A ( A [gap] B ) -> We want Moving [gap] A ?? No, logic usually implies sequence.
        // If we are placing Moving to the Left of A: Moving [gap] A. Match B [gap] A? (i.e. B is Left of A too?)
        // Or A [gap] B?
        // Let's simplified: Check if Moving is placing itself such that it creates a gap equal to ANY existing gap between X-neighbors A and B.
      }
    }

    // Also Handle explicit "Gap of 10" mentioned by user?
    // "when having a gap of 10 and than getting a third object it should be able to also snap... when it has a gap to one of the items with a gap of 10"
    // This confirms detecting existing gaps.
  }

  // Simplified Gap Search for X (Optimized)
  // Find all horizontal gaps between existing objects A and B.
  const existingXGaps: number[] = [];
  // For every pair A, B where OverlapY, calculate gap.
  for (let i = 0; i < otherBounds.length; i++) {
    for (let j = i + 1; j < otherBounds.length; j++) {
      const A = otherBounds[i];
      const B = otherBounds[j];
      if (Math.max(A.minY, B.minY) < Math.min(A.maxY, B.maxY)) { // Overlap Y
        const gap1 = A.minX - B.maxX; // B is left of A
        if (gap1 > 0) existingXGaps.push(gap1);
        const gap2 = B.minX - A.maxX; // A is left of B
        if (gap2 > 0) existingXGaps.push(gap2);
      }
    }
  }

  // Now check if Moving creates a matching gap with ANY A
  if (minDistX === SNAP_THRESHOLD) { // Only if no alignment
    for (const A of otherBounds) {
      if (Math.max(currentBounds.minY, A.minY) < Math.min(currentBounds.maxY, A.maxY)) { // Overlap Y
        // Check Moving to Right of A
        const currentGapRight = movingPoints.left - A.maxX;
        for (const g of existingXGaps) {
          if (Math.abs(currentGapRight - g) < minGapDistX) {
            minGapDistX = Math.abs(currentGapRight - g);
            gapSnapDx = g - currentGapRight; // Correction
          }
        }

        // Check Moving to Left of A
        const currentGapLeft = A.minX - movingPoints.right;
        for (const g of existingXGaps) {
          if (Math.abs(currentGapLeft - g) < minGapDistX) {
            minGapDistX = Math.abs(currentGapLeft - g);
            gapSnapDx = -(g - currentGapLeft); // Correction: move moving left (negative) to increase gap?
            // gap = A.minX - (Right + dx) = A.minX - Right - dx
            // We want gap == g
            // g = A.minX - Right - dx  =>  dx = A.minX - Right - g
            // Current Gap = A.minX - Right
            // dx = Current - g. 
            // Wait, if current is 12, g is 10. we want distance 10.
            // A.min - Right = 12. We want 10. We need to move Right by +2 (right). 
            // dx = 2.
            // dx = currentGap - g.
            gapSnapDx = currentGapLeft - g;
          }
        }
      }
    }
  }

  if (gapSnapDx !== 0 && Math.abs(gapSnapDx) < SNAP_THRESHOLD) {
    snapDx = gapSnapDx;
  }

  // Same logic for Y Gaps
  const existingYGaps: number[] = [];
  for (let i = 0; i < otherBounds.length; i++) {
    for (let j = i + 1; j < otherBounds.length; j++) {
      const A = otherBounds[i];
      const B = otherBounds[j];
      if (Math.max(A.minX, B.minX) < Math.min(A.maxX, B.maxX)) { // Overlap X
        const gap1 = A.minY - B.maxY;
        if (gap1 > 0) existingYGaps.push(gap1);
        const gap2 = B.minY - A.maxY;
        if (gap2 > 0) existingYGaps.push(gap2);
      }
    }
  }

  gapSnapDy = 0;
  if (minDistY === SNAP_THRESHOLD) {
    // FIX: Use the SNAPPED X position to check for vertical column overlap.
    // If we just snapped to an alignment guide in X, we are now "in the column".
    const snappedMinX = currentBounds.minX + snapDx;
    const snappedMaxX = currentBounds.maxX + snapDx;

    for (const A of otherBounds) {
      if (Math.max(snappedMinX, A.minX) < Math.min(snappedMaxX, A.maxX)) { // Overlap X (using snapped position)
        // Moving Below A (Top - A.Bottom)
        const currentGapBottom = movingPoints.top - A.maxY;
        for (const g of existingYGaps) {
          if (Math.abs(currentGapBottom - g) < minGapDistY) {
            // we want Gap == g
            // Gap = (Top + dy) - A.maxY
            // g = Top + dy - A.maxY
            // dy = g + A.maxY - Top 
            // = g - (Top - A.maxY) = g - currentGap
            gapSnapDy = g - currentGapBottom;
            minGapDistY = Math.abs(gapSnapDy);
          }
        }
        // Moving Above A (A.Top - Moving.Bottom)
        const currentGapTop = A.minY - movingPoints.bottom;
        for (const g of existingYGaps) {
          if (Math.abs(currentGapTop - g) < minGapDistY) {
            // Gap = A.minY - (Bottom + dy)
            // g = A.minY - Bottom - dy
            // dy = A.minY - Bottom - g
            // dy = currentGap - g
            gapSnapDy = currentGapTop - g;
            minGapDistY = Math.abs(gapSnapDy);
          }
        }
      }
    }
  }

  if (gapSnapDy !== 0 && Math.abs(gapSnapDy) < SNAP_THRESHOLD) {
    snapDy = gapSnapDy;
  }


  // 4. Generate Guides (Recalculate with final snap)
  const finalDx = dragOffset.x + snapDx;
  const finalDy = dragOffset.y + snapDy;

  // Re-verify alignment guides
  // ... (Simplification: just show guide if we snapped)
  if (snapDx !== 0) {
    // Find what we snapped to
    const finalLeft = movingPoints.left + snapDx;
    const finalRight = movingPoints.right + snapDx;
    const finalCenterX = movingPoints.centerX + snapDx;

    // Did we snap to a specific target?
    // Or was it a gap snap?
    // Visual feedback for gap snap is trickier (showing two gaps equal).
    // For alignment:

    // Check alignments again
    let aligned = false;
    for (const tx of candidatesX) {
      if (Math.abs(finalLeft - tx) < 0.01 || Math.abs(finalRight - tx) < 0.01 || Math.abs(finalCenterX - tx) < 0.01) {
        guides.push({ type: 'vertical', orientation: 'vertical', position: tx, start: -10000, end: 10000 });
        aligned = true;
      }
    }

    // If not aligned, it was a gap snap?
    if (!aligned) {
      // We can add "Gap" guides here later. For now, simple vertical line at edges to show 'something' happened?
      // Ideally we show arrows <-> 10px <->
    }
  }

  if (snapDy !== 0) {
    const finalTop = movingPoints.top + snapDy;
    const finalBottom = movingPoints.bottom + snapDy;
    const finalCenterY = movingPoints.centerY + snapDy;

    for (const ty of candidatesY) {
      if (Math.abs(finalTop - ty) < 0.01 || Math.abs(finalBottom - ty) < 0.01 || Math.abs(finalCenterY - ty) < 0.01) {
        guides.push({ type: 'horizontal', orientation: 'horizontal', position: ty, start: -10000, end: 10000 });
      }
    }
  }

  return {
    dx: finalDx,
    dy: finalDy,
    guides
  };
}
</file>

<file path="src/sandbox/_functions/files/babelUtils.ts">
import { getFileExtension } from './fileUtils';

export const BABEL_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'] as const;

export const VIEWPORT_PRESETS = {
  LAPTOP: { width: 1440, height: 900 },
  TABLET: { width: 768, height: 1024 },
  PHONE: { width: 375, height: 667 },
  NONE: { width: 800, height: 600 }
} as const;

export function isBabelCompatible(filename: string): boolean {
  const ext = getFileExtension(filename);
  return BABEL_EXTENSIONS.some(babelExt => babelExt === `.${ext}`);
}

export function getFilenameWithoutExtension(filename: string): string {
  if (!filename) return '';
  const lastDot = filename.lastIndexOf('.');
  return lastDot === -1 ? filename : filename.substring(0, lastDot);
}

// Validate filename format (basic validation)
export function isValidFilename(filename: string): boolean {
  if (!filename || filename.trim() === '') return false;
  const invalidChars = /[<>:"|?*]/;
  return !invalidChars.test(filename);
}
</file>

<file path="src/sandbox/_functions/grid/onMouseLeave.ts">

</file>

<file path="src/sandbox/_functions/grid/useGridKeyboardShortcuts.ts">
import { useEffect } from "react";
import { useBlueprints } from "src/sandbox/_providers/BlueprintsContextProvider";
import { useDrawing } from "src/sandbox/_providers/DrawingContextProvider";

/**
 * Grid-level keyboard shortcuts for undo/redo of grid items (files, notes).
 * This is SEPARATE from drawing shortcuts (handled in useKeyboardShortcuts.ts).
 * 
 * Only handles Ctrl+Z/Y when:
 * - Monaco editor is NOT focused
 * - TipTap notes are NOT focused  
 * - CodeMirror blocks are NOT focused
 * - Drawing mode is NOT enabled (drawing has its own shortcuts)
 */
export function useGridKeyboardShortcuts() {
  const {
    undoChange,
    redoChange,
    canUndo,
    canRedo
  } = useBlueprints();

  const { drawingEnabled } = useDrawing();

  useEffect(() => {
    const isEditorFocused = () => {
      const activeEl = document.activeElement;
      if (!activeEl) return false;

      const isTyping = activeEl instanceof HTMLTextAreaElement || activeEl instanceof HTMLInputElement;
      const monacoFocused = !!activeEl.closest('.monaco-editor');
      const tiptapFocused = !!activeEl.closest('.tiptap, .ProseMirror');
      const codemirrorFocused = !!activeEl.closest('.cm-editor');

      return isTyping || monacoFocused || tiptapFocused || codemirrorFocused;
    };

    const handleKeyDown = (e: KeyboardEvent) => {
      if (drawingEnabled) return;
      if (isEditorFocused()) return;

      // Undo: Ctrl+Z (not Shift)
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        if (canUndo) {
          e.preventDefault();
          undoChange();
        }
      }

      // Redo: Ctrl+Y or Ctrl+Shift+Z
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        if (canRedo) {
          e.preventDefault();
          redoChange();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [drawingEnabled, undoChange, redoChange, canUndo, canRedo]);
}
</file>

<file path="src/sandbox/_providers/BuilderPanelContextProvider.tsx">
import { createContext, useContext, useState, ReactNode, RefObject, SetStateAction, Dispatch, useRef, useEffect } from 'react';

export enum BuilderMenuMode {
  CODE = "CODE",
  BUILDER = "BUILDER",
  CLOSED = "CLOSED"
}

type BuilderPanelContextType = {
  builderMenuMode: BuilderMenuMode;
  setBuilderMenuMode: Dispatch<SetStateAction<BuilderMenuMode>>;
  
  prevBuilderMenuMode: BuilderMenuMode;
  setPrevBuilderMenuMode: Dispatch<SetStateAction<BuilderMenuMode>>;

  windowDividerDragging: RefObject<boolean>;

  windowDivider: boolean;
  setWindowDivider: Dispatch<SetStateAction<boolean>>;

  windowDividerPosition: number | null;
  setWindowDividerPosition: Dispatch<SetStateAction<number | null>>;

  lastPositionWindowDivider: RefObject<number>;
};

const BuilderPanelContext = createContext<BuilderPanelContextType | undefined>(undefined);

export const BuilderPanelProvider = ({ children }: { children: ReactNode }) => {
  const [builderMenuMode, setBuilderMenuMode] = useState<BuilderMenuMode>(BuilderMenuMode.CLOSED);
  const [prevBuilderMenuMode, setPrevBuilderMenuMode] = useState<BuilderMenuMode>(BuilderMenuMode.CODE);

  const windowDividerDragging: RefObject<boolean> = useRef(false);
  const [windowDivider, setWindowDivider] = useState<boolean>(false);
  const [windowDividerPosition, setWindowDividerPosition] = useState<number | null>(null);
  const lastPositionWindowDivider = useRef<number>(0);

  useEffect(() => {
    if (builderMenuMode == BuilderMenuMode.CLOSED) { return; }
    setPrevBuilderMenuMode(builderMenuMode);
  }, [builderMenuMode])

  return (
    <BuilderPanelContext.Provider value={{ 
      builderMenuMode, 
      setBuilderMenuMode,

      prevBuilderMenuMode, 
      setPrevBuilderMenuMode,
      
      windowDividerPosition,
      setWindowDividerPosition,

      windowDividerDragging,
      
      windowDivider,
      setWindowDivider,

      lastPositionWindowDivider,
    }}>
      {children}
    </BuilderPanelContext.Provider>
  );
};

export const useBuilderPanel = () => {
  const context = useContext(BuilderPanelContext);
  if (!context) {
    throw new Error('useMenuState must be used within a MenuStateProvider');
  }
  return context;
};
</file>

<file path="src/sandbox/_providers/NotesContextProvider.tsx">
import { createContext, useContext, useState, ReactNode, SetStateAction, Dispatch, useEffect } from 'react';
import { NoteOptionsVisibleState } from '../types/NotesOptionsTypes';
import { Editor } from '@tiptap/react';

type NotesContextType = {
  noteOptionsMenuOpen: NoteOptionsVisibleState;
  setNoteOptionsMenuOpen: Dispatch<SetStateAction<NoteOptionsVisibleState>>;
  noteOptionsMenuPosition: { x: number; y: number } | null;
  setNoteOptionsMenuPosition: Dispatch<SetStateAction<{ x: number; y: number } | null>>;
  lastActiveEditor: { editor: Editor; position: number } | null;
  setLastActiveEditor: Dispatch<SetStateAction<{ editor: Editor; position: number } | null>>;
  wasNoteRecentlyActive: boolean;
  setWasNoteRecentlyActive: Dispatch<SetStateAction<boolean>>;
};

const NotesContext = createContext<NotesContextType | undefined>(undefined);

export const NotesProvider = ({ children }: { children: ReactNode }) => {
  const [noteOptionsMenuOpen, setNoteOptionsMenuOpen] = useState<NoteOptionsVisibleState>(NoteOptionsVisibleState.CLOSED);
  const [noteOptionsMenuPosition, setNoteOptionsMenuPosition] = useState<{ x: number; y: number } | null>(null);
  const [lastActiveEditor, setLastActiveEditor] = useState<{ editor: Editor; position: number } | null>(null);
  const [wasNoteRecentlyActive, setWasNoteRecentlyActive] = useState(false);

  useEffect(() => {

    if (!noteOptionsMenuPosition) { return; }

    const maxHeight = window.innerHeight;
    const maxWidth = window.innerWidth;
    const minHeight = 340; // value has no relation to menu height, just a comfortable min height
    const minWidth = 20; // value has no relation to menu width, just a comfortable min width

    const menuHeight = 312 / 2; // menu opens half up and half down from the cursor thats why half height
    const menuWidth = 288; // full width because it only opens to the right

    let newX = noteOptionsMenuPosition.x;
    let newY = noteOptionsMenuPosition.y;

    if (noteOptionsMenuPosition.x + menuWidth > maxWidth) {
      newX = maxWidth - menuWidth - 40;
    } else if (noteOptionsMenuPosition.y + menuHeight > maxHeight) {
      newY = maxHeight - menuHeight - 40;
    }

    if (noteOptionsMenuPosition.x < minWidth) {
      newX = minWidth;
    } else if (noteOptionsMenuPosition.y < minHeight) {
      newY = minHeight;
    }

    if (newX !== noteOptionsMenuPosition.x || newY !== noteOptionsMenuPosition.y) {
      setNoteOptionsMenuPosition({ x: newX, y: newY });
    }

  }, [noteOptionsMenuPosition]);

  return (
    <NotesContext.Provider value={{
      noteOptionsMenuOpen,
      setNoteOptionsMenuOpen,

      noteOptionsMenuPosition,
      setNoteOptionsMenuPosition,

      lastActiveEditor,
      setLastActiveEditor,

      wasNoteRecentlyActive,
      setWasNoteRecentlyActive
    }}>
      {children}
    </NotesContext.Provider>
  );
};

export const useNotes = () => {
  const context = useContext(NotesContext);
  if (!context) {
    throw new Error('useNotes must be used within a NotesProvider');
  }
  return context;
};
</file>

<file path="src/sandbox/types/gridProps.ts">
export interface GridElement {
  id: string;
  x: number;
  y: number;
  width: number;
  height: number;
  color?: string;
};
</file>

<file path="src/sandbox/types/react-jsx-runtime.d.ts">
import * as React from "./";
export { Fragment } from "./";

export namespace JSX {
    type ElementType = React.JSX.ElementType;
    interface Element extends React.JSX.Element {}
    interface ElementClass extends React.JSX.ElementClass {}
    interface ElementAttributesProperty extends React.JSX.ElementAttributesProperty {}
    interface ElementChildrenAttribute extends React.JSX.ElementChildrenAttribute {}
    type LibraryManagedAttributes<C, P> = React.JSX.LibraryManagedAttributes<C, P>;
    interface IntrinsicAttributes extends React.JSX.IntrinsicAttributes {}
    interface IntrinsicClassAttributes<T> extends React.JSX.IntrinsicClassAttributes<T> {}
    interface IntrinsicElements extends React.JSX.IntrinsicElements {}
}

/**
 * Create a React element.
 *
 * You should not use this function directly. Use JSX and a transpiler instead.
 */
export function jsx(
    type: React.ElementType,
    props: unknown,
    key?: React.Key,
): React.ReactElement;

/**
 * Create a React element.
 *
 * You should not use this function directly. Use JSX and a transpiler instead.
 */
export function jsxs(
    type: React.ElementType,
    props: unknown,
    key?: React.Key,
): React.ReactElement;
</file>

<file path="src/sandbox/types/viewportMapping.ts">
export enum Viewports {
  LAPTOP = "Laptop",
  TABLET = "Tablet",
  PHONE = "Phone",
  NONE = "None",
}

export const viewportMapping = {
  [Viewports.LAPTOP]: { width: 1440, height: 900 },
  [Viewports.TABLET]: { width: 768, height: 1024 },
  [Viewports.PHONE]: { width: 375, height: 667 },
  [Viewports.NONE]: { width: 0, height: 0 },
};
</file>

<file path="src/scrollbar-dark.css">
/* Global scrollbar styling */

/* For modern browsers (WebKit-based like Chrome, Edge, Safari) */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: transparent;
}

::-webkit-scrollbar-thumb {
    background-color: #a3a3a3; /* Medium dark gray */
    border-radius: 4px;
    transition: background-color 0.3s ease;
}

::-webkit-scrollbar-thumb:hover {
    background-color: #6b6b6b; /* Lighter gray on hover */
}

::-webkit-scrollbar-button {
    display: none;
}
</file>

<file path="src/scrollbar-white.css">
/* For modern browsers (WebKit-based like Chrome, Edge, Safari) */
::-webkit-scrollbar {
    width: 8px; /* Customize width */
    height: 8px; /* Customize height for horizontal scrollbars */
}
  
::-webkit-scrollbar-track {
    background: transparent; /* Remove the white background behind the scrollbar */
}
  
::-webkit-scrollbar-thumb {
    background-color: #ffffff; /* Customize thumb color */
    border-radius: 4px; /* Optional: make scrollbar thumb rounded */
    transition: all 0.3s; /* Optional: add hover effect */
    padding: 20px; /* Optional: just make scrollbar thinner */
}
  
::-webkit-scrollbar-thumb:hover {
    background-color: #ffffff; /* Customize thumb color on hover */
}
  
::-webkit-scrollbar-button {
    display: none; /* Remove arrows */
}
</file>

<file path="src/settings/_api/updateUser.ts">
import { PrismaClient } from '@prisma/client';
import { AuthProps, SessionLayout } from 'config';
import path from 'path';
import { GameDataProps } from 'server/functions/game';
import sharp from "sharp";

interface Functions {
  prisma: PrismaClient;

  saveSession: (sessionId: string, data: any) => Promise<boolean>;
  getSession: (sessionId: string) => Promise<any | null>;
  deleteSession: (sessionId: string) => Promise<boolean>;

  saveGameData: (gameCode: string, data: GameDataProps) => Promise<boolean>;
  getGameData: (gameCode: string) => Promise<GameDataProps | null>;
  deleteGameData: (gameCode: string) => Promise<boolean>;
  gameExists: (gameCode: string) => Promise<boolean>;

  tryCatch: <T, P>(func: (values: P) => Promise<T> | T, params?: P) => Promise<[any, T | null]>;

  [key: string]: any; // allows for other functions that are not defined as a type but do exist in the functions folder
};

interface ApiParams {
  data: Record<string, any>;
  functions: Functions;
  user: SessionLayout;
};


const auth: AuthProps = {
  login: true, //? checks if the session data has an id. 
  additional: [
  ]
}

// const __filename = fileURLToPath(import.meta.url);
// const __dirname = path.dirname(__filename);
const main = async ({ data, functions, user }: ApiParams) => {

  const { avatar, name, theme, language } = data;

  if (avatar) {
    console.log(avatar)
    const matches = avatar.match(/^data:(.+);base64,(.+)$/);
    if (matches) {
      const base64Data = matches[2];
      const buffer = Buffer.from(base64Data, "base64");

      // save as WebP under user's ID
      const fileName = `${user.id}.webp`;
      const filePath = path.join(process.cwd(), "uploads", fileName);

      try {
        await sharp(buffer)
          .webp({ quality: 80 }) // adjust quality if you want
          .toFile(filePath);

        console.log(`✅ Avatar saved for ${user.name} at ${filePath}`);
      } catch (err) {
        console.error("Error saving avatar:", err);
        return { status: "error" };
      }
    } else { console.log("failed to upload new avatar") }
  }

  let newData = {};

  if (avatar) newData = { ...newData, avatar: `${user.id}` }
  if (name) newData = { ...newData, name }
  if (theme) newData = { ...newData, theme }
  if (language) newData = { ...newData, language }

  //? here we can assume the avatar was uploaded successfully if avatar !=  null

  console.log(user)
  if (!user.token) return { status:'error' }

  await functions.prisma.user.update({
    where: { id: user.id },
    data: newData
  })

  await functions.saveSession(user.token, {...user, ...newData});

  return { status: 'success' }
}

export { auth, main }
</file>

<file path="src/test/_sync/updateCounter_client.ts">
import { ClientSyncProps } from "config";

const main = ({ user }: ClientSyncProps) => {
  //? here you can do certain checks for each user and determine if they should get the event or not
  //? e.g. user.admin == true or user.location.pathName == '/test'
  console.log(user)
  if (user?.location?.pathName == '/test') {
    return {
      status: 'success',
    };
  }
}

export { main }
</file>

<file path="src/test/_sync/updateCounter_server.ts">
import { AuthProps, ServerSyncProps } from "config";

const auth: AuthProps = {
  login: true,
  additional: []
}

const main = async ({ clientData }: ServerSyncProps) => {

  console.log(clientData);
  // here you can maybe update a counter in your server memory with redis or update your database cause this file only runs once

  return {
    status: 'success',
    increase: clientData.increase
  }
}

export { main, auth };
</file>

<file path="src/types/react-hooks.d.ts">
declare const useState: typeof import("react").useState;
declare const useEffect: typeof import("react").useEffect;
declare const useContext: typeof import("react").useContext;
</file>

<file path="src/types/react-jsx-runtime.d.ts">
import * as React from "./";
export { Fragment } from "./";

export namespace JSX {
    type ElementType = React.JSX.ElementType;
    interface Element extends React.JSX.Element {}
    interface ElementClass extends React.JSX.ElementClass {}
    interface ElementAttributesProperty extends React.JSX.ElementAttributesProperty {}
    interface ElementChildrenAttribute extends React.JSX.ElementChildrenAttribute {}
    type LibraryManagedAttributes<C, P> = React.JSX.LibraryManagedAttributes<C, P>;
    interface IntrinsicAttributes extends React.JSX.IntrinsicAttributes {}
    interface IntrinsicClassAttributes<T> extends React.JSX.IntrinsicClassAttributes<T> {}
    interface IntrinsicElements extends React.JSX.IntrinsicElements {}
}

/**
 * Create a React element.
 *
 * You should not use this function directly. Use JSX and a transpiler instead.
 */
export function jsx(
    type: React.ElementType,
    props: unknown,
    key?: React.Key,
): React.ReactElement;

/**
 * Create a React element.
 *
 * You should not use this function directly. Use JSX and a transpiler instead.
 */
export function jsxs(
    type: React.ElementType,
    props: unknown,
    key?: React.Key,
): React.ReactElement;
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    "allowJs": true,
    "checkJs": false,
    
    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "./",
    "paths": {
      "src/*": ["src/*"]
    },

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"],
  "exclude": [ // this excludes files from being build
    "src/**/api",                    // exclude any api folder
    "src/**/sync/*_server.ts",       // only exclude server_*.ts files inside sync folders
    "src/**/sync/*_server.tsx",      // (optional) if you use TSX files too
    "src/**/sync/*_server.js",       // (optional) in case you have JS mixed in
    "src/**/sync/*_server.jsx",       // (optional) same for JSX
  ]

}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    "allowJs": true,
    "checkJs": false,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="tsconfig.server.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "lib": ["ES2022"],
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "rewriteRelativeImportExtensions": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "dist/server",
    "resolveJsonModule": true,
    "types": ["node"],
    "sourceMap": true
  },
  "include": ["server/**/*"]
}
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model user {
  id        String   @id @map("_id") @default(uuid())
  email     String
  name      String
  password  String?
  admin     Boolean @default(false)
  avatar    String @default("")
  language  String @default("en")
  theme     THEME @default(dark)
  provider  PROVIDERS
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

enum THEME {
  dark
  light
}

enum PROVIDERS {
  credentials
  google
  github
  x
  facebook
  linkedIn
  apple
  discord
  instagram
}

// Command:               Purpose
/*
npx prisma format:	      Auto-format your schema.prisma file (fixes spacing, indentation, style)
npx prisma validate:	    Validate that your schema.prisma is correct (syntax & relational rules)
npx prisma generate:	    Generate the Prisma Client (after changing schema or installing Prisma)
npx prisma db pull:	      Pull the current database structure into your Prisma schema (reverse-engineer an existing database)
npx prisma db push:	      Push your Prisma schema to the database — creates tables based on schema (development only, no migrations)
npx prisma migrate dev:	  Create a new migration based on schema changes and apply it to the database
npx prisma migrate reset:	Reset the database: drops all tables, re-applies migrations, and runs seed scripts if any
npx prisma studio:      	Open Prisma Studio (a GUI to view and edit database records easily)
*/
</file>

<file path="PROJECT_CONTEXT.md">
<!-- 
  to toggle markdown file press  
  1. ctrl + k
  2. v
-->


# UI-Builder Project Context

> **Human-readable documentation for AI assistants to understand this project.**  
> Last updated: 2025-01-11

---

## Project Overview

**UI-Builder** (internally called "LuckyStack") is a **creative platform** for:
- **Visual UI development** - Upload `.tsx/.jsx` files, compile with Babel, and render live in viewports
- **Idea organization** - Notes, drawings, and file management on an infinite 2D canvas
- **Future: Real-time collaboration** - Room-based sync infrastructure is built-in

The project is split into two logical parts:
1. **Framework** - Custom full-stack framework with authentication, sockets, and API routing
2. **Application (Sandbox)** - The main canvas-based workspace where users create

---

# Part 1: Framework Summary

The framework is a **custom-built React + Node.js stack** inspired by Next.js but with socket-first architecture.

## Root Configuration Files

| File | Purpose |
|------|---------|
| `config.ts` | Main app configuration (URLs, defaults, session layout). Gitignored - use `configTemplate.txt` |
| `envTemplate.txt` | Template for `.env` file with database, OAuth, and server secrets |
| `vite.config.ts` | Vite bundler config with path aliases (`src/`, `config`) and exclusions for server files |
| `index.html` | Entry point with two root divs: `#root` (app) and `#portalRoot` (modals/overlays z-999999999) |
| `redis.conf` | Redis configuration for session storage |
| `prisma/schema.prisma` | MongoDB database schema - currently only `user` model with OAuth providers |

## Server Architecture (`/server`)

The backend is **raw Node.js** (no Express) with a custom HTTP router and Socket.io.

### `server/server.ts` - Main Entry Point
- Creates HTTP server with CORS, security headers (Referrer-Policy, X-Frame-Options, X-XSS-Protection)
- HTTP route handling by path prefix:
  - `/auth/api/{provider}` → Redirects to OAuth provider or handles credentials login
  - `/auth/callback/{provider}` → Handles OAuth callback from providers
  - `/uploads/*` → Serves uploaded files (avatars, etc.)
  - `/assets/*` → Serves static assets
  - Everything else → Falls back to `index.html` for SPA routing
- In development mode: initializes hot-reload watchers and REPL console
- Initializes Socket.io via `loadSocket()`

### `server/auth/` - Authentication System

| File | Purpose |
|------|---------|
| `login.ts` | Handles credentials login/register and OAuth callback processing |
| `loginConfig.ts` | Defines 5 OAuth provider configs (credentials, Google, GitHub, Discord, Facebook) |
| `checkOrigin.ts` | Validates request origins against allowed domains (DNS, localhost, external origins) |

**Supported Providers:** credentials, Google, GitHub, Facebook, Discord

**Login Flow:**
1. Credentials: Validates email/password, hashes with bcrypt, creates/authenticates user
2. OAuth: Redirects to provider → callback exchanges code for token → fetches user info → creates/finds user
3. On successful login, generates random token and saves session to Redis

### `server/sockets/socket.ts` - Socket.io Server
Handles all real-time communication:
- **`apiRequest`** - RPC-style API calls from client (routed via `handleApiRequest.ts`)
- **`sync`** - Room-based sync events between clients (routed via `handleSyncRequest.ts`)
- **`joinRoom`** - Adds socket to a room (room code stored in session)
- **`updateLocation`** - Tracks user's current page path
- **`disconnect`** - Handles socket disconnection with optional activity broadcasting

### `server/sockets/handleApiRequest.ts` - API Request Handler
- Special handlers for `session` (returns user session) and `logout` (logs out user)
- Validates `auth` requirements before executing API functions
- **Auth Validation System** supports flexible conditions:
  - `login: true` - Requires user to be logged in
  - `additional: [{key, type?, value?, nullish?, mustBeFalsy?}]` - Custom field checks

### `server/sockets/handleSyncRequest.ts` - Sync Request Handler
- Validates server-side sync file before broadcasting
- Loops through all sockets in the room and runs client-side sync for each
- Supports `ignoreSelf` to exclude sender from receiving the event

### `server/functions/` - Server Utilities
| File | Purpose |
|------|---------|
| `session.ts` | Session CRUD in Redis + **auto-kicks previous sessions on login** |
| `redis.ts` | Redis client wrapper (ioredis) |
| `db.ts` | Prisma client export for MongoDB |
| `tryCatch.ts` | Error-safe async function wrapper |
| `sleep.ts` | Promise-based delay |
| `broadcaster.ts` | Utility for broadcasting to socket rooms |
| `game.ts` | Game-related utilities (for multiplayer games) |

### Session Kicking Feature (`session.ts`)
When a user logs in, the system automatically kicks all previous sessions for that user:
1. Looks up all active tokens for the user ID in Redis
2. For each existing session: emits `logout` event to connected sockets, deletes session data
3. Registers new token in the active users set
4. Broadcasts `updateSession` to all sockets with the new token

### `server/dev/` - Development Utilities
| File | Purpose |
|------|---------|
| `loader.ts` | Hot-reloads `_api` and `_sync` files without server restart |
| `hotReload.ts` | File watcher that triggers reloads on changes |

### `server/sockets/utils/` - Socket Utilities
| File | Purpose |
|------|---------|
| `logout.ts` | Handles logout: clears timers, leaves rooms, deletes session |
| `activityBroadcaster.ts` | Tracks user activity (AFK detection, reconnection) |

### Build Scripts (`/scripts`)
| Script | Purpose |
|--------|---------|
| `generateServerRequests.ts` | Scans `src/` for `_api/` and `_sync/` folders, generates route map |
| `bundleServer.ts` | Bundles server for production |
| `clearServerRequests.ts` | Clears generated route map for dev restart |

---

## Client Architecture (`/src`)

### Entry Point: `main.tsx`
- File-based routing similar to Next.js
- Scans for `page.tsx` in any non-underscore folder
- Wraps app in providers: `SocketStatus` → `Session` → `Translation` → `Avatar` → `MenuHandler` → `Router`

### Provider Hierarchy (Framework-level)
```
SocketStatusProvider   # Socket connection status
└── SessionProvider    # User session from Redis
    └── TranslationProvider  # i18n with JSON locale files
        └── AvatarProvider   # User avatar caching
            └── MenuHandlerProvider  # Global menu state
                └── RouterProvider   # React Router
```

### `src/_sockets/` - Client-Server Communication

These are the core functions for communicating with the backend:

#### `apiRequest({ name, data })` → Promise
- Sends RPC-style request over socket
- Auto-prefixes with current path: `api/{path}/{name}`
- Has abort controllers for duplicate GET-like requests

#### `syncRequest({ name, data, receiver, ignoreSelf })` → Promise  
- Sends real-time events to other clients in same room
- `receiver` is the room code (e.g., "abc123")
- `ignoreSelf` prevents the sender from receiving the event

#### `joinRoom(code)` → Promise
- Joins a socket room for sync events
- Room code stored in user session

### `src/_components/` - Reusable UI Components

| Component | Purpose |
|-----------|---------|
| `TemplateProvider.tsx` | Wraps pages in templates: `plain`, `main`, `sandbox` |
| `SessionProvider.tsx` | Provides session context and socket initialization |
| `Middleware.tsx` | Route authentication guards |
| `LoginForm.tsx` | OAuth login buttons |
| `MenuHandler.tsx` | Global menu/modal management |
| `Navbar.tsx` | Top navigation bar |
| `Tooltip.tsx` | Hover tooltips |
| `Dropdown.tsx` | Dropdown menus |
| `ConfirmMenu.tsx` | Confirmation dialogs |
| `TranslationProvider.tsx` | i18n with `src/_locales/{lang}.json` |

### Templates (`TemplateProvider.tsx`)

Pages export a `template` constant to specify their wrapper:

1. **`plain`** - Minimal wrapper, no UI chrome
2. **`main`** - Navbar with user info and navigation
3. **`sandbox`** - Full sandbox with all feature providers:
   ```
   GridProvider → BlueprintsProvider → BuilderPanelProvider → 
   MenusProvider → CodeProvider → DrawingProvider → NotesProvider → MainTemplate
   ```

### Page Routes

| Route | Template | Purpose |
|-------|----------|---------|
| `/` | plain | Root redirect based on session |
| `/login` | plain | OAuth login page |
| `/register` | plain | Registration (uses LoginForm) |
| `/home` | main | Sandbox selection (in progress) |
| `/settings` | main | User settings with `_api` folder |
| `/test` | main | Development testing with `_api` and `_sync` examples |
| `/sandbox` | sandbox | Main application canvas |

### API/Sync Convention

**API Routes** (server-only functions):
- Place files in `src/{page}/_api/{name}.ts`
- Export `main` function and optional `auth` guard
- Call from client: `apiRequest({ name: '{name}' })`

**Sync Routes** (real-time client-server events):
- `src/{page}/_sync/{name}_server.ts` - Runs on server for validation
- `src/{page}/_sync/{name}_client.ts` - Runs on receiving clients
- Call from client: `syncRequest({ name: '{name}', receiver: 'room-code' })`

---

## Styling

- **TailwindCSS v4** with custom colors in `src/index.css`
- Theme support: light (default) and dark mode via CSS classes
- Custom CSS variables for colors (`--color-background`, `--color-primary`, etc.)
- `src/NoteEditor.css` - ProseMirror/TipTap styles for notes
- `src/scrollbar-*.css` - Theme-specific scrollbar styles (not yet dynamically loaded)

---

# Part 2: Application Summary (Sandbox)

The sandbox is the **main application** - an infinite 2D canvas where users place and interact with various components.

## Sandbox Page (`src/sandbox/page.tsx`)

Split-panel layout:
- **Left Panel** - The infinite grid canvas
- **Right Panel** - Code editor (Monaco) for selected file
- **Divider** - Draggable to resize panels

## Sandbox Providers

Located in `src/sandbox/_providers/`:

| Provider | Purpose |
|----------|---------|
| `GridContextProvider` | Zoom, pan offset, dragging state, container ref |
| `BlueprintsContextProvider` | Central state for all grid items (files, notes, drawings) |
| `CodeContextProvider` | Currently selected code file and editor state |
| `DrawingContextProvider` | Drawing tool state (color, size, mode, strokes) |
| `NotesContextProvider` | Note editor state and selection |
| `MenusContextProvider` | Open/close state for sandbox menus |
| `BuilderPanelContextProvider` | Right panel visibility and divider position |

## Grid System (`src/sandbox/_components/grid/`)

### `Grid.tsx` - The Infinite Canvas
- Renders dot/line grid background that pans and zooms
- Contains all blueprint items (files, notes, drawings)
- Mouse handlers for pan, zoom, drag-drop
- Renders menus as overlays

**Grid Features:**
- Infinite panning with offset tracking
- Zoom with mousewheel (shows percentage indicator)
- Drag-and-drop file uploads
- Right-click context menu disabled

### `ScreenRenderer.tsx`
- Renders Babel-compiled React components in viewports

### `ErrorBoundary.tsx`
- Catches rendering errors in child components

## Files System (`src/sandbox/_components/files/`)

### File Types
Any JavaScript-like file can be compiled with Babel:
- **`.tsx/.ts/.jsx/.js`** - Can be compiled with Babel and rendered live in viewports
- **Other files** - Displayed as file cards with preview

### View Modes
- **`code`** - Shows as a file card, opens in Monaco editor
- **`rendered`** - Compiles with Babel and displays in viewport frame

### `File.tsx`
- File card component on grid
- Click to select and open in editor
- Drag to move on grid

### `Render.tsx`  
- Renders compiled React component in a viewport frame
- Viewport sizes: Phone, Tablet, Laptop, Desktop, Large Desktop

## Code Editor (`src/sandbox/_components/editor/`)

### `Editor.tsx` - Main Editor Panel
- Renders in right panel when open
- Contains Monaco editor for the selected file

### `BaseCodeEditor.tsx` / `CodeEditor.tsx`
- Monaco editor wrapper with syntax highlighting
- Auto-detects language from file extension

### `CodeMirrorEditor.tsx`
- CodeMirror 6 editor for code blocks in notes
- Language-aware syntax highlighting

## Notes System (`src/sandbox/_components/notes/`)

### `Note.tsx`
- Note container on the grid
- Draggable and resizable
- Contains TipTap rich-text editor

### `NoteEditor.tsx`
- TipTap-based rich-text editor
- Supports: headings, lists, bold, italic, code blocks, task lists
- Uses `src/NoteEditor.css` for styling

### `CodeBlockComponent.tsx`
- Custom TipTap node for code blocks
- Embeds CodeMirror editor with language selection

### Note Options Menu
- Opened with `/` command in editor
- Options: headings, lists, code blocks, dividers, etc.

## Drawing System (`src/sandbox/_components/drawing/`)

### `DrawingLayer.tsx`
- SVG-based freehand drawing overlay
- Renders above grid items
- Uses `perfect-freehand` for smooth strokes

### Drawing Features
- Pen with variable stroke width
- Shapes: line, rectangle, circle, diamond
- Eraser with partial and complete erase modes
- Color picker
- Line styles: solid, dashed, dotted

### `DrawingSideMenu.tsx` / `DrawingTopMenu.tsx`
- Drawing tool selection and options
- Color, size, style controls

## Menus (`src/sandbox/_components/menus/`)

### `BottomLeftMenu.tsx`
- Quick access buttons (toggle drawing, etc.)

### `CreateComponentMenu.tsx`
- Right-click context menu
- Options to create files, notes, etc.

### `NoteOptionsMenu.tsx`
- Slash command menu in notes
- Insert headings, code blocks, lists, etc.

## Functions (`src/sandbox/_functions/`)

Organized by feature:

### `codeEditor/` - 23 files
- Babel compilation utilities
- Monaco editor configuration
- Language detection

### `drawing/` - 12 files
- Stroke point generation
- Shape algorithms
- Eraser logic

### `grid/` - 6 files
- `onMouseDown.ts` - Pan start, item selection
- `onMouseUp.ts` - Pan end, drop handling
- `onMouseMove.ts` - Pan motion, item dragging
- `onMouseWheel.ts` - Zoom handling
- `onFileDrop.ts` - File drag-and-drop upload

### `files/` - 2 files
- `babelUtils.ts` - File type detection, Babel compatibility
- `fileUtils.ts` - File reading, extension detection, MIME type handling

**File Upload Handling:**
When files are dropped onto the grid or uploaded via the context menu:
- **Text-based files** (code files like `.tsx`, `.ts`, `.jsx`, `.js`, `.json`, `.css`, `.html`, `.md`, etc.) are stored as **plain text content**
- **Binary files** (images, PDFs, ZIPs, etc.) are stored as **base64 encoded content**

The file type detection uses **extension-based priority**:
1. First checks if `getMonacoLanguage(extension)` returns a known language (not `'plaintext'`)
2. Falls back to browser MIME type via `getMimeTypeCategory(file.type)`
3. Code file extensions take priority - this handles cases where browsers don't provide proper MIME types for `.tsx`, `.ts`, etc.

**Key functions in `fileUtils.ts`:**
| Function | Purpose |
|----------|---------|
| `getFileExtension(fileName)` | Extracts lowercase extension from filename |
| `getMimeTypeCategory(mimeType)` | Categorizes MIME type: text, image, pdf, video, audio, binary |
| `getMonacoLanguage(extension)` | Maps file extension to Monaco editor language |
| `readFileAsText(file)` | Reads file as plain text string |
| `readFileAsBase64(file)` | Reads file as base64 string (without data URL prefix) |
| `getFileIcon(extension, mimeType)` | Returns FontAwesome icon for file type |
| `formatFileSize(bytes)` | Formats bytes as human-readable size |

### `notes/` - 3 files
- Note manipulation utilities

## Types (`src/sandbox/types/`)

| File | Purpose |
|------|---------|
| `blueprints.ts` | Shape definitions for files, notes, drawings |
| `gridProps.ts` | Grid-related type definitions |
| `viewportMapping.ts` | Viewport size presets |
| `NotesOptionsTypes.ts` | Note slash command options |
| `react*.d.ts` | React type augmentations for sandbox scope |

---

# Future Plans

Based on `ideas.md` and conversation history:

1. **Real-time collaboration** - Infrastructure exists (rooms, sync), needs UI implementation
2. **AI integration** - AI window that can interact with app functions
3. **Diagram builders** - Use case, flowchart, class, ERD diagrams
4. **User story tables** - Structured story format
5. **Requirements reports** - Checklist-based requirement validation
6. **File sync to profile** - Files saved across sandboxes
7. **Builder mode** - WordPress-like drag-drop UI editing
8. **Cross-file imports** - Import existing grid files into other files (e.g., import Dropdown component into another component). Saved files from user's profile would be added to grid for collaborator access.

> **Future Enhancement Ideas:**
> - Visual component tree for builder mode
> - Shared component library across sandboxes
> - Version history for files and notes
> - Export diagrams to PNG/SVG/PDF

---

# Quick Start for AI Assistants

## Understanding the codebase

1. **Root files** configure build, TypeScript, and Tailwind
2. **`/server`** is the custom Node.js backend with Socket.io
3. **`/src`** is the React frontend with file-based routing
4. **`/src/sandbox`** is the main application (canvas workspace)

## Common patterns

- **API calls**: `apiRequest({ name: 'functionName', data: {} })`
- **Real-time sync**: `syncRequest({ name: 'eventName', data: {}, receiver: 'roomCode' })`
- **State management**: Context providers, no Redux
- **Styling**: TailwindCSS with custom CSS variables

## Key provider access

```tsx
// Framework
const { session } = useSession();
const { t } = useTranslation();

// Sandbox
const { zoom, offset, containerRef } = useGrid();
const { blueprints, setBlueprints } = useBlueprints();
const { drawingState, setDrawingState } = useDrawing();
const { selectedFile, setSelectedFile } = useCode();
```

---

# File Tree Reference

```
UI-builder/
├── server/                   # Backend
│   ├── server.ts             # HTTP server entry
│   ├── sockets/              # Socket.io handlers
│   ├── auth/                 # OAuth providers
│   ├── functions/            # Server utilities
│   └── ...
├── src/                      # Frontend
│   ├── main.tsx              # App entry with routing
│   ├── page.tsx              # Root redirect
│   ├── index.css             # Global styles + Tailwind
│   ├── _components/          # Framework components
│   ├── _providers/           # Framework providers
│   ├── _sockets/             # Client-server communication
│   ├── _locales/             # i18n JSON files
│   ├── login/                # Login page
│   ├── home/                 # Home page
│   ├── settings/             # Settings with _api
│   ├── test/                 # Dev testing with _api, _sync
│   └── sandbox/              # Main application
│       ├── page.tsx          # Sandbox entry
│       ├── _providers/       # Sandbox state providers
│       ├── _components/      # Sandbox UI components
│       │   ├── grid/         # Canvas grid
│       │   ├── editor/       # Monaco code editor
│       │   ├── drawing/      # Freehand drawing
│       │   ├── notes/        # TipTap notes
│       │   ├── files/        # File cards
│       │   └── menus/        # Context menus
│       ├── _functions/       # Sandbox logic
│       └── types/            # TypeScript definitions
├── prisma/                   # Database schema
├── scripts/                  # Build scripts
└── config files...           # Vite, TypeScript, Tailwind
```

---

# Detailed Documentation

This section provides in-depth documentation for specific subsystems.

---

## Framework Components (`src/_components/`)

### MenuHandler.tsx - Global Modal System
A stack-based modal/menu system with slide animations.

**Key Features:**
- **Stack-based:** Modals stack on top of each other
- **Promise-based:** `open()` returns a Promise that resolves when closed
- **Slide animations:** Modals slide in from right, slide left when covered by another modal
- **Escape key:** Closes top modal
- **Background click:** Closes all modals

**API:**
```tsx
const { open, replace, close, closeAll } = useMenuHandler();

// Open a modal (returns Promise)
const result = await open(<MyModal />, { 
  dimBackground: true,  // Darken background
  background: 'bg-white',  // CSS class
  size: 'sm' | 'md' | 'lg'  // Width preset
});

// Replace current modal with new one
await replace(<NewModal />);

// Close top modal
close();

// Close entire stack
closeAll();
```

### Middleware.tsx - Route Guards
Wraps page content and validates access before rendering.

**Flow:**
1. Waits for session to load (max 5 seconds)
2. Calls `middlewareHandler()` with path, params, session
3. If `success: true` → renders children
4. If `redirect: '/path'` → navigates to path
5. If neither → navigates back

### middlewareHandler.ts - Route Access Rules
Switch statement defining per-route access rules.

```tsx
// Example rule structure
case '/admin':
  if (session?.admin) return { success: true };
  return { redirect: '/login' };
```

**Default:** All undefined routes are allowed.

### TranslationProvider.tsx - i18n System
Multi-language support with 4 languages: nl, en, de, fr.

**Features:**
- Reads language from user session
- Falls back to config.defaultLanguage
- Dynamic key lookup with dot notation
- Parameter replacement with `{{param}}`

**API:**
```tsx
const translations = useTranslation();
const setLanguage = useUpdateLanguage();

// Access translation
translations.login.title  // "Sign In"

// Dynamic translation with params
translate({ 
  translationList: translations,
  key: 'login.welcome',
  params: [{ key: 'name', value: 'John' }]
}); // "Welcome, John!"
```

---

## Framework Functions (`src/_functions/`)

| Function | Purpose |
|----------|---------|
| `notify.ts` | Toast notifications with i18n support (success, error, info, warning) |
| `confetti.ts` | Trigger confetti animation |
| `sleep.ts` | Promise-based delay utility |
| `tryCatch.ts` | Error-safe async function wrapper |
| `menuHandler.ts` | Menu state utilities |
| `middlewareHandler.ts` | Route access control logic |
| `translator.ts` | Get current language translations |
| `icon.ts` | Icon utilities |

---

## Sandbox Providers (`src/sandbox/_providers/`)

### BlueprintsContextProvider - Central Data Store
Stores all grid items: files, notes, drawings.

```tsx
type blueprints = {
  files: file[];      // Code files with positions
  notes: note[];      // Rich-text notes with positions
  drawings: drawing[]; // Freehand drawings
};

// Also supports "instances" - copies of blueprints
instances: blueprints[];  // For future component instancing
```

**Change-Based History (Undo/Redo):**
Uses operation-based history (not snapshots) to support future multiplayer sync.

| State | Type | Purpose |
|-------|------|---------|
| `localChanges` | GridChange[] | Stack of user's own operations |
| `changeIndex` | number | Current position in history (-1 = no changes) |
| `localBlueprints` | blueprints | Items created by this user |
| `remoteBlueprints` | blueprints | Items from other coop users (future) |
| `blueprints` | blueprints | Merged view (local + remote) for rendering |

**GridChange Type:**
```typescript
type GridChange = 
  | { type: 'create'; itemType: 'file' | 'note'; item: file | note }
  | { type: 'delete'; itemType: 'file' | 'note'; item: file | note };
// Future: | { type: 'move'; id: string; from: Position; to: Position }
```

**Actions:**
- `applyChange(change)`: Apply a create/delete operation (adds to history)
- `undoChange()`: Undo last change (async - may trigger ownership transfer)
- `redoChange()`: Redo next change
- `canUndo` / `canRedo`: Boolean helpers for UI

**Sync Event Hooks (for future coop):**
```typescript
setSyncCallbacks({
  // Called before undo-delete - return false to block and transfer ownership
  onBeforeDelete: (change) => {
    const isBeingEdited = checkIfOtherUserEditing(change.item.id);
    if (isBeingEdited) {
      // Move item to remoteBlueprints, notify other user they now own it
      return false; // Block the delete
    }
    return true;
  },
  
  // Called after any change - emit to sockets
  onChangeApplied: (change, direction) => {
    socket.emit('gridChange', { change, direction, userId: myId });
  },
  
  // Called when ownership transfers to another user
  onOwnershipTransfer: (itemId, newOwnerId) => {
    socket.emit('ownershipTransfer', { itemId, newOwnerId });
  }
});
```

**Ownership Transfer Pattern:**
When user A deletes a file but user B is editing it:
1. `onBeforeDelete` returns `false`
2. Item moves from `localBlueprints` to `remoteBlueprints`
3. Item removed from user A's history
4. Notification sent to user B who now owns it

**Keyboard Shortcuts:**
- Ctrl+Z: Undo (only when Monaco/TipTap/CodeMirror/Drawing not focused)
- Ctrl+Y: Redo

**UI:** Undo/Redo buttons in BottomLeftMenu.tsx


### GridContextProvider - Canvas State
Manages zoom, pan, and interaction refs.

| State | Type | Purpose |
|-------|------|---------|
| `zoom` | number | Current zoom level (0.1 - 10) |
| `offset` | {x, y} | Pan offset in pixels |
| `dragging` | boolean | Is user panning the grid |
| `containerRef` | Ref | Reference to grid container |
| `zoomRef` | Ref | Synced for event handlers |

### DrawingContextProvider - Drawing State
Extensive state for the drawing system.

**Core State:**
- `strokes: StrokeData[]` - All completed strokes
- `currentPoints: DrawingPoint[]` - Currently drawing points
- `brushSize/brushColor` - Tool settings
- `lineStyle` - solid, dashed, dotted

**Modes:**
- `drawingEnabled` - Drawing mode active
- `erasing` - DISABLED, PARTIAL, or FULL erase mode
- `activeShape` - Current shape tool (square, circle, diamond, line, arrow)
- `selectionMode` - Selection tool active
- `fillMode` - Fill shapes with color
- `textMode` - Text tool (planned)

**Selection:**
- `selectedStrokeIds: string[]` - Currently selected strokes
- `marqueeMode/marqueeBox` - Marquee selection

**History:**
- `strokeHistory: StrokeData[][]` - Undo/redo stack
- `historyIndex: number` - Current position in history

### CodeContextProvider - Editor State
Manages Monaco editor instances.

| State | Purpose |
|-------|---------|
| `codeWindows` | All open code contexts |
| `activeCodeWindow` | Currently focused file ID |
| `codeWindowSize` | Font size (6-100) |
| `currentMonacoInstance` | Monaco module reference |
| `currentEditorInstance` | Active editor instance |

### NotesContextProvider - Note Editor State
Manages TipTap editor and slash menu.

| State | Purpose |
|-------|---------|
| `noteOptionsMenuOpen` | Slash menu visibility state |
| `noteOptionsMenuPosition` | Menu position (auto-clamped to viewport) |
| `lastActiveEditor` | TipTap editor + cursor position for focus restore |
| `wasNoteRecentlyActive` | Prevents unwanted focus loss |

---

## Drawing System Details

### Drawing Functions (`src/sandbox/_functions/drawing/`)

| File | Purpose |
|------|---------|
| `useDrawingEvents.ts` | Main drawing event handlers (33KB - core logic) |
| `generateShapePoints.ts` | Generates points for square, circle, diamond, line, arrow |
| `eraseStroke.ts` | Partial and full erase logic |
| `selectionUtils.ts` | Selection bounds calculation, hit testing |
| `snappingUtils.ts` | Alignment snapping (12KB - Figma-like behavior) |
| `clipUtils.ts` | Polygon clipping for partial erase |
| `exportUtils.ts` | Export drawings to PNG/SVG |
| `getSvgPathFromStroke.ts` | Convert stroke points to SVG path |
| `clientToWorld.ts` | Screen coordinates to world coordinates |
| `RenderDrawingPath.tsx` | React component to render stroke SVG |

### Stroke Data Structure
```tsx
type StrokeData = {
  id: string;
  points: DrawingPoint[];  // Array of {x, y, color, size}
  fill?: string;           // Fill color for shapes
  lineStyle?: 'solid' | 'dashed' | 'dotted';
};
```

### Erase Modes
- **PARTIAL:** Erases portions of strokes where brush touches (clips polygons)
- **FULL:** Removes entire stroke if any part is touched

---

## Code Editor System Details

### Code Editor Functions (`src/sandbox/_functions/codeEditor/`)

| Directory/File | Purpose |
|---------------|---------|
| `babel/` | Babel compilation for live preview |
| `autocompletions/` | Custom autocomplete providers |
| `tailwindcss/` | TailwindCSS autocomplete integration |
| `themes/` | Monaco editor color themes |
| `compilerOptions.ts` | TypeScript compiler configuration |
| `hoverTooltip.ts` | Custom hover tooltip logic |
| `traverseClickedComponent.ts` | Click-to-navigate for rendered components |

### Babel Compilation Flow
1. User edits `.tsx/.jsx` file in Monaco
2. Code is compiled with `@babel/standalone`
3. React component is extracted
4. Rendered in viewport iframe with selected dimensions
5. Errors are caught and displayed in error boundary

### Viewport Sizes
```tsx
Viewports = {
  PHONE: { width: 375, height: 667 },
  TABLET: { width: 768, height: 1024 },
  LAPTOP: { width: 1366, height: 768 },
  DESKTOP: { width: 1920, height: 1080 },
  LARGE_DESKTOP: { width: 2560, height: 1440 }
}
```

---

## Notes System Details

### TipTap Extensions Used
- **StarterKit** - Basic formatting (bold, italic, headings, lists)
- **TaskList/TaskItem** - Checkbox task lists
- **Placeholder** - "Type / for commands" placeholder
- **CodeBlock (custom)** - Replaced with CodeMirror integration

### Slash Command Menu Options
Triggered by typing `/` in note editor:
- Heading 1, 2, 3
- Bullet List, Numbered List
- Task List (checkboxes)
- Code Block (opens CodeMirror)
- Divider
- Blockquote

### CodeBlock Integration
- Custom TipTap node wrapping CodeMirror 6
- Language selection dropdown
- Syntax highlighting per language
- Keyboard navigation refined (Escape to exit, Enter to focus)

---

# Code Examples & Patterns

This section provides real code examples from the codebase demonstrating common patterns.

---

## Creating an API Route

**File:** `src/{page}/_api/myApi.ts`

```typescript
import { AuthProps, SessionLayout } from 'config';
import { PrismaClient } from '@prisma/client';

// Define available server functions
interface Functions {
  prisma: PrismaClient;
  saveSession: (token: string, data: any) => Promise<boolean>;
  getSession: (token: string) => Promise<any | null>;
  deleteSession: (token: string) => Promise<boolean>;
  tryCatch: <T, P>(func: (values: P) => Promise<T> | T, params?: P) => Promise<[any, T | null]>;
  [key: string]: any;
}

interface ApiParams {
  data: Record<string, any>;  // Data sent from client
  functions: Functions;        // Server utilities
  user: SessionLayout;         // Current user session
}

// Auth guard - checks run before main()
export const auth: AuthProps = {
  login: true,  // Requires logged-in user
  additional: [
    // { key: 'admin', value: true },        // Must be admin
    // { key: 'email', type: 'string' },     // Email must be string
    // { key: 'groupId', mustBeFalsy: false }, // groupId must be truthy
    // { key: 'updatedAt', nullish: false }  // Must not be null/undefined
  ]
};

// Main API handler
export const main = async ({ data, functions, user }: ApiParams) => {
  const { prisma, tryCatch } = functions;
  
  // Example: fetch user's data
  const [error, result] = await tryCatch(async () => {
    return await prisma.user.findUnique({
      where: { id: user.id }
    });
  });
  
  if (error) {
    return { status: 'error', message: 'Database error' };
  }
  
  return { 
    status: 'success', 
    result: { userData: result } 
  };
};
```

**Calling from client:**
```tsx
import { apiRequest } from 'src/_sockets/apiRequest';

const response = await apiRequest({ 
  name: 'myApi',  // Matches filename without .ts
  data: { 
    someParam: 'value' 
  } 
});

console.log(response);  // { userData: {...} }
```

---

## Creating a Sync Event (Real-time)

Sync events require two files: `_server.ts` (validation) and `_client.ts` (per-user filtering).

### Server File: `src/{page}/_sync/updateData_server.ts`

```typescript
import { AuthProps, ServerSyncProps } from "config";

export const auth: AuthProps = {
  login: true,
  additional: []
};

// Runs ONCE when sync is called
// Can update database, validate data, etc.
export const main = async ({ clientData, user, functions }: ServerSyncProps) => {
  console.log('User triggered sync:', user.name);
  console.log('Client data:', clientData);
  
  // Example: update counter in Redis
  await functions.saveSession(`counter:${clientData.roomCode}`, {
    value: clientData.newValue
  });
  
  // Return data to be sent to all clients
  return {
    status: 'success',
    newValue: clientData.newValue,
    updatedBy: user.name
  };
};
```

### Client File: `src/{page}/_sync/updateData_client.ts`

```typescript
import { ClientSyncProps } from "config";

// Runs for EACH socket in the room
// Return status: 'success' to allow, or nothing/error to block
export const main = ({ user, serverData }: ClientSyncProps) => {
  // Example: only send to users on this specific page
  if (user?.location?.pathName !== '/sandbox') {
    return; // User won't receive the event
  }
  
  // Example: only send to non-admin users
  if (user?.admin) {
    return; // Admins won't receive
  }
  
  return {
    status: 'success',
    // Can add additional client-specific data
  };
};
```

### Triggering from Client:

```tsx
import { syncRequest, useSyncEvents } from 'src/_sockets/syncRequest';
import { joinRoom } from 'src/_sockets/socketInitializer';
import { useEffect } from 'react';

export default function MyPage() {
  // 1. Join a room on mount
  useEffect(() => {
    joinRoom('my-room-123');
  }, []);
  
  // 2. Register callback for receiving sync events
  const { upsertSyncEventCallback } = useSyncEvents();
  
  upsertSyncEventCallback('updateData', ({ serverData, clientData }) => {
    console.log('Received sync!', serverData);
    // Update UI with new data
    document.getElementById('counter')!.innerText = serverData.newValue;
  });
  
  // 3. Trigger sync to all users in room
  const handleClick = async () => {
    await syncRequest({
      name: 'updateData',
      data: { newValue: 42 },
      receiver: 'my-room-123',  // Room code
      ignoreSelf: false          // Set true to not receive your own event
    });
  };
  
  return <button onClick={handleClick}>Update All Clients</button>;
}
```

---

## Using the Notification System

```tsx
import notify from 'src/_functions/notify';

// Simple notifications (keys from _locales/*.json)
notify.success({ key: 'login.success' });
notify.error({ key: 'login.failed' });
notify.info({ key: 'common.loading' });
notify.warning({ key: 'common.unsavedChanges' });

// With parameters ({{param}} in translation string)
notify.success({ 
  key: 'welcome.greeting',  // "Welcome, {{name}}!"
  params: [
    { key: 'name', value: 'John' }
  ]
});
```

**Translation file example (`src/_locales/en.json`):**
```json
{
  "login": {
    "success": "Successfully logged in!",
    "failed": "Login failed. Please try again."
  },
  "welcome": {
    "greeting": "Welcome, {{name}}!"
  }
}
```

---

## Using the Modal System

### Basic Modal:
```tsx
import { useMenuHandler } from 'src/_components/MenuHandler';

function MyComponent() {
  const { open, close, closeAll } = useMenuHandler();
  
  const handleOpenModal = async () => {
    // open() returns a Promise that resolves when closed
    const result = await open(
      <div className="p-4 bg-white">
        <h2>My Modal</h2>
        <p>Modal content here</p>
        <button onClick={close}>Close</button>
      </div>,
      { 
        dimBackground: true,   // Dark overlay
        background: 'bg-white', // Modal background class
        size: 'md'              // 'sm' | 'md' | 'lg'
      }
    );
    
    console.log('Modal closed with:', result);
  };
  
  return <button onClick={handleOpenModal}>Open Modal</button>;
}
```

### Nested Modals (Stack):
```tsx
const { open, close } = useMenuHandler();

// First modal
open(
  <div className="p-4">
    <h2>First Modal</h2>
    <button onClick={() => {
      // Second modal slides in, first slides left
      open(
        <div className="p-4">
          <h2>Second Modal</h2>
          <button onClick={close}>Close (returns to first)</button>
        </div>,
        { background: 'bg-blue-100' }
      );
    }}>
      Open Nested
    </button>
  </div>,
  { background: 'bg-white' }
);
```

### Confirm Dialog:
```tsx
import { confirmDialog } from 'src/_components/ConfirmMenu';

const handleDelete = async () => {
  const confirmed = await confirmDialog({
    title: 'Delete Item',
    content: 'Are you sure you want to delete this item?',
    input: 'DELETE'  // Optional: require typing to confirm
  });
  
  if (confirmed) {
    // User confirmed
    await deleteItem();
  }
};
```

---

## Middleware Route Protection

**File:** `src/_functions/middlewareHandler.ts`

```typescript
import { SessionLayout } from "config";

export default function middlewareHandler({ 
  location, 
  searchParams, 
  session 
}: { 
  location: string, 
  searchParams: Record<string, any>, 
  session: SessionLayout | null 
}) {
  
  switch (location) {
    // Protected route - requires login
    case '/dashboard':
      if (session?.id) {
        return { success: true };
      }
      return { redirect: '/login' };
    
    // Admin only route
    case '/admin':
      if (session?.admin === true) {
        return { success: true };
      }
      return { redirect: '/unauthorized' };
    
    // Route with query param check
    case '/invite':
      if (searchParams.code) {
        return { success: true };
      }
      return { redirect: '/home' };
    
    // Public routes - allow all
    case '/login':
    case '/register':
    case '/about':
      return { success: true };
    
    // Default: allow (or change to require login)
    default:
      return { success: true };
  }
}
```

---

## Working with Blueprints (Grid Items)

```tsx
import { useBlueprints } from 'src/sandbox/_providers/BlueprintsContextProvider';

function MyComponent() {
  const { blueprints, setBlueprints } = useBlueprints();
  
  // Add a new file
  const addFile = () => {
    setBlueprints(prev => ({
      ...prev,
      files: [...prev.files, {
        id: crypto.randomUUID(),
        name: 'NewComponent.tsx',
        position: { x: 100, y: 100 },
        code: 'export default function NewComponent() { return <div>Hello</div>; }',
        viewMode: 'code',  // 'code' or 'rendered'
        viewport: { width: 375, height: 667, enabled: true }
      }]
    }));
  };
  
  // Add a new note
  const addNote = () => {
    setBlueprints(prev => ({
      ...prev,
      notes: [...prev.notes, {
        id: crypto.randomUUID(),
        position: { x: 200, y: 200 },
        width: 300,
        height: 200,
        content: JSON.stringify({
          type: 'doc',
          content: [
            { type: 'paragraph', content: [{ type: 'text', text: 'New note' }] }
          ]
        })
      }]
    }));
  };
  
  // Update a file's position
  const moveFile = (fileId: string, newX: number, newY: number) => {
    setBlueprints(prev => ({
      ...prev,
      files: prev.files.map(f => 
        f.id === fileId 
          ? { ...f, position: { x: newX, y: newY } }
          : f
      )
    }));
  };
  
  // Delete a note
  const deleteNote = (noteId: string) => {
    setBlueprints(prev => ({
      ...prev,
      notes: prev.notes.filter(n => n.id !== noteId)
    }));
  };
  
  return (
    <div>
      <button onClick={addFile}>Add File</button>
      <button onClick={addNote}>Add Note</button>
      <p>Files: {blueprints.files.length}</p>
      <p>Notes: {blueprints.notes.length}</p>
    </div>
  );
}
```

---

## Drawing System Usage

```tsx
import { useDrawing, ErasingMode } from 'src/sandbox/_providers/DrawingContextProvider';

function DrawingControls() {
  const {
    drawingEnabled,
    setDrawingEnabled,
    brushSize,
    setBrushSize,
    brushColor,
    updateBrushColor,
    erasing,
    setErasing,
    activeShape,
    setActiveShape,
    lineStyle,
    setLineStyle,
    strokes,
    strokeHistory,
    historyIndex,
    setHistoryIndex
  } = useDrawing();
  
  // Toggle drawing mode
  const toggleDrawing = () => setDrawingEnabled(!drawingEnabled);
  
  // Set eraser mode
  const enablePartialErase = () => setErasing(ErasingMode.PARTIAL);
  const enableFullErase = () => setErasing(ErasingMode.FULL);
  const disableErase = () => setErasing(ErasingMode.DISABLED);
  
  // Set shape tool
  const drawSquare = () => setActiveShape('square');
  const drawCircle = () => setActiveShape('circle');
  const freeDraw = () => setActiveShape(null);
  
  // Undo/Redo
  const undo = () => {
    if (historyIndex > 0) {
      setHistoryIndex(historyIndex - 1);
    }
  };
  
  const redo = () => {
    if (historyIndex < strokeHistory.length - 1) {
      setHistoryIndex(historyIndex + 1);
    }
  };
  
  return (
    <div>
      <button onClick={toggleDrawing}>
        {drawingEnabled ? 'Exit Drawing' : 'Start Drawing'}
      </button>
      
      <input 
        type="color" 
        value={brushColor} 
        onChange={e => updateBrushColor(e.target.value)} 
      />
      
      <input 
        type="range" 
        min={1} max={50} 
        value={brushSize} 
        onChange={e => setBrushSize(Number(e.target.value))} 
      />
      
      <select 
        value={lineStyle} 
        onChange={e => setLineStyle(e.target.value as any)}
      >
        <option value="solid">Solid</option>
        <option value="dashed">Dashed</option>
        <option value="dotted">Dotted</option>
      </select>
      
      <button onClick={undo} disabled={historyIndex <= 0}>Undo</button>
      <button onClick={redo} disabled={historyIndex >= strokeHistory.length - 1}>Redo</button>
      
      <p>Strokes: {strokes.length}</p>
    </div>
  );
}
```

---

## File Structure Patterns

### Page with API and Sync:
```
src/
└── myFeature/
    ├── page.tsx           # Main page component
    ├── _api/              # Server-only API routes
    │   ├── getData.ts     # GET-like operations
    │   ├── saveData.ts    # POST-like operations
    │   └── deleteItem.ts  # DELETE operations
    └── _sync/             # Real-time sync events
        ├── itemUpdated_server.ts
        ├── itemUpdated_client.ts
        ├── userJoined_server.ts
        └── userJoined_client.ts
```

### Sandbox Feature:
```
src/sandbox/
├── _components/
│   └── myFeature/         # Feature UI components
│       ├── MyFeature.tsx
│       └── MyFeatureMenu.tsx
├── _functions/
│   └── myFeature/         # Feature logic
│       ├── utils.ts
│       └── handlers.ts
├── _providers/
│   └── MyFeatureContextProvider.tsx  # Feature state
└── types/
    └── myFeatureTypes.ts  # TypeScript types
```

---

## OAuth Login Flow

```tsx
import config from 'config';

// Redirect to OAuth provider
const loginWithGoogle = () => {
  window.location.href = `${config.backendUrl}/auth/api/google`;
};

const loginWithGithub = () => {
  window.location.href = `${config.backendUrl}/auth/api/github`;
};

// After OAuth callback, user is redirected to config.loginRedirectUrl
// with session cookie set automatically
```

---

## Session Access Patterns

```tsx
import { useSession, getCurrentSession } from 'src/_providers/SessionProvider';

// In a React component (hook)
function MyComponent() {
  const { session, sessionLoaded } = useSession();
  
  if (!sessionLoaded) {
    return <div>Loading...</div>;
  }
  
  if (!session?.id) {
    return <div>Please log in</div>;
  }
  
  return (
    <div>
      <p>Welcome, {session.name}!</p>
      <p>Email: {session.email}</p>
      <p>Theme: {session.theme}</p>
      <p>Language: {session.language}</p>
      <img src={session.avatar} alt="Avatar" />
    </div>
  );
}

// Outside React (in utility functions)
import { getCurrentSession } from 'src/_providers/SessionProvider';

function someUtilityFunction() {
  const session = getCurrentSession();
  if (session?.admin) {
    // Admin-only logic
  }
}
```

---

# Quick Reference Cheatsheet

> **Copy-paste ready snippets for common operations.**

---

## Imports

```tsx
// Sockets & Communication
import { apiRequest } from 'src/_sockets/apiRequest';
import { syncRequest, useSyncEvents } from 'src/_sockets/syncRequest';
import { joinRoom } from 'src/_sockets/socketInitializer';

// Session & Auth
import { useSession, getCurrentSession } from 'src/_providers/SessionProvider';

// UI Components
import { useMenuHandler } from 'src/_components/MenuHandler';
import { confirmDialog } from 'src/_components/ConfirmMenu';
import notify from 'src/_functions/notify';

// Translation
import { useTranslation, useUpdateLanguage, translate } from 'src/_components/TranslationProvider';

// Sandbox Providers
import { useGrid } from 'src/sandbox/_providers/GridContextProvider';
import { useBlueprints } from 'src/sandbox/_providers/BlueprintsContextProvider';
import { useDrawing, ErasingMode } from 'src/sandbox/_providers/DrawingContextProvider';
import { useCode } from 'src/sandbox/_providers/CodeContextProvider';
import { useNotes } from 'src/sandbox/_providers/NotesContextProvider';

// Config
import config from 'config';
```

---

## API Calls

| Action | Code |
|--------|------|
| Call API | `await apiRequest({ name: 'apiName', data: { key: 'value' } })` |
| Get session | `await apiRequest({ name: 'session' })` |
| Logout | `await apiRequest({ name: 'logout' })` |

---

## Real-time Sync

| Action | Code |
|--------|------|
| Join room | `joinRoom('room-code')` |
| Send sync | `await syncRequest({ name: 'eventName', data: {}, receiver: 'room-code' })` |
| Send (skip self) | `await syncRequest({ name: 'event', data: {}, receiver: 'room', ignoreSelf: true })` |
| Listen for sync | `useSyncEvents().upsertSyncEventCallback('eventName', ({ serverData }) => { ... })` |

---

## Notifications

| Type | Code |
|------|------|
| Success | `notify.success({ key: 'translation.key' })` |
| Error | `notify.error({ key: 'translation.key' })` |
| Info | `notify.info({ key: 'translation.key' })` |
| Warning | `notify.warning({ key: 'translation.key' })` |
| With params | `notify.success({ key: 'key', params: [{ key: 'name', value: 'John' }] })` |

---

## Modal System

| Action | Code |
|--------|------|
| Open modal | `menuHandler.open(<Component />, { dimBackground: true, size: 'md' })` |
| Close top | `menuHandler.close()` |
| Close all | `menuHandler.closeAll()` |
| Confirm dialog | `const ok = await confirmDialog({ title: 'Delete?', content: 'Are you sure?' })` |
| Confirm + input | `await confirmDialog({ title: 'Type YES', input: 'YES' })` |

---

## Session

| Action | Code |
|--------|------|
| Get in component | `const { session, sessionLoaded } = useSession()` |
| Get outside React | `const session = getCurrentSession()` |
| Check logged in | `if (session?.id) { ... }` |
| Check admin | `if (session?.admin) { ... }` |

---

## Blueprints (Grid Items)

| Action | Code |
|--------|------|
| Get blueprints | `const { blueprints, setBlueprints } = useBlueprints()` |
| Add file | `setBlueprints(p => ({ ...p, files: [...p.files, newFile] }))` |
| Add note | `setBlueprints(p => ({ ...p, notes: [...p.notes, newNote] }))` |
| Update file | `setBlueprints(p => ({ ...p, files: p.files.map(f => f.id === id ? {...f, ...changes} : f) }))` |
| Delete file | `setBlueprints(p => ({ ...p, files: p.files.filter(f => f.id !== id) }))` |

---

## Drawing

| Action | Code |
|--------|------|
| Toggle drawing | `setDrawingEnabled(!drawingEnabled)` |
| Set color | `updateBrushColor('#FF0000')` |
| Set size | `setBrushSize(20)` |
| Partial erase | `setErasing(ErasingMode.PARTIAL)` |
| Full erase | `setErasing(ErasingMode.FULL)` |
| Stop erasing | `setErasing(ErasingMode.DISABLED)` |
| Draw square | `setActiveShape('square')` |
| Draw circle | `setActiveShape('circle')` |
| Freehand | `setActiveShape(null)` |
| Undo | `setHistoryIndex(historyIndex - 1)` |
| Redo | `setHistoryIndex(historyIndex + 1)` |

---

## Grid

| Action | Code |
|--------|------|
| Get grid state | `const { zoom, offset, setZoom, setOffset } = useGrid()` |
| Reset zoom | `setZoom(1)` |
| Reset position | `setOffset({ x: 0, y: 0 })` |

---

## Translation

| Action | Code |
|--------|------|
| Get translations | `const t = useTranslation()` |
| Access key | `t.login.title` |
| Change language | `const setLang = useUpdateLanguage(); setLang('en')` |
| Dynamic translate | `translate({ translationList: t, key: 'key', params: [...] })` |

---

## File Naming Conventions

| Type | Pattern | Example |
|------|---------|---------|
| Page | `src/{route}/page.tsx` | `src/dashboard/page.tsx` |
| API | `src/{route}/_api/{name}.ts` | `src/settings/_api/updateProfile.ts` |
| Sync Server | `src/{route}/_sync/{name}_server.ts` | `src/game/_sync/move_server.ts` |
| Sync Client | `src/{route}/_sync/{name}_client.ts` | `src/game/_sync/move_client.ts` |
| Provider | `src/sandbox/_providers/{Name}ContextProvider.tsx` | `DrawingContextProvider.tsx` |
| Component | `src/sandbox/_components/{feature}/{Name}.tsx` | `drawing/DrawingSideMenu.tsx` |

---

## Auth Guard Options

```typescript
export const auth: AuthProps = {
  login: true,                              // Must be logged in
  additional: [
    { key: 'admin', value: true },          // admin === true
    { key: 'email', type: 'string' },       // typeof email === 'string'
    { key: 'groupId', mustBeFalsy: false }, // groupId is truthy
    { key: 'deletedAt', nullish: true },    // deletedAt is null/undefined
  ]
};
```

---

## Config Keys (`config.ts`)

| Key | Purpose |
|-----|---------|
| `backendUrl` | Server URL for API/socket |
| `devMode` | Development mode flag |
| `defaultLanguage` | Fallback language ('en') |
| `defaultTheme` | Fallback theme ('light') |
| `loginRedirectUrl` | Where to go after login |
| `loginPageUrl` | Login page path |
| `providers` | Enabled OAuth providers array |

---

## Keyboard Shortcuts (Sandbox)

| Shortcut | Action |
|----------|--------|
| `Escape` | Exit drawing mode / Close menu / Deselect |
| `Ctrl+Z` | Undo (when implemented) |
| `Ctrl+Shift+Z` | Redo (when implemented) |
| `/` | Open slash command menu in notes |
| `Enter` | Focus code block in notes |

---

## Common Type Shapes

```typescript
// File on grid
type file = {
  id: string;
  name: string;
  position: { x: number; y: number };
  code: string;
  viewMode: 'code' | 'rendered';
  viewport: { width: number; height: number; enabled: boolean };
};

// Note on grid
type note = {
  id: string;
  position: { x: number; y: number };
  width: number;
  height: number;
  content: string; // TipTap JSON stringified
};

// Drawing stroke
type StrokeData = {
  id: string;
  points: { x: number; y: number; color: string; size: number }[];
  fill?: string;
  lineStyle?: 'solid' | 'dashed' | 'dotted';
};

// Session
type SessionLayout = {
  id: string;
  name: string;
  email: string;
  provider: string;
  avatar: string;
  admin: boolean;
  language: string;
  theme: string;
  token: string;
  createdAt: Date;
  updatedAt: Date;
};
```
</file>

<file path="server/utils/serveAvatars.ts">
import path from "path";
import { access } from 'fs/promises';
import fs from "fs";
import { ServerResponse } from "http";

export const serveAvatar = async ({ 
  routePath,
  res,
}: {
  routePath: string;
  res: ServerResponse;
}) => {
  const uploadsFolder = path.join(process.cwd(), "uploads");
      
  // Always append .webp since that's the stored format
  const fileId = path.basename(routePath, path.extname(routePath)); // remove any extension if present
  const fileName = `${fileId}.webp`;
  const filePath = path.join(uploadsFolder, fileName);

  if (!fileId) return;

  try {
    await access(filePath)

    res.writeHead(200, {
      "Content-Type": "image/webp",
      "Cache-Control": "public, max-age=86400",
    });

    const readStream = fs.createReadStream(filePath);
    readStream.pipe(res);
  } catch (err) {
    // console.log('File not found:', err, 'red');
    res.writeHead(404, { "Content-Type": "text/plain" });
    res.end("File not found");
  };

  return;
}
</file>

<file path="src/_components/ConfirmMenu.tsx">
import { ReactNode, useState } from 'react';
import { menuHandler } from 'src/_functions/menuHandler';

interface ConfirmMenuProps {
  title: string;
  content?: string | ReactNode;
  input?: string;
  resolve: (val: boolean) => void;
}

export const ConfirmMenu = ({ title, content, input, resolve }: ConfirmMenuProps) => {
  const [inputValue, setInputValue] = useState('');

  const handleConfirm = () => {
    if (input && input !== inputValue) return;
    resolve(true);
    menuHandler.close();
  };

  const handleCancel = () => {
    resolve(false);
    menuHandler.close();
  };

  const inputRequiredAndInvalid = input && input !== inputValue ? true : false;

  return (
    <div className="p-6 flex flex-col gap-4 bg-background2 text-text w-full max-w-md">
      <h2 className="text-xl font-bold">{title}</h2>

      {typeof content === 'string' ? (
        <p className="text-text2">{content}</p>
      ) : (
        content
      )}

      {input && (
        <div className="flex flex-col gap-1">
          <label className="text-sm text-text2">
            Type <span className="font-mono bg-background px-1 rounded">{input}</span> to confirm:
          </label>
          <input
            type="text"
            className="border border-border rounded px-3 py-2 bg-background text-text outline-none focus:ring-0 focus:border-primary transition-colors"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
          />
        </div>
      )}

      <div className="flex gap-4 justify-end">
        <button
          onClick={handleCancel}
          className="px-4 py-2 rounded bg-background hover:bg-background-hover text-text text-sm font-semibold transition-colors"
        >
          Cancel
        </button>
        <button
          onClick={handleConfirm}
          disabled={inputRequiredAndInvalid}
          className={`px-4 py-2 rounded text-sm text-white transition-colors font-semibold
            ${inputRequiredAndInvalid
              ? 'bg-primary/40 cursor-not-allowed'
              : 'bg-primary hover:bg-primary/80 cursor-pointer'
            }`}
        >
          Confirm
        </button>
      </div>
    </div>
  );
};

export const confirmDialog = (props: Omit<ConfirmMenuProps, 'resolve'>): Promise<boolean> => {
  return new Promise((resolve) => {
    menuHandler.open(
      <ConfirmMenu {...props} resolve={resolve} />,
      { dimBackground: true, background: 'bg-background2', size: 'sm' }
    );
  });
};
</file>

<file path="src/_components/LocationProvider.tsx">
import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';
import { useSession } from 'src/_providers/SessionProvider';
import { updateLocationRequest } from 'src/_sockets/socketInitializer';

export default function LocationProvider({ children }: { children: React.ReactNode }) {
  const location = useLocation();
  const { session } = useSession();
  
  useEffect(() => {
    //? when the user changes the url, update the location in the users session data on the server, also update navbar from default tempalte
    const searchParams: Record<string, string> = {};
    for (const [key, value] of new URLSearchParams(location.search)) {
      searchParams[key] = value;
    }
    const locationObj = {
      pathName: location.pathname,
      searchParams,
      previousLocation: session?.location?.pathName || null,
    }

    void updateLocationRequest({ location: locationObj })
  }, [location]);

  //? Outlet is all the child components in the browser router
  return (
    <>
      {children}
    </>
  );
}
</file>

<file path="src/_components/LoginForm.tsx">
import { useRef, useState } from "react";
import { Link } from "react-router-dom";
import config, { providers, SessionLayout } from "config";
import tryCatch from "src/_functions/tryCatch";
import notify from "../_functions/notify";
const env = import.meta.env;

export default function LoginForm({ formType }: { formType: "login" | "register" }) {
  const isLogin = formType === "login";
  const title = isLogin ? "Sign in to your account" : "Create a new account";
  const subtitleText = isLogin ? "Don't have an account yet? " : "Already have an account? ";
  const subtitleLink = isLogin ? "Create one now" : "Log in";
  const redirectURL = isLogin ? "/register" : "/login";
  const buttonText = isLogin ? "Log in" : "Sign up";

  const buttonRef = useRef<HTMLButtonElement>(null);
  const [loading, setLoading] = useState(false);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      buttonRef.current?.click();
    }
  };

  const handleSubmit = async (e: React.MouseEvent<HTMLButtonElement>, provider: string) => {
    e.preventDefault();
    if (loading) return;
    setLoading(true);

    if (provider !== "credentials") {
      window.location.href = `${config.backendUrl}/auth/api/${provider}`;
      return;
    }

    const form = (e.target as HTMLElement).closest("form");
    if (!form) {
      setLoading(false);
      return console.error("Form not found");
    }

    const getValue = (name: string) =>
      (form.querySelector(`input[name="${name}"]`) as HTMLInputElement)?.value || "";

    const name = getValue("name");
    const email = getValue("email");
    const password = getValue("password");
    const confirmPassword = getValue("confirmPassword");

    const fetchUser = async () => {
      const res = await fetch(`${config.backendUrl}/auth/api/credentials`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, email, password, confirmPassword, provider }),
        credentials: "include",
      });
      return (await res.json()) as { status: boolean; reason: string, newToken: string | null, session: SessionLayout | undefined };
    };

    const [error, response] = await tryCatch(fetchUser);
    if (error || !response?.reason) {
      // notify.error("Unexpected error occurred.");
      notify.error({ key: 'commen/.404' })
      console.error(error || "No JSON response");
      return setLoading(false);
    }

    if (!response.status) {
      notify.error({ key: response.reason });
      return setLoading(false);
    }

    notify.success({ key: response.reason });
    setTimeout(() => {
      if (response.newToken) {
        if (env.VITE_SESSION_BASED_TOKEN == 'true') {
          sessionStorage.setItem("token", response.newToken);
        }
      }
      window.location.href = response.newToken ? config.loginRedirectUrl : config.loginPageUrl;
      // window.location.href = config.loginPageUrl;
    }, 1000);
  };

  return (
    <div className="w-full overflow-y-auto flex items-center justify-center">
      <form
        onKeyDown={handleKeyDown}
        className="p-8 bg-container rounded-md text-title flex flex-col gap-10 max-w-[400px] w-full"
      >
        <div className="flex flex-col gap-2">
          <h1 className="font-semibold text-lg">{title}</h1>
          <p className="font-medium text-sm text-common">
            {subtitleText}
            <Link to={redirectURL} className="text-blue-500 cursor-pointer">
              {subtitleLink}
            </Link>
          </p>
        </div>

        {providers.includes("credentials") && (
          <>
            <div className="flex flex-col gap-4">
              {!isLogin && (
                <div className="flex flex-col gap-2">
                  <label className="font-medium text-sm">Name</label>
                  <input
                    name="name"
                    type="text"
                    placeholder="John Pork"
                    className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                  />
                </div>
              )}
              <div className="flex flex-col gap-2">
                <label className="font-medium text-sm">Email address</label>
                <input
                  name="email"
                  type="email"
                  placeholder="johnpork@gmail.com"
                  className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                />
              </div>
              <div className="flex flex-col gap-2">
                <label className="font-medium text-sm">Password</label>
                <input
                  name="password"
                  type="password"
                  placeholder="********"
                  className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                />
              </div>
              {!isLogin && (
                <div className="flex flex-col gap-2">
                  <label className="font-medium text-sm">Confirm password</label>
                  <input
                    name="confirmPassword"
                    type="password"
                    placeholder="********"
                    className="rounded-md w-full h-8 border border-container-border focus:outline-blue-500 p-2"
                  />
                </div>
              )}

              <div className="flex items-center justify-center">
                {isLogin && (
                  <button className="px-8 h-10 cursor-pointer rounded-md text-blue-500 hover:scale-105 transition-all duration-300">
                    Forgot Password?
                  </button>
                )}
              </div>

              <button
                ref={buttonRef}
                className="px-8 h-10 rounded-md bg-blue-500 text-title hover:scale-105 transition-all duration-300 cursor-pointer"
                onClick={(e) => void handleSubmit(e, "credentials")}
              >
                {loading ? "Loading..." : buttonText}
              </button>
            </div>

            <div className="flex items-center w-full text-gray-500 text-sm before:flex-1 before:border-t before:border-container-border before:content-[''] after:flex-1 after:border-t after:border-container-border after:content-['']">
              <span className="px-4 bg-container text-title">Or continue with</span>
            </div>
          </>
        )}

        <div className="grid grid-cols-2 gap-2">
          {providers
            .filter((p) => p !== "credentials")
            .map((provider) => (
              <button
                key={provider}
                onClick={(e) => void handleSubmit(e, provider)}
                className="h-10 rounded-md cursor-pointer bg-container text-title border border-container-border flex gap-2 items-center justify-center hover:scale-105 transition-all duration-300"
              >
                <img src={`/${provider}.png`} alt={provider} className="w-5 h-5" />
                <span className="text-lg">{provider.charAt(0).toUpperCase() + provider.slice(1)}</span>
              </button>
            ))}
        </div>
      </form>
    </div>
  );
}
</file>

<file path="src/_components/MenuHandler.tsx">
import { createContext, useContext, useState, ReactNode, ReactElement, useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import { v4 as uuidv4 } from 'uuid';

// Types
interface MenuEntry {
  id: string;
  element: ReactElement;
  options: MenuOptions;
  isClosing?: boolean;
  soonIsTop?: boolean;
  resolver?: (value: any) => void;
}

interface MenuOptions {
  dimBackground?: boolean;
  background?: string;
  size?: 'sm' | 'md' | 'lg';
}

interface MenuHandlerContextType {
  open: (element: ReactElement, options?: MenuOptions) => Promise<any>;
  replace: (element: ReactElement, options?: MenuOptions) => Promise<any>;
  close: () => void;
  closeAll: () => void;
  logStack: () => void;
}

interface SlideInWrapperProps {
  children: ReactNode;
  isTop: boolean;
  options: MenuOptions;
  isClosing?: boolean;
  soonIsTop?: boolean;
}

const SlideInWrapper = ({ children, options, isTop, isClosing, soonIsTop }: SlideInWrapperProps) => {
  const [location, setLocation] = useState<'left' | 'center' | 'right'>('center');

  useEffect(() => {
    // Only slide when stacking multiple menus
    if (!isTop && location === 'center') {
      setLocation('left');
    } else if (isClosing && location === 'center') {
      setLocation('right');
    } else if (location === 'left' && soonIsTop) {
      setLocation('center');
    }
  }, [isTop, isClosing, soonIsTop]);

  const translate =
    location === 'center'
      ? '0 0'
      : location === 'left'
        ? '-100% 0'
        : '100% 0';

  return (
    <div
      className={`w-full overflow-hidden absolute flex flex-col text-black transform transition-transform duration-300 
        ${options.background ?? ''}
      `}
      style={{ translate }}
    >
      {children}
    </div>
  );
};


const MenuHandlerContext = createContext<MenuHandlerContextType | null>(null);

export const useMenuHandler = () => {
  const ctx = useContext(MenuHandlerContext);
  if (!ctx) throw new Error('useMenuHandler must be used within MenuHandlerProvider');
  return ctx;
};

export const MenuHandlerProvider = ({ children }: { children: ReactNode }) => {
  const [stack, setStack] = useState<MenuEntry[]>([]);
  const [isAnimatingIn, setIsAnimatingIn] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });

  const open = (element: ReactElement, options: MenuOptions = {}) => {
    return new Promise((resolve) => {
      const id = uuidv4();
      setStack((prev) => [...prev, { id, element, options, resolver: resolve }]);
      setIsAnimatingIn(true);
      // Reset animation state after initial render
      requestAnimationFrame(() => {
        setIsAnimatingIn(false);
      });
    });
  };

  const replace = (element: ReactElement, options: MenuOptions = {}) => {
    return new Promise((resolve) => {
      const id = uuidv4();
      setStack((prev) => {
        const newStack = [...prev];
        newStack.pop();
        newStack.push({ id, element, options, resolver: resolve });
        return newStack;
      });
    });
  };

  const close = () => {
    setStack((prev) => {
      if (prev.length === 0) return prev;
      const lastitem = prev.length == 1
      const newStack = [...prev];
      const top = newStack[newStack.length - 1];
      const second = newStack[newStack.length - 2];

      // Prevent double-close
      if ((top as any).isClosing) return prev;

      // Mark top as closing
      if (!lastitem) {
        newStack[newStack.length - 1] = { ...top, isClosing: true };
        if (second) {
          newStack[newStack.length - 2] = { ...second, soonIsTop: true };
        }
      } else {
        top.resolver?.(null);
        return [];
      }

      // Delay removal for animation
      if (!lastitem) {
        setTimeout(() => {
          setStack((current) => {
            const last = current[current.length - 1];
            const tempSecond = current[current.length - 2];
            if (last?.id === top.id && (last as any).isClosing) {
              if (last.resolver) last.resolver(null);
              if (tempSecond?.id && tempSecond.id == second?.id && (tempSecond as any).soonIsTop) {
                current[current.length - 2] = { ...tempSecond, soonIsTop: false };
              }
              return current.slice(0, -1);
            }
            return current;
          });
        }, 200); // Match animation duration
      }
      return newStack;
    });
  };


  const closeAll = () => {
    setStack((prev) => {
      prev.forEach((entry) => entry.resolver?.(null));
      return [];
    });
  };

  const logStack = () => {
    console.log('Menu stack:', stack.map(s => s.id));
  };

  // Handle keyboard events
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') close();
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  // Measure container size based on content
  useEffect(() => {
    if (!containerRef.current || stack.length === 0) {
      setContainerSize({ width: 0, height: 0 });
      return;
    }

    const updateSize = () => {
      if (!containerRef.current) return;

      const lastChild = containerRef.current.lastElementChild as HTMLElement;
      if (lastChild) {
        const rect = lastChild.getBoundingClientRect();
        setContainerSize({
          width: rect.width,
          height: rect.height
        });
      }
    };

    // Initial measurement
    updateSize();

    // Use ResizeObserver for dynamic content changes
    const resizeObserver = new ResizeObserver(updateSize);
    if (containerRef.current) {
      resizeObserver.observe(containerRef.current);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, [stack]);

  const stackTop = stack[stack.length - 1] || {};

  const sizeClass = {
    sm: '384px',
    md: '512px',
    lg: '768px',
  }[stackTop?.options?.size || 'sm'];

  let attempToCloseAll = false;

  return (
    <MenuHandlerContext.Provider value={{ open, replace, close, closeAll, logStack }}>
      {children}
      {createPortal(
        <div
          className={`absolute top-0 left-0 w-full h-full flex items-center justify-center z-[1000] overflow-hidden ${stack.length == 0 ? 'pointer-events-none' : ''}`}
          style={{ backgroundColor: stackTop.options && stackTop.options?.dimBackground != false ? 'rgba(0, 0, 0, 0.7)' : 'transparent' }}
          onMouseDown={() => attempToCloseAll = true}
          onMouseUp={() => {
            if (!attempToCloseAll) { return }
            closeAll();
          }}
        >
          <div
            ref={containerRef}
            className={`rounded-md overflow-hidden relative
              transition-[opacity,transform,height,width] duration-200 origin-center
              ${isAnimatingIn || stack.length === 0 ? 'opacity-0 scale-90' : 'opacity-100 scale-100'}
            `}
            style={{
              width: containerSize.width > 0 ? `${containerSize.width}px` : sizeClass,
              height: containerSize.height > 0 ? `${containerSize.height}px` : 'auto'
            }}
            onMouseDown={(e) => e.stopPropagation()}
            onMouseUp={(e) => e.stopPropagation()}
          >
            {stack.map((entry, index) => (
              <SlideInWrapper
                key={entry.id}
                isTop={index === stack.length - 1}
                isClosing={entry.isClosing}
                soonIsTop={entry.soonIsTop}
                options={entry.options}
              >
                {entry.element}
              </SlideInWrapper>
            ))}
          </div>
        </div>,
        document.body
      )}
    </MenuHandlerContext.Provider>
  );
};
</file>

<file path="src/_components/Router.tsx">
import { useLocation, useNavigate } from "react-router-dom";
import middlewareHandler from "src/_functions/middlewareHandler";
import { useSession } from "../_providers/SessionProvider";

const getParams = (locationSearch: string) => {
  const params = new URLSearchParams(locationSearch);
  const queryObject: Record<string, string> = {};

  params.forEach((value, key) => {
    queryObject[key] = value;
  });

  return queryObject;
}

export default function useRouter() {
  const navigateHandler = useNavigate();
  const location = useLocation();
  const { session } = useSession();

  return async (path: string) => {
    // const session = await apiRequest({ name: 'session' }) as SessionLayout;
    const queryObject = getParams(location.search);
    const result = await middlewareHandler({ location: path, searchParams: queryObject, session }) as { success: boolean, redirect: string } | undefined;

    if (result?.success) {
      return navigateHandler(path);
    } else if (result?.redirect) {
      return navigateHandler(result.redirect);
    } else {
      return
    }
  }
}
</file>

<file path="src/_functions/middlewareHandler.ts">
//? here you can add your own route
//? return an object with the success key set to true if the user is allowed to access the route
//? return an object with the redirect key set to the path you want to redirect the user to if you want to redirect the user to a different page
//? return nothing if the user is not allowed to access the route and it will be send back to its previous page
//? if you dont add your page in here it will allow the user to access the page
import { SessionLayout } from "config";
import notify from "src/_functions/notify";

// @ts-ignore // we use ts-ignore because we dont use the searcParams in the example and this will cause a bundle error
export default function middlewareHandler({ location, searchParams, session }: { location: string, searchParams: Record<string, any>, session: SessionLayout | null }) {
  console.log(session)

  switch (location) {
    case '/test':
      if (session?.email && session?.provider) { 
        return { success: true }; 
      }
      return { redirect: '/login' };

    case '/home':
      if (session?.email && session?.provider) {
        return { success: true };
      } else {
        return { redirect: '/login' };
      }

    default:
      return { success: true };
  }
}
</file>

<file path="src/home/page.tsx">
import useRouter from "src/_components/Router"

export const template = 'main'
export default function HomePage() {

  const router = useRouter();

  return (
    <div className="bg-background w-full h-full">
      Home Page
      <button
        className="bg-blue-500 px-6 py-1 rounded cursor-pointer"
        onClick={() => router("/sandbox")}
      >
        Click to go to sandbox cvdgjBHSZ
      </button>
    </div>
  )
}
</file>

<file path="src/sandbox/_components/editor/BuilderMenu.tsx">
export default function BuilderMenu() {
  return (
    <div className="bg-background w-full h-full text-text">
      Builder Menu
    </div>
  )
}
</file>

<file path="src/sandbox/_components/editor/CodeMirrorEditor.tsx">
import { useEffect, useRef, useMemo } from 'react'
import { EditorState, Compartment } from '@codemirror/state'
import { EditorView, keymap } from '@codemirror/view'
import { defaultKeymap, indentWithTab } from '@codemirror/commands'
import { javascript } from '@codemirror/lang-javascript'
import { html } from '@codemirror/lang-html'
import { css } from '@codemirror/lang-css'
import { json } from '@codemirror/lang-json'
import { python } from '@codemirror/lang-python'
import { syntaxHighlighting, HighlightStyle } from '@codemirror/language'
import { tags } from '@lezer/highlight'
import { handleCaretPositionChange } from '../../_functions/notes/handleCaretPosition'

interface CodeMirrorEditorProps {
  value: string
  onChange?: (value: string) => void
  language?: string
  onEscape?: () => void
  onFocus?: () => void
  onBlur?: () => void
  enableCaretTracking?: boolean
  onMount?: (view: any) => void
  preventInitialFocus?: boolean
}

export default function CodeMirrorEditor({
  value,
  onChange,
  language = 'javascript',
  onEscape,
  onFocus,
  onBlur,
  enableCaretTracking = false,
  onMount,
  preventInitialFocus = false
}: CodeMirrorEditorProps) {
  const editorRef = useRef<HTMLDivElement>(null)
  const viewRef = useRef<EditorView | null>(null)
  const handleCaretPosition = handleCaretPositionChange()

  // Create a compartment for the editable facet so we can reconfigure it
  const editableCompartment = useMemo(() => new Compartment(), [])

  useEffect(() => {
    if (!editorRef.current) return

    // Get language extension
    const getLanguageExtension = () => {
      switch (language) {
        case 'javascript':
        case 'typescript':
          return javascript({ typescript: language === 'typescript' })
        case 'html':
          return html()
        case 'css':
          return css()
        case 'json':
          return json()
        case 'python':
          return python()
        default:
          return javascript()
      }
    }

    // Custom theme matching the dark design with syntax colors
    const customTheme = EditorView.theme({
      '&': {
        backgroundColor: 'transparent',
        height: '100%',
        fontSize: '14px',
        color: '#d4d4d4', // Default text color
      },
      '.cm-content': {
        caretColor: '#fff',
        padding: '0',
        fontFamily: 'monospace',
      },
      '.cm-cursor': {
        borderLeftColor: '#fff',
      },
      '.cm-activeLine': {
        backgroundColor: 'transparent',
      },
      '.cm-selectionBackground': {
        backgroundColor: 'rgba(255, 255, 255, 0.1) !important',
      },
      '&.cm-focused .cm-selectionBackground': {
        backgroundColor: 'rgba(255, 255, 255, 0.15) !important',
      },
      '.cm-gutters': {
        display: 'none',
      },
      '.cm-line': {
        padding: '0',
      },
      // Syntax highlighting colors matching VS Code/Monaco
      '.tok-keyword': { color: '#569cd6' }, // Blue for keywords
      '.tok-string': { color: '#ce9178' }, // Orange for strings 
      '.tok-comment': { color: '#6a9955', fontStyle: 'italic' }, // Green for comments
      '.tok-number': { color: '#b5cea8' }, // Light green for numbers
      '.tok-variableName': { color: '#9cdcfe' }, // Light blue for variables
      '.tok-typeName': { color: '#4ec9b0' }, // Teal for types
      '.tok-function': { color: '#dcdcaa' }, // Yellow for function names
      '.tok-operator': { color: '#d4d4d4' }, // White for operators
      '.tok-propertyName': { color: '#9cdcfe' }, // Light blue for properties
      '.tok-punctuation': { color: '#d4d4d4' }, // White for punctuation
      '.tok-tagName': { color: '#569cd6' }, // Blue for HTML tags
      '.tok-attributeName': { color: '#9cdcfe' }, // Light blue for attributes
      '.tok-className': { color: '#4ec9b0' }, // Teal for classes
      '.tok-definition': { color: '#dcdcaa' }, // Yellow for definitions
      '.tok-meta': { color: '#569cd6' }, // Blue for meta
    }, { dark: true })

    // Escape key handler
    const escapeKeymap = keymap.of([
      {
        key: 'Escape',
        run: () => {
          if (onEscape) {
            onEscape()
            return true
          }
          return false
        }
      }
    ])

    // Custom syntax highlighting style (VS Code colors)
    const customHighlightStyle = HighlightStyle.define([
      { tag: tags.keyword, color: '#569cd6' }, // Blue
      { tag: tags.name, color: '#9cdcfe' }, // Light blue
      { tag: tags.deleted, color: '#f44747' },
      { tag: tags.inserted, color: '#608b4e' },
      { tag: tags.changed, color: '#569cd6' },
      { tag: tags.invalid, color: '#f44747' },
      { tag: tags.comment, color: '#6a9955', fontStyle: 'italic' }, // Green
      { tag: tags.string, color: '#ce9178' }, // Orange
      { tag: tags.number, color: '#b5cea8' }, // Light green
      { tag: tags.bool, color: '#569cd6' },
      { tag: tags.regexp, color: '#d16969' },
      { tag: tags.escape, color: '#d7ba7d' },
      { tag: tags.variableName, color: '#9cdcfe' }, // Light blue
      { tag: tags.function(tags.variableName), color: '#dcdcaa' }, // Yellow for functions
      { tag: tags.propertyName, color: '#9cdcfe' },
      { tag: tags.className, color: '#4ec9b0' }, // Teal
      { tag: tags.typeName, color: '#4ec9b0' },
      { tag: tags.namespace, color: '#4ec9b0' },
      { tag: tags.operator, color: '#d4d4d4' },
      { tag: tags.punctuation, color: '#d4d4d4' },
      { tag: tags.bracket, color: '#ffd700' }, // Gold for brackets
      { tag: tags.tagName, color: '#569cd6' },
      { tag: tags.attributeName, color: '#9cdcfe' },
    ])

    // Create editor state
    const startState = EditorState.create({
      doc: value,
      extensions: [
        getLanguageExtension(),
        customTheme,
        keymap.of([...defaultKeymap, indentWithTab]),
        escapeKeymap,
        syntaxHighlighting(customHighlightStyle),
        EditorView.updateListener.of((update) => {
          if (update.docChanged && onChange) {
            onChange(update.state.doc.toString())
          }

          // Handle focus/blur
          if (update.focusChanged) {
            if (update.view.hasFocus) {
              onFocus?.()
            } else {
              onBlur?.()
            }
          }

          // Track cursor position for grid auto-scroll
          if (enableCaretTracking && (update.selectionSet || update.geometryChanged)) {
            const selection = update.state.selection.main
            const coords = update.view.coordsAtPos(selection.head)
            if (coords && editorRef.current) {
              const caretPosition = {
                absoluteX: coords.left,
                absoluteY: coords.top,
                viewportPercentage: (coords.top / window.innerHeight) * 100,
                viewportPercentageX: (coords.left / window.innerWidth) * 100,
                isInViewport: true,
                offset: 0,
                offsetNode: editorRef.current as unknown as globalThis.Node,
                getClientRect: () => new DOMRect(coords.left, coords.top, 0, coords.bottom - coords.top)
              }
              handleCaretPosition(caretPosition)
            }
          }
        }),
        EditorView.lineWrapping,
        // Make editor non-interactive until explicitly focused
        ...(preventInitialFocus ? [
          editableCompartment.of(EditorView.editable.of(false)),
        ] : []),
      ],
    })

    // Create view
    const view = new EditorView({
      state: startState,
      parent: editorRef.current,
      ...(preventInitialFocus && {
        // Prevent focus on mousedown to let TipTap handle block selection first
        dispatch(tr) {
          view.update([tr])
          return true
        }
      })
    })

    viewRef.current = view

    // Store editableCompartment on view for external access
    if (preventInitialFocus) {
      (view as any)._editableCompartment = editableCompartment
    }

    // Call onMount callback with view instance
    if (onMount) {
      onMount(view)
    }

    // Make editor editable when it gains focus (if preventInitialFocus is enabled)
    if (preventInitialFocus && editorRef.current) {
      const editorElement = editorRef.current;

      editorElement.addEventListener('focusin', () => {
        if (view) {
          // Make editable
          view.dispatch({
            effects: editableCompartment.reconfigure(EditorView.editable.of(true))
          })
          // Re-enable pointer events
          if (editorElement) {
            editorElement.style.pointerEvents = 'auto';
          }
        }
      })
    }

    return () => {
      view.destroy()
      viewRef.current = null
    }
  }, [language]) // Recreate when language changes

  // Update content when value changes externally
  useEffect(() => {
    if (viewRef.current && value !== viewRef.current.state.doc.toString()) {
      viewRef.current.dispatch({
        changes: {
          from: 0,
          to: viewRef.current.state.doc.length,
          insert: value,
        },
      })
    }
  }, [value])

  return <div ref={editorRef} className="w-full h-full" />
}
</file>

<file path="src/sandbox/_components/files/Render.tsx">
import { file } from "src/sandbox/types/blueprints";
import { ScreenRenderer } from "../grid/ScreenRenderer";
import { useCode } from "src/sandbox/_providers/CodeContextProvider";
import { useBlueprints } from "src/sandbox/_providers/BlueprintsContextProvider";
import { useBuilderPanel } from "src/sandbox/_providers/BuilderPanelContextProvider";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faFile } from "@fortawesome/free-solid-svg-icons";
import Dropdown from "src/_components/Dropdown";
import { viewportMapping, Viewports } from "src/sandbox/types/viewportMapping";
import { useEffect } from "react";

export default function Render({
  file,
  setFile
}: {
  file: file;
  setFile: (fileUpdate: Partial<file>) => void;
}) {

  useEffect(() => {
    console.log(viewportMapping[file.viewport ?? Viewports.NONE])
    console.log(file.viewport)
  }, [file.viewport])

  const screenSize = file.viewport && file.viewport !== Viewports.NONE
    ? viewportMapping[file.viewport]
    : null;

  const {
    setCodeWindows,
    activeCodeWindow,
    setActiveCodeWindow
  } = useCode();

  const {
    setBlueprints,
    highlightInstances
  } = useBlueprints();

  const {
    prevBuilderMenuMode,
    setBuilderMenuMode,
    setWindowDividerPosition
  } = useBuilderPanel();

  return (
    <div
      key={file.id}
      style={{
        position: 'absolute',
        left: file.position.x,
        top: file.position.y,
      }}
    >
      <ScreenRenderer
        id={file.id}
        name={file.name}
        code={file.code}
        // style={{
        //   width: viewportMapping[file.viewport ?? Viewports.NONE].width ?? 0,
        //   height: viewportMapping[file.viewport ?? Viewports.NONE].height ?? 0,
        // }}
        style={screenSize ? {
          width: screenSize.width ?? 0,
          height: screenSize.height ?? 0,
        } : {}}
        className={`
          VIEW overflow-hidden text-text
          ${highlightInstances ? "outline-4 rounded-3xl" : "pointer-events-auto"}
          ${highlightInstances && file.id != activeCodeWindow ? "outline-border hover:outline-border2 cursor-pointer" : ""}
          ${highlightInstances && file.id == activeCodeWindow ? "outline-border2" : ""}
        `}
        onClick={() => {
          setBuilderMenuMode(prevBuilderMenuMode);
          setWindowDividerPosition(prev => prev || 50);
          setCodeWindows(prev => {
            const exists = prev.find(cw => cw.id === file.id);
            if (exists) {
              return prev;
            }
            return [
              ...prev,
              {
                id: file.id,
                name: file.name,
                code: file.code
              }
            ]
          })
          setActiveCodeWindow(file.id);
        }}
      />

      <div
        className="bg-background2 border h-10 border-border2/50 text-text text-sm absolute top-0 left-0 -translate-y-[200%] rounded-xl flex"
      >
        <Dropdown
          items={Viewports ? Object.values(Viewports) : []}
          itemsPlaceholder={Viewports ? Object.values(Viewports) : []}
          placeholder="Select viewport"
          onChange={(v: Viewports) => { setFile({ viewport: v }); }}
          value={file.viewport}
          className="px-4"
        />
        <div className="w-[1px] h-full bg-border2"></div>
        <div
          className="MENU flex gap-2 items-center px-4 cursor-pointer"
          onClick={() => {
            setFile({ viewMode: 'card' });
          }}
        >
          <FontAwesomeIcon icon={faFile} />
          <h3 className="text-nowrap">Unrender file</h3>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/sandbox/_functions/codeEditor/tailwindcss/inlineColorIcon.ts">
import * as monaco from "monaco-editor";

export default function InitInlineColorIcon(
  editorInstance: monaco.editor.IStandaloneCodeEditor,
  extractColorValue: (cls: string) => string | null = () => null
) {
  let tailwindColorDecorationIds: string[] = [];

  const updateColorIcons = () => {
    const model = editorInstance.getModel();
    if (!model) return;

    const newColorDecorations = findTailwindColors(model, extractColorValue);

    tailwindColorDecorationIds = editorInstance.deltaDecorations(
      tailwindColorDecorationIds,
      newColorDecorations
    );
  }

  updateColorIcons();

  return editorInstance.onDidChangeModelContent(updateColorIcons);
}

function findTailwindColors(
  model: monaco.editor.ITextModel,
  extractColorValue: (cls: string) => string | null = () => null,
) {
  const regex = /\b(?:text|decoration|bg|divide|outline|ring|shadow|accent|caret|fill|stroke|border|border-t|border-b|border-l|border-r|border-x|border-y)-([a-z]+)-\d{3}\b/g;
  const decorations = [];

  const lines = model.getLineCount();

  for (let line = 1; line <= lines; line++) {
    const text = model.getLineContent(line);
    let match;

    while ((match = regex.exec(text))) {
      const cls = match[0];
      const color = extractColorValue(cls);
      if (!color) continue;
      const safeColor = color.replace("#", "");

      //? add icon color to style tag in head
      let styleTag = document.getElementById("dynamicColorIcons") as HTMLStyleElement | null;
      if (!styleTag) {
        styleTag = document.createElement("style");
        styleTag.id = 'dynamicColorIcons'
        document.head.appendChild(styleTag);
      }

      if (!styleTag.innerHTML.includes(`dynamicColorIcon-${safeColor}`)) {
        styleTag.innerHTML += `
          .dynamicColorIcon-${safeColor} {
            background-color: ${color};
          }
        `;
      }

      decorations.push({
        range: new monaco.Range(
          line,
          match.index + 1,
          line,
          match.index + cls.length + 1
        ),
        options: {
          before: {
            content: " ",
            inlineClassName: `inlineColorIcon dynamicColorIcon-${safeColor}`,
            inlineClassNameAffectsLetterSpacing: true, // ensures spacing works without a fake char
          },
        },
      });
      decorations.push({
        range: new monaco.Range(
          line,
          match.index + 1,
          line,
          match.index + cls.length + 1
        ),
        options: {
          before: {
            content: " ",
            inlineClassName: 'inlineColorIconGap',
          },
        },
      })
    }
  }

  return decorations;
}
</file>

<file path="src/sandbox/_functions/codeEditor/themes/textmate/wireTmGrammars.ts">
import * as vsctm from 'vscode-textmate';
import { loadWASM, OnigScanner, OnigString } from 'vscode-oniguruma';
import * as monaco from 'monaco-editor';
// import wasmURL from 'vscode-oniguruma/release/onig.wasm?url';
import { IColorTheme, TMToMonacoToken } from './tm-to-monaco-token';

export {
  convertTheme,
  type IVScodeTheme,
  type TokenColor,
} from './theme-converter';

const wasmPromise = fetch("public/onig.wasm") // put in /public folder
  .then((response) => response.arrayBuffer())
  .then((buffer) => loadWASM({ data: buffer }))
  .catch((error) => console.error('Failed to load `onig.wasm`:', error));

// const scopeUrlMap: Record<string, string> = {
//   'source.ts':
//     'https://raw.githubusercontent.com/microsoft/vscode/main/extensions/typescript-basics/syntaxes/TypeScript.tmLanguage.json',
// };
const scopeUrlMap: Record<string, string> = {
  'source.ts': 'https://raw.githubusercontent.com/microsoft/vscode/main/extensions/typescript-basics/syntaxes/TypeScript.tmLanguage.json',
  'source.tsx': '/TypeScriptReact.tmLanguage.json', // or a raw URL if you prefer
};

const registry = new vsctm.Registry({
  onigLib: wasmPromise.then(() => {
    return {
      createOnigScanner: (sources) => new OnigScanner(sources),
      createOnigString: (str) => new OnigString(str),
    };
  }),
  loadGrammar(scopeName) {
    function fetchGrammar(path: string) {
      return fetch(path).then((response) => response.text());
    }

    const url = scopeUrlMap[scopeName];
    if (url) {
      return fetchGrammar(url).then((grammar) => JSON.parse(grammar));
    }

    return Promise.reject(
      new Error(`No grammar found for scope: ${scopeName}`)
    );
  },
});

async function createTokensProvider(
  scopeName: string,
  editor?:
    | (monaco.editor.IStandaloneCodeEditor & { _themeService?: any })
    | undefined,
  colorTheme?: IColorTheme
): Promise<monaco.languages.TokensProvider> {

  const grammar = await registry.loadGrammar(scopeName);
  if (!grammar) throw new Error('Failed to load grammar');

  if (!colorTheme) {
    colorTheme = {
      tokenColors: [],
    };
  }


  return {
    getInitialState: () => vsctm.INITIAL,
    tokenize(line, state: vsctm.StateStack) {
      const lineTokens = grammar.tokenizeLine(line, state);
      const tokens: monaco.languages.IToken[] = [];

      for (const token of lineTokens.tokens) {
        const resolvedToken = TMToMonacoToken(colorTheme, token.scopes);
        tokens.push({
          startIndex: token.startIndex,
          scopes: resolvedToken,
        });
      }

      return { tokens, endState: lineTokens.ruleStack };
    },
  };
}

class TokensProviderCache {
  private cache: Record<string, monaco.languages.TokensProvider> = {};

  constructor(
    private editor?: monaco.editor.IStandaloneCodeEditor | undefined,
    private colorTheme?: IColorTheme
  ) { }

  async getTokensProvider(
    scopeName: string
  ): Promise<monaco.languages.TokensProvider> {
    if (!this.cache[scopeName]) {
      this.cache[scopeName] = await createTokensProvider(
        scopeName,
        this.editor,
        this.colorTheme
      );
    }

    return this.cache[scopeName];
  }
}

export { TokensProviderCache };
</file>

<file path="src/sandbox/_functions/codeEditor/traverseClickedComponent.ts">
import * as monaco from "monaco-editor";

export default function traverseClickedComponent({
  editor,
  userComponents
}: {
  editor: monaco.editor.IStandaloneCodeEditor,
  userComponents: { name: string; code: string }[]
}) {

  editor.onMouseDown(e => {
    const { target, event } = e;

    if (!event.ctrlKey || event.buttons == 0) return;
    const matched = userComponents.find(c => c.name == target.element?.innerText);
    if (matched) {
      console.log("Ctrl + clicked component:", matched.name);
      event.preventDefault();
    }
  });
}
</file>

<file path="src/sandbox/_functions/drawing/eraseStroke.ts">
import { DrawingPoint, StrokeData } from "src/sandbox/_providers/DrawingContextProvider";
import { isPointInPolygon } from "./sharedUtils";

const notInRange = (stroke: StrokeData, x: number, y: number, radius: number) => {
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const p of stroke.points) {
    if (p.x < minX) minX = p.x;
    if (p.x > maxX) maxX = p.x;
    if (p.y < minY) minY = p.y;
    if (p.y > maxY) maxY = p.y;
  }

  if (x + radius < minX || x - radius > maxX || y + radius < minY || y - radius > maxY) {
    return true;
  }
  return false;
}

export const eraseStokePoint = (
  x: number,
  y: number,
  brushSize: number,
  prevStrokes: StrokeData[]
): StrokeData[] | null => {
  const radius = brushSize / 2;
  const newStrokes: StrokeData[] = [];
  let changed = false;

  for (const stroke of prevStrokes) {
    // optimization: check bounding box first
    if (notInRange(stroke, x, y, radius)) {
      newStrokes.push(stroke);
      continue;
    }

    let currentSegment: DrawingPoint[] = [];
    let strokeModified = false;

    for (const p of stroke.points) {
      const dist = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);
      if (dist > radius) {
        currentSegment.push(p);
      } else {
        strokeModified = true;
        changed = true;
        if (currentSegment.length > 1) {
          // Creates a new stroke, copy lineStyle but not fill
          // We intentionally remove fill when modifying/erasing part of a stroke (partial erase)
          newStrokes.push({ id: crypto.randomUUID(), points: currentSegment, lineStyle: stroke.lineStyle });
        }
        currentSegment = [];
      }
    }

    if (currentSegment.length > 1) {
      // if stroke was not modified at all, keep original id and properties
      newStrokes.push({
        id: strokeModified ? crypto.randomUUID() : stroke.id,
        points: currentSegment,
        fill: strokeModified ? undefined : stroke.fill,
        lineStyle: stroke.lineStyle
      });
    } else if (currentSegment.length <= 1 && !strokeModified) {
      // if original stroke was tiny and not touched
      if (stroke.points.length > 1) {
        newStrokes.push(stroke);
      }
    }
  }

  return changed ? newStrokes : null;
}

export const eraseStroke = (
  x: number,
  y: number,
  brushSize: number,
  prevStrokes: StrokeData[]
) => {
  const radius = brushSize / 2;
  const newStrokes: StrokeData[] = [];

  for (const stroke of prevStrokes) {
    //? Quick reject: mouse nowhere near bounding box
    if (notInRange(stroke, x, y, radius)) {
      newStrokes.push(stroke);
      continue;
    }

    //? Accuracy check: is any actual point near the eraser?
    let hit = false;
    for (const p of stroke.points) {
      const dist = Math.hypot(p.x - x, p.y - y); // cleaner distance
      if (dist <= radius) {
        hit = true;
        break;
      }
    }

    //? Check if inside fill (for filled shapes)
    if (!hit && stroke.fill && stroke.points.length > 2) {
      if (isPointInPolygon({ x, y }, stroke.points)) {
        hit = true;
      }
    }

    if (!hit) {
      //? Stroke wasn't actually touched, keep it
      newStrokes.push(stroke);
    }
    //? Otherwise: do NOT push → stroke is erased
  }

  return newStrokes;

}
</file>

<file path="src/sandbox/_functions/drawing/RenderDrawingPath.tsx">
import { getStroke } from 'perfect-freehand'
import { getSvgPathFromStroke } from './getSvgPathFromStroke'
import { DrawingPoint, LineStyle } from 'src/sandbox/_providers/DrawingContextProvider'

export const RenderDrawingPath = ({ points, zoom, fill, strokeData }: { points: DrawingPoint[], zoom: number, fill?: string, strokeData?: { lineStyle?: LineStyle, text?: string } }) => {
  // If it's a text stroke, we don't render it here (handled in DrawingLayer)
  if (strokeData?.text !== undefined) return null;

  const lineStyle = strokeData?.lineStyle || 'solid';

  // For dashed/dotted, render as a stroke-based line instead of filled path
  if (lineStyle !== 'solid') {
    // Create a simple polyline path from center points
    const linePath = `M ${points.map(p => `${p.x},${p.y}`).join(' L ')}`;
    // Use the brush size directly for stroke width
    const strokeWidth = points[0].size;
    // Make dash array proportional to stroke width for visibility
    const strokeDasharray = lineStyle === 'dashed'
      ? `${strokeWidth * 4} ${strokeWidth * 2}`   // Long dashes with medium gaps
      : `${strokeWidth * 0.1} ${strokeWidth * 2}`; // Tiny dots with large gaps

    return (
      <>
        {fill && <path d={linePath + ' Z'} fill={fill} stroke="none" />}
        <path
          d={linePath}
          fill="none"
          stroke={points[0].color}
          strokeWidth={strokeWidth}
          strokeDasharray={strokeDasharray}
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </>
    );
  }

  // Solid style - use perfect-freehand for smooth filled paths
  const stroke = getStroke(points, {
    size: Math.min(20, (12 / zoom)) * (points[0].size / 10),
    thinning: 0,
    smoothing: 0.5,
    streamline: 0.5,
    easing: (t: number) => t,
    last: true,
  })
  const pathData = getSvgPathFromStroke(stroke)

  // Create fill path from center points
  const fillPath = fill ? `M ${points.map(p => `${p.x},${p.y}`).join(' L ')} Z` : undefined;

  return (
    <>
      {fill && <path d={fillPath} fill={fill} stroke="none" />}
      <path d={pathData} fill={points[0].color} stroke="none" />
    </>
  )
}
</file>

<file path="src/sandbox/_functions/drawing/useDrawingEvents.ts">
import { Dispatch, SetStateAction, useCallback, useEffect, useRef, useState } from "react";
import { clientToWorld } from "./clientToWorld";
import { useGrid } from "src/sandbox/_providers/GridContextProvider";
import { ErasingMode, useDrawing, StrokeData } from "src/sandbox/_providers/DrawingContextProvider";
import { eraseStokePoint, eraseStroke } from "./eraseStroke";
import { generateShapePoints } from "./generateShapePoints";
import { hitTestStroke, isStrokeInRect, getStrokesBoundingBox, isPointInRect, hitTestResizeHandle } from "./selectionUtils";
import { getSnappingGuides, SnappingGuide } from "./snappingUtils";
import { isPointInPolygon } from "./sharedUtils";

export default function useDrawingEvents() {

  const {
    strokes,
    setStrokes,

    currentPoints,
    setCurrentPoints,

    drawingEnabled,

    brushSize,
    erasing,
    brushColor,

    setStrokeHistory,
    historyIndex,
    setHistoryIndex,

    activeShape,

    selectionMode,
    selectedStrokeIds,
    setSelectedStrokeIds,

    snappingEnabled,
    fillMode,
    marqueeMode,

    setMarqueeBox,
    textMode,
    setTextMode,
    lineStyle
  } = useDrawing();

  const {
    zoom,
    offset,
  } = useGrid();

  const startPoint = useRef<{ x: number, y: number } | null>(null);

  // Selection transient state
  const [selectionBox, setSelectionBox] = useState<{ x: number, y: number, width: number, height: number } | null>(null);
  const [dragOffset, setDragOffset] = useState<{ x: number, y: number } | null>(null);
  const [activeSnappingGuides, setActiveSnappingGuides] = useState<SnappingGuide[]>([]);

  // Internal state machine for selection interaction
  const selectionState = useRef<'IDLE' | 'POINTER_DOWN_ON_STROKE' | 'POINTER_DOWN_ON_EMPTY' | 'DRAGGING_STROKES' | 'DRAGGING_SELECTION_BOX' | 'RESIZING'>('IDLE');
  const initialSelectedIds = useRef<string[]>([]); // Snapshot of selection at drag start
  const pointerDownPos = useRef<{ x: number, y: number } | null>(null);
  const hitStrokeIdRef = useRef<string | null>(null);

  // Resize state
  const resizeHandleRef = useRef<'nw' | 'ne' | 'sw' | 'se' | null>(null);
  const initialResizeBoundsRef = useRef<{ minX: number, minY: number, maxX: number, maxY: number } | null>(null);
  const initialResizeStrokesRef = useRef<StrokeData[]>([]);

  // Text Tool State
  const [editingTextId, setEditingTextId] = useState<string | null>(null);
  const textInputRef = useRef<HTMLTextAreaElement | null>(null); // To focus

  useEffect(() => {
    if (!textMode) {
      setEditingTextId(null);
    }
  }, [textMode]);


  const mousePosRef = useRef<{ x: number, y: number } | null>(null);

  // Cursor state
  const [cursorStyle, setCursorStyle] = useState<string | null>(null);

  const handleDrawing = useCallback((
    e: React.PointerEvent<Element>,
    setEraserPos: Dispatch<SetStateAction<{ x: number, y: number } | null>>,
    overlayRef: React.RefObject<SVGSVGElement | null>
  ) => {
    if (!drawingEnabled) { return }

    const firstHit = e.type === 'pointerdown';
    const { x, y } = clientToWorld(e.clientX, e.clientY, overlayRef.current, offset, zoom)

    if (firstHit && overlayRef.current) {
      try {
        overlayRef.current.setPointerCapture(e.pointerId);
      } catch (err) {
        console.error("Failed to capture pointer:", err);
      }
    }

    mousePosRef.current = { x, y };

    // --- HOVER / CURSOR LOGIC (Passive) ---
    // If not dragging/drawing, we update cursor based on what's under it
    if (e.buttons === 0 && !erasing && !marqueeMode) {
      // 1. Check Resize Handles FIRST (if selections exist)
      if (selectedStrokeIds.length > 0) {
        const selectedStrokes = strokes.filter(s => selectedStrokeIds.includes(s.id));
        const bounds = getStrokesBoundingBox(selectedStrokes);
        if (bounds) {
          const handle = hitTestResizeHandle({ x, y }, bounds, zoom);
          if (handle) {
            // Map handle to cursor style
            let cursor = 'default';
            if (handle === 'nw' || handle === 'se') cursor = 'nwse-resize';
            if (handle === 'ne' || handle === 'sw') cursor = 'nesw-resize';
            setCursorStyle(cursor);
            setEraserPos(null); // Hide eraser
            return;
          }
        }
      }

      // 2. Check Selection (Dragging existing selection) or Hovering selectable items
      // We allow dragging IF selectionMode OR (we have a selection and we are in 'hybrid' mode?)
      // Actually, if we have a selection, we can always drag it if we click inside.

      let hoverCursor: string | null = null;
      let hoveringStroke = false;

      // Check inside existing selection
      if (selectedStrokeIds.length > 0) {
        const selectedStrokes = strokes.filter(s => selectedStrokeIds.includes(s.id));
        const bounds = getStrokesBoundingBox(selectedStrokes);
        if (bounds && isPointInRect({ x, y }, bounds)) {
          hoverCursor = 'move';
          hoveringStroke = true;
        }
      }

      // Check for unselected strokes (only if selection mode)
      // In Draw Mode, we do NOT want to show 'move' cursor on unselected items, because clicking them would just draw.
      if (!hoveringStroke && selectionMode) {
        // Optimization: Reverse loop
        for (let i = strokes.length - 1; i >= 0; i--) {
          if (hitTestStroke({ x, y }, strokes[i], zoom)) {
            hoverCursor = 'move'; // Or 'pointer'? 'move' implies draggable.
            break;
          }
        }
      }

      setCursorStyle(hoverCursor);
      setEraserPos(null); // Hide eraser when hovering UI elements? 

      return; // Passive move, done.
    }

    // Reset cursor if we start drawing/interacting or move to empty space (handled by fallback in UI)
    // Persist cursor if we are dragging/resizing
    if (e.buttons === 1) {
      const state = selectionState.current;
      if (state === 'DRAGGING_STROKES' || state === 'POINTER_DOWN_ON_STROKE') {
        setCursorStyle('move');
      } else if (state === 'RESIZING') {
        const h = resizeHandleRef.current;
        if (h === 'nw' || h === 'se') setCursorStyle('nwse-resize');
        else if (h === 'ne' || h === 'sw') setCursorStyle('nesw-resize');
        else setCursorStyle('default');
      } else {
        setCursorStyle(null); // Default to crosshair/none for drawing
      }
    }



    setEraserPos({ x, y })


    // --- SELECTION OVERRIDE LOGIC ---
    // If not in selection mode, but we have items selected, check if we are interacting with them.
    let overrideToSelection = false;
    // We only check for override on the initial CLICK.
    // However, if we are DRAGGING (buttons=1, not firstHit), we need to know if we are in an override state!
    // But selectionState.current handles that once started.
    // The issue is: on Move, 'firstHit' is false. overrideToSelection becomes false.
    // But 'selectionState.current' should preserve the state.

    if (!selectionMode && selectedStrokeIds.length > 0 && e.buttons === 1 && firstHit) {
      const selectedStrokes = strokes.filter(s => selectedStrokeIds.includes(s.id));
      const bounds = getStrokesBoundingBox(selectedStrokes);

      // Check interaction
      if (bounds) {
        if (hitTestResizeHandle({ x, y }, bounds, zoom)) {
          overrideToSelection = true;
        } else if (isPointInRect({ x, y }, bounds)) {
          overrideToSelection = true;
        }
      }
    }

    // Also, if we are ALREADY interacting (dragging), we treat it as selection mode effectively.
    if (!selectionMode && selectionState.current !== 'IDLE') {
      overrideToSelection = true;
    }

    // --- SELECTION MODE LOGIC ---
    if (selectionMode || overrideToSelection || marqueeMode) {
      if (e.buttons !== 1) {
        return;
      }

      if (firstHit) {
        // MOUSE DOWN
        pointerDownPos.current = { x, y };
        setActiveSnappingGuides([]);

        // PRIORITY: Marquee Mode (Force Box Selection)
        if (marqueeMode) {
          selectionState.current = 'DRAGGING_SELECTION_BOX';
          // Clear selection unless Shift/Ctrl
          if (!e.ctrlKey && !e.shiftKey) {
            setSelectedStrokeIds([]);
            setMarqueeBox(null);
          }
          return;
        }

        // 0. Check Resize Handles FIRST
        if (selectedStrokeIds.length > 0) {
          const selectedStrokes = strokes.filter(s => selectedStrokeIds.includes(s.id));
          const bounds = getStrokesBoundingBox(selectedStrokes);
          if (bounds) {
            const handle = hitTestResizeHandle({ x, y }, bounds, zoom);
            if (handle) {
              selectionState.current = 'RESIZING';
              resizeHandleRef.current = handle;
              initialResizeBoundsRef.current = bounds;
              initialResizeStrokesRef.current = JSON.parse(JSON.stringify(selectedStrokes));
              return; // Stop here, we are resizing
            }
          }
        }

        // 0.5 Check for specific hit stroke FIRST
        let hitStrokeId: string | null = null;
        for (let i = strokes.length - 1; i >= 0; i--) {
          if (hitTestStroke({ x, y }, strokes[i], zoom)) {
            hitStrokeId = strokes[i].id;
            break;
          }
        }

        // 1. Check inside selection
        let clickedInsideSelection = false;
        if (selectedStrokeIds.length > 0) {
          const selectedStrokes = strokes.filter(s => selectedStrokeIds.includes(s.id));
          const bounds = getStrokesBoundingBox(selectedStrokes);
          if (bounds && isPointInRect({ x, y }, bounds)) {
            if (!e.ctrlKey && !e.shiftKey) {
              clickedInsideSelection = true;
              selectionState.current = 'POINTER_DOWN_ON_STROKE';
              // Store hit stroke even if inside selection, for single-click selection
              hitStrokeIdRef.current = hitStrokeId;
              initialSelectedIds.current = [...selectedStrokeIds];
            }
          }
        }

        // If we clicked inside selection (or resize handle), we are interacting with selection.
        if (clickedInsideSelection) {
          return; // Consumed event
        }

        // If we are overriding (Hybrid Mode) and we didn't click inside selection or resize handle:
        if (overrideToSelection && !selectionMode) {
          // Fall through to drawing logic
          // do NOT return
        } else {
          // Normal Selection Mode behavior: Check for other strokes to select
          if (hitStrokeId) {
            selectionState.current = 'POINTER_DOWN_ON_STROKE';
            hitStrokeIdRef.current = hitStrokeId;
            const isSelected = selectedStrokeIds.includes(hitStrokeId);
            const isModifier = e.ctrlKey || e.shiftKey;

            if (isModifier) {
              initialSelectedIds.current = [...selectedStrokeIds];
            } else {
              if (isSelected) {
                initialSelectedIds.current = [...selectedStrokeIds];
              } else {
                initialSelectedIds.current = [hitStrokeId];
                setSelectedStrokeIds([hitStrokeId]);
              }
            }
          } else {
            selectionState.current = 'POINTER_DOWN_ON_EMPTY';
            initialSelectedIds.current = [...selectedStrokeIds];
          }
        }
        return;
      } else {
        // MOUSE MOVE
        if (!pointerDownPos.current) return;

        const dx = x - pointerDownPos.current.x;
        const dy = y - pointerDownPos.current.y;

        // --- RESIZING ---
        if (selectionState.current === 'RESIZING') {
          const handle = resizeHandleRef.current;
          const initBounds = initialResizeBoundsRef.current;
          if (!handle || !initBounds) return;

          // Anchor logic
          let anchorX = 0, anchorY = 0;
          if (handle === 'nw') { anchorX = initBounds.maxX; anchorY = initBounds.maxY; }
          else if (handle === 'ne') { anchorX = initBounds.minX; anchorY = initBounds.maxY; }
          else if (handle === 'se') { anchorX = initBounds.minX; anchorY = initBounds.minY; }
          else if (handle === 'sw') { anchorX = initBounds.maxX; anchorY = initBounds.minY; }

          // Re-calculate original handle pos
          let origX = (handle == 'nw' || handle == 'sw') ? initBounds.minX : initBounds.maxX;
          let origY = (handle == 'nw' || handle == 'ne') ? initBounds.minY : initBounds.maxY;

          const oldW = Math.abs(origX - anchorX);
          const oldH = Math.abs(origY - anchorY);

          // Current bounds width/height
          // We use the pointer position x, y as the new handle position
          const newW = Math.abs(x - anchorX);
          const newH = Math.abs(y - anchorY);

          const scaleX = oldW > 0.01 ? newW / oldW : 1;
          const scaleY = oldH > 0.01 ? newH / oldH : 1;

          const updatedStrokes = strokes.map(s => {
            const initStroke = initialResizeStrokesRef.current.find(is => is.id === s.id);
            if (initStroke) {
              if (s.text !== undefined) {
                // Resize Text: Scale font size and move X position only
                // Keep Y position fixed - text only scales horizontally

                const newPoints = initStroke.points.map(p => ({
                  ...p,
                  // Move X position with anchor, keep Y fixed
                  x: anchorX + (p.x - anchorX) * scaleX,
                  y: p.y, // Keep Y position fixed
                  // Scale font size proportionally
                  size: Math.max(8, p.size * scaleX)
                }));

                return {
                  ...s,
                  points: newPoints
                }
              }

              return {
                ...s,
                points: initStroke.points.map(p => ({
                  ...p,
                  x: anchorX + (p.x - anchorX) * scaleX,
                  y: anchorY + (p.y - anchorY) * scaleY,
                  size: p.size * ((scaleX + scaleY) / 2) // Approximate size scaling
                }))
              };
            }
            return s;
          });
          setStrokes(updatedStrokes);
          return;
        }

        // --- DRAG / BOX SELECT ---
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (selectionState.current === 'POINTER_DOWN_ON_STROKE' || selectionState.current === 'POINTER_DOWN_ON_EMPTY') {
          if (dist > 5 / zoom) {
            if (selectionState.current === 'POINTER_DOWN_ON_STROKE') {
              selectionState.current = 'DRAGGING_STROKES';
            } else {
              if (selectionMode && !overrideToSelection) {
                selectionState.current = 'DRAGGING_SELECTION_BOX';
              }
            }
          }
        }

        if (selectionState.current === 'DRAGGING_STROKES') {
          // Snapping Logic
          if (snappingEnabled) {
            const movingStrokes = strokes.filter(s => selectedStrokeIds.includes(s.id));
            const otherStrokes = strokes.filter(s => !selectedStrokeIds.includes(s.id));

            const { dx: snappedDx, dy: snappedDy, guides } = getSnappingGuides(movingStrokes, otherStrokes, { x: dx, y: dy }, zoom);

            setDragOffset({ x: snappedDx, y: snappedDy });
            setActiveSnappingGuides(guides);
          } else {
            setDragOffset({ x: dx, y: dy });
            setActiveSnappingGuides([]);
          }
          return; // Consumed drag
        } else if (selectionState.current === 'DRAGGING_SELECTION_BOX') {
          const start = pointerDownPos.current!;
          const minX = Math.min(start.x, x);
          const minY = Math.min(start.y, y);
          const width = Math.abs(start.x - x);
          const height = Math.abs(start.y - y);
          setSelectionBox({ x: minX, y: minY, width, height });
          return; // Consumed drag
        }

        // Return if consuming interaction
        if (selectionMode || overrideToSelection) return;
      }
    }
    // ----------------------------

    if (e.buttons !== 1) {
      startPoint.current = null;
      return
    }

    if (erasing !== ErasingMode.DISABLED) {
      if (erasing == ErasingMode.FULL) {
        const newStrokes = eraseStroke(x, y, brushSize, strokes)
        if (newStrokes) setStrokes(newStrokes)
      } else {
        // For partial erase, use smaller radius for finer control
        const newStrokes = eraseStokePoint(x, y, brushSize / 2, strokes)
        if (newStrokes) setStrokes(newStrokes)
      }
      return
    }

    if (fillMode) {
      if (!firstHit) return;


      // Find hit stroke (Check inside first, then partial hit if needed?)
      // We prioritize "inside" hits for closed shapes.
      // We iterate structure topmost first? (reverse index)
      let targetStrokeId: string | null = null;

      for (let i = strokes.length - 1; i >= 0; i--) {
        const s = strokes[i];
        if (s.points.length < 3) continue;

        // Check if closed (visually)
        const start = s.points[0];
        const end = s.points[s.points.length - 1];
        const dist = Math.sqrt(Math.pow(start.x - end.x, 2) + Math.pow(start.y - end.y, 2));
        // Actually generateShapePoints may not repeat the first point.
        // Let's assume visual closure is enough or strict closure.

        // Raycasting works best if the polygon is effectively closed.
        // If we treat the points as a polygon, the edge (last -> first) is implied.

        if (isPointInPolygon({ x, y }, s.points)) {
          targetStrokeId = s.id;
          break;
        }

        // Also check edge hit as fallback?
        if (hitTestStroke({ x, y }, s, zoom)) {
          targetStrokeId = s.id;
          break;
        }
      }

      if (targetStrokeId) {
        const newStrokes = strokes.map(s => {
          if (s.id === targetStrokeId) {
            // Update Fill AND Outline Color
            return {
              ...s,
              fill: brushColor,
              points: s.points.map(p => ({ ...p, color: brushColor }))
            };
          }
          return s;
        });
        setStrokes(newStrokes);
        setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), newStrokes]);
        setHistoryIndex(prev => prev + 1);
      } else {
        console.log("No shape found to fill at", x, y);
      }
      return;
    }

    if (activeShape) {
      if (firstHit) {
        // Start Drawing a Shape
        startPoint.current = { x, y };
        setCurrentPoints([{ x, y, color: brushColor, size: brushSize }]);
        setActiveSnappingGuides([]); // Reset guides

        // If we click to draw, we should Deselect others
        setSelectedStrokeIds([]);

      } else if (startPoint.current) {
        let endX = x;
        let endY = y;

        // Snapping while drawing
        if (snappingEnabled) {
          const tempPoints = generateShapePoints(startPoint.current, { x, y }, activeShape, brushSize, brushColor);
          const tempStroke: StrokeData = { id: 'temp', points: tempPoints };
          const { guides, dx, dy } = getSnappingGuides([tempStroke], strokes, { x: 0, y: 0 }, zoom);

          endX += dx;
          endY += dy;
          setActiveSnappingGuides(guides);
        }

        const points = generateShapePoints(startPoint.current, { x: endX, y: endY }, activeShape, brushSize, brushColor);
        setCurrentPoints(points);
      }
      return;
    }



    // --- TEXT TOOL LOGIC ---
    if (textMode && firstHit && e.buttons === 1) {
      // If we click on an existing text, we might want to edit it?
      // Let's check hit test first.
      let hitTextId = null;
      // Check top-most text
      for (let i = strokes.length - 1; i >= 0; i--) {
        const s = strokes[i];
        if (s.text && hitTestStroke({ x, y }, s, zoom)) {
          hitTextId = s.id;
          break;
        }
      }

      if (hitTextId) {
        // Clicked on an existing text field

        // First, clean up current editing session if any
        if (editingTextId && editingTextId !== hitTextId) {
          const currentTextStroke = strokes.find(s => s.id === editingTextId);
          if (currentTextStroke && (!currentTextStroke.text || currentTextStroke.text.trim() === '')) {
            setStrokes(prev => prev.filter(s => s.id !== editingTextId));
          }
          setEditingTextId(null);
        }

        // Check if this text is already selected
        const isAlreadySelected = selectedStrokeIds.includes(hitTextId);

        if (isAlreadySelected && !editingTextId) {
          // Second click on already-selected text -> enter edit mode
          setEditingTextId(hitTextId);
        } else if (!isAlreadySelected) {
          // First click -> select only (no edit)
          setSelectedStrokeIds([hitTextId]);
          setEditingTextId(null); // Make sure not editing
        }
        // If clicking same text we're already editing, do nothing (stay in edit)

      } else {
        // Clicked empty space

        // Clean up empty text if we were editing, then just unfocus (don't create new)
        if (editingTextId) {
          const currentTextStroke = strokes.find(s => s.id === editingTextId);
          if (currentTextStroke && (!currentTextStroke.text || currentTextStroke.text.trim() === '')) {
            setStrokes(prev => prev.filter(s => s.id !== editingTextId));
          }
          setEditingTextId(null);
          setSelectedStrokeIds([]); // Also deselect
          return; // Just unfocus, don't create new text
        }

        // If we have a selection, deselect it and RETURN (Do not create new text yet)
        if (selectedStrokeIds.length > 0) {
          setSelectedStrokeIds([]);
          return;
        }

        // No selection, no editing - create new text field
        const newId = crypto.randomUUID();
        const newStroke: StrokeData = {
          id: newId,
          points: [{ x, y, color: brushColor, size: 24 }], // Point 0 is origin, use fixed 24px font
          text: "", // Empty start
          width: 300,
          height: 150
        };

        setStrokes(prev => [...prev, newStroke]);
        setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), [...strokes, newStroke]]);
        setHistoryIndex(prev => prev + 1);

        setSelectedStrokeIds([]); // DO NOT select it initially, just edit
        setEditingTextId(newId);
        // We stay in text mode.
      }
      return;
    }

    if (textMode) return;

    if (firstHit) {
      setCurrentPoints([{ x, y, color: brushColor, size: brushSize }])
      setSelectedStrokeIds([]); // Deselect on freehand drawing too
      return
    }

    setCurrentPoints(prev => {
      const last = prev[prev.length - 1]

      if (last) {
        const dist = Math.sqrt(Math.pow(last.x - x, 2) + Math.pow(last.y - y, 2))
        if (dist < 1 / zoom) return prev
      }

      if (!last || last.x !== x || last.y !== y) {
        return [...prev, { x, y, color: brushColor, size: brushSize }]
      }
      return prev
    })

  }, [zoom, offset, drawingEnabled, erasing, brushColor, brushSize, strokes, setStrokes, setCurrentPoints, activeShape, selectionMode, selectedStrokeIds, setSelectedStrokeIds, snappingEnabled, fillMode, marqueeMode, textMode, editingTextId])

  const handlePointerUp = useCallback((e: React.PointerEvent<SVGSVGElement>) => {
    if (!drawingEnabled) { return }
    try { e.currentTarget.releasePointerCapture(e.pointerId) } catch { }

    setActiveSnappingGuides([]); // Clear guides

    // Handle Selection State Transitions
    if (selectionState.current !== 'IDLE') {
      if (selectionState.current === 'RESIZING') {
        setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), strokes]);
        setHistoryIndex(prev => prev + 1);
        resizeHandleRef.current = null;
        initialResizeBoundsRef.current = null;
        initialResizeStrokesRef.current = [];
      }
      else if (selectionState.current === 'DRAGGING_STROKES') {
        if (dragOffset) {
          const newStrokes = strokes.map(s => {
            if (selectedStrokeIds.includes(s.id)) {
              return {
                ...s,
                points: s.points.map(p => ({ ...p, x: p.x + dragOffset.x, y: p.y + dragOffset.y }))
              };
            }
            return s;
          });
          setStrokes(newStrokes);
          setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), newStrokes]);
          setHistoryIndex(prev => prev + 1);
        }
        setDragOffset(null);
      } else if (selectionState.current === 'DRAGGING_SELECTION_BOX') {
        if (selectionBox) {
          if (marqueeMode) {
            // Persist the box for Export
            setMarqueeBox(selectionBox);
            // DO NOT select strokes. This is purely for export cropping.
            // Ensure no selection is active to avoid confusion
            setSelectedStrokeIds([]);
          } else {
            const newSelection = strokes.filter(s => isStrokeInRect(s, selectionBox)).map(s => s.id);
            if (e.ctrlKey || e.shiftKey) {
              const combined = new Set(selectedStrokeIds);
              newSelection.forEach(id => {
                if (combined.has(id)) combined.delete(id);
                else combined.add(id);
              });
              setSelectedStrokeIds(Array.from(combined));
            } else {
              setSelectedStrokeIds(newSelection);
            }
          }
        }
        setSelectionBox(null);
      } else if (selectionState.current === 'POINTER_DOWN_ON_STROKE') {
        // It was just a click
        if (e.ctrlKey || e.shiftKey) {
          if (hitStrokeIdRef.current) {

            // Toggle selection
            const idToToggle = hitStrokeIdRef.current;
            if (selectedStrokeIds.includes(idToToggle)) {
              setSelectedStrokeIds(prev => prev.filter(pid => pid !== idToToggle));
            } else {
              setSelectedStrokeIds(prev => [...prev, idToToggle]);
            }
          }
        } else {
          // Simple Click without modifier -> Select ONLY this one 
          if (hitStrokeIdRef.current) {
            setSelectedStrokeIds([hitStrokeIdRef.current]);

            // Check if it is TEXT
            const clickedStroke = strokes.find(s => s.id === hitStrokeIdRef.current);
            if (clickedStroke?.text !== undefined) {
              // If we are in Text Mode OR Selection Mode, allow editing?
              // User said: "clicking on it again makes us edit it again"
              // If it's selected, and we click it again...
              if (initialSelectedIds.current.includes(hitStrokeIdRef.current)) {
                setEditingTextId(hitStrokeIdRef.current);
              } else {
                // First click selects it (already done above).
                // Maybe we only edit if Text Mode?
                // User said: "clicking outside makes us untoggle... clicking on it again makes us edit"
                // Logic: If already selected, enter edit mode.

                // Actually, if we are in text mode, maybe first click edits?
                if (textMode) setEditingTextId(hitStrokeIdRef.current);
              }
            }
          }
        }
      } else if (selectionState.current === 'POINTER_DOWN_ON_EMPTY') {
        setSelectedStrokeIds([]);
        // Clicked empty: Commit text if editing
        setEditingTextId(null);
      }

      selectionState.current = 'IDLE';
      pointerDownPos.current = null;
      hitStrokeIdRef.current = null;

      return;
    }

    if (erasing) {
      setStrokeHistory(prev => {
        const base = prev.slice(0, historyIndex + 1)
        return [...base, strokes]
      })
      setHistoryIndex(prev => prev + 1)
      return
    }

    if (activeShape || !selectionMode) {
      // We might have just finished drawing.
      if (currentPoints.length > 1) {
        const newId = crypto.randomUUID();
        setStrokeHistory(prev => {
          const base = prev.slice(0, historyIndex + 1)
          const currentSnapshot = prev[historyIndex] || []
          const newSnapshot = [...currentSnapshot, {
            id: newId,
            points: currentPoints,
            lineStyle: lineStyle, // Apply current line style
          }]
          return [...base, newSnapshot]
        });
        setHistoryIndex(prev => prev + 1)

        // Auto-Select the new stroke!
        setSelectedStrokeIds([newId]);
        setCurrentPoints([])
        return;
      }
      setCurrentPoints([])
    }
  }, [drawingEnabled, erasing, strokes, currentPoints, historyIndex, setStrokeHistory, setHistoryIndex, setCurrentPoints, selectionMode, selectedStrokeIds, setSelectedStrokeIds, selectionBox, dragOffset, lineStyle])

  return {
    handleDrawing,
    handlePointerUp,
    selectionBox,
    dragOffset,
    activeSnappingGuides,
    cursorStyle,
    editingTextId,
    setEditingTextId
  }
}
</file>

<file path="src/sandbox/_functions/drawing/useKeyboardShortcuts.ts">
import { useEffect, useRef } from "react";
import { useDrawing, StrokeData } from "src/sandbox/_providers/DrawingContextProvider";
import { useGrid } from "src/sandbox/_providers/GridContextProvider";

export function useKeyboardShortcuts() {
  const {
    setHistoryIndex,
    historyIndex,
    strokeHistory,
    setStrokes,
    selectedStrokeIds,
    setSelectedStrokeIds,
    setStrokeHistory,
    strokes,
    drawingEnabled
  } = useDrawing();

  const { zoom } = useGrid();

  const mousePosRef = useRef<{ x: number; y: number } | null>(null);

  // Track mouse position for paste offset
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (drawingEnabled) {
        mousePosRef.current = { x: e.clientX, y: e.clientY };
      }
    };
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, [drawingEnabled]);

  useEffect(() => {
    if (!drawingEnabled) return;

    const handleKeyDown = async (e: KeyboardEvent) => {
      // Don't interfere with text input
      const activeEl = document.activeElement;
      const isTyping = activeEl instanceof HTMLTextAreaElement || activeEl instanceof HTMLInputElement;

      // Undo: Ctrl + Z (only if not typing - let browser handle native undo in text fields)
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !isTyping) {
        e.preventDefault();
        setHistoryIndex(prev => {
          const newIndex = Math.max(0, prev - 1);
          return newIndex;
        });
      }

      // Redo: Ctrl + Y or Ctrl + Shift + Z (only if not typing)
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey)) && !isTyping) {
        e.preventDefault();
        setHistoryIndex(prev => {
          const newIndex = Math.min(strokeHistory.length - 1, prev + 1);
          return newIndex;
        });
      }

      // Delete: Delete or Backspace (only if not typing)
      if ((e.key === 'Delete' || e.key === 'Backspace') && !isTyping) {
        if (selectedStrokeIds.length > 0) {
          e.preventDefault();
          // Delete selected strokes
          const newStrokes = strokes.filter(s => !selectedStrokeIds.includes(s.id));
          setStrokes(newStrokes);
          setSelectedStrokeIds([]);

          // Add to history
          setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), newStrokes]);
          setHistoryIndex(prev => prev + 1);
        }
      }

      // Copy: Ctrl+C
      if ((e.ctrlKey || e.metaKey) && e.key === 'c' && !isTyping) {
        const selected = strokes.filter(s => selectedStrokeIds.includes(s.id));
        if (selected.length > 0) {
          const json = JSON.stringify(selected);
          try {
            await navigator.clipboard.writeText(json);
            console.log("Copied strokes to clipboard");
          } catch (err) {
            console.error("Failed to copy:", err);
          }
        }
      }

      // Cut: Ctrl+X
      if ((e.ctrlKey || e.metaKey) && e.key === 'x' && !isTyping) {
        const selected = strokes.filter(s => selectedStrokeIds.includes(s.id));
        if (selected.length > 0) {
          const json = JSON.stringify(selected);
          try {
            await navigator.clipboard.writeText(json);
            // Delete
            const newStrokes = strokes.filter(s => !selectedStrokeIds.includes(s.id));
            setStrokes(newStrokes);
            setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), newStrokes]);
            setHistoryIndex(prev => prev + 1);
            setSelectedStrokeIds([]);
          } catch (err) {
            console.error("Failed to cut:", err);
          }
        }
      }

      // Paste: Ctrl+V
      if ((e.ctrlKey || e.metaKey) && e.key === 'v' && !isTyping) {
        try {
          const text = await navigator.clipboard.readText();
          if (!text) return;

          let pastedData: StrokeData[];
          try {
            pastedData = JSON.parse(text);
          } catch { return; } // Not stroke data

          if (!Array.isArray(pastedData)) return;

          // Validate structure loosely
          const valid = pastedData.every(s => s.points && Array.isArray(s.points));
          if (!valid) return;

          // Offset and ID regen
          // Use mouse position if available, otherwise offset slightly
          let offsetX = 20 / zoom;
          let offsetY = 20 / zoom;

          if (mousePosRef.current) {
            // Calculate center of pasted strokes
            let minX = Infinity, minY = Infinity;
            for (const s of pastedData) {
              for (const p of s.points) {
                if (p.x < minX) minX = p.x;
                if (p.y < minY) minY = p.y;
              }
            }
            if (minX !== Infinity) {
              offsetX = mousePosRef.current.x - minX;
              offsetY = mousePosRef.current.y - minY;
            }
          }

          const newIds: string[] = [];

          const newStrokesToAdd = pastedData.map(s => {
            const newId = crypto.randomUUID();
            newIds.push(newId);
            return {
              ...s,
              id: newId,
              points: s.points.map(p => ({
                ...p,
                x: p.x + offsetX,
                y: p.y + offsetY
              }))
            }
          });

          const newStrokes = [...strokes, ...newStrokesToAdd];
          setStrokes(newStrokes);
          setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), newStrokes]);
          setHistoryIndex(prev => prev + 1);
          setSelectedStrokeIds(newIds);

        } catch (err) {
          console.error("Failed to paste:", err);
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [drawingEnabled, historyIndex, strokeHistory, selectedStrokeIds, strokes, zoom, setHistoryIndex, setStrokes, setSelectedStrokeIds, setStrokeHistory]);
}
</file>

<file path="src/sandbox/_functions/grid/onMouseMove.ts">
import { useEffect } from "react";
import { useGrid } from "../../_providers/GridContextProvider";
import { useDrawing } from "../../_providers/DrawingContextProvider";
import { useBuilderPanel } from "../../_providers/BuilderPanelContextProvider";

export default function useOnMouseMove() {

  const { 
    draggingRef, 
    lastPos, 
    setOffset 
  } = useGrid();

  const { 
    lastPositionWindowDivider, 
    windowDividerDragging 
  } = useBuilderPanel();

  const handleMouseMove = (e: MouseEvent) => {
    if (!draggingRef.current) return;
    
    const dx = e.clientX - lastPos.current.x;
    const dy = e.clientY - lastPos.current.y;
    lastPos.current = { x: e.clientX, y: e.clientY };
    setOffset(prev => ({ x: prev.x + dx, y: prev.y + dy }));
  };

  useEffect(() => {
    const rightPanel = document.getElementById("rightPanel");
    if (!rightPanel) { return; }

    const leftPanel = document.getElementById("leftPanel");
    if (!leftPanel) { return; }

    const handleMouseMove = (e: MouseEvent) => {
      if (!windowDividerDragging.current) return;

      const dx = e.clientX - lastPositionWindowDivider.current;
      const containerWidth = window.innerWidth;
      const newPosition = ((lastPositionWindowDivider.current + dx) / containerWidth) * 100;

      lastPositionWindowDivider.current = e.clientX;

      rightPanel.style.width = `${100 - newPosition}%`;
      leftPanel.style.width = `${newPosition}%`;
    }

    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, [])

  return { handleMouseMove };
}
</file>

<file path="src/sandbox/_functions/notes/getCaretPosition.ts">
import { Editor } from '@tiptap/react';

export interface CaretPosition {
  absoluteY: number;
  viewportPercentage: number;
  absoluteX: number;
  viewportPercentageX: number;
  isInViewport: boolean;
  offset: number;
  offsetNode: Node;
  getClientRect: () => DOMRect;
}

export function getCaretPosition(editor: Editor | null): CaretPosition | null {
  if (!editor) {
    return null;
  }

  const { view, state } = editor;
  const { selection } = state;

  const { from } = selection;

  try {
    const coords = view.coordsAtPos(from);

    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;

    const viewportPercentage = (coords.top / viewportHeight) * 100;
    const viewportPercentageX = (coords.left / viewportWidth) * 100;

    const isInViewport =
      coords.top >= 0 &&
      coords.top <= viewportHeight &&
      coords.left >= 0 &&
      coords.left <= viewportWidth;

    const domAtPos = view.domAtPos(from);
    const offsetNode = domAtPos.node;

    return {
      absoluteY: coords.top,
      viewportPercentage: Math.max(0, Math.min(100, viewportPercentage)),
      absoluteX: coords.left,
      viewportPercentageX: Math.max(0, Math.min(100, viewportPercentageX)),
      isInViewport,
      offset: from,
      offsetNode: offsetNode,
      getClientRect: () => {
        return new DOMRect(coords.left, coords.top, 0, coords.bottom - coords.top);
      },
    };
  } catch (error) {
    console.error('Error getting caret position:', error);
    return null;
  }
}
</file>

<file path="src/sandbox/_functions/notes/handleCaretPosition.ts">
import { useGrid } from "src/sandbox/_providers/GridContextProvider";
import { CaretPosition } from "./getCaretPosition";

export const handleCaretPositionChange = () => {

  const {
    setOffset
  } = useGrid();

  return (position: CaretPosition | null) => {
    if (!position) { return; }

    setOffset(prev => {
      let newY = prev.y;
      const absoluteY = position.absoluteY;
      const windowHeight = window.innerHeight;
      if (absoluteY > windowHeight * 0.65) {
        const remaining = (windowHeight * 0.65) - absoluteY;
        newY = prev.y + remaining;
      } else if (absoluteY < windowHeight * 0.35) {
        const remaining = (windowHeight * 0.35) - absoluteY;
        newY = prev.y + remaining;
      }
      return { ...prev, y: newY };
    })
  }
};
</file>

<file path="src/sandbox/_functions/notes/PlaceholderPerLine.ts">
import { Extension } from '@tiptap/core'
import { Plugin, PluginKey } from '@tiptap/pm/state'
import { Decoration, DecorationSet } from '@tiptap/pm/view'

export const PlaceholderPerLine = Extension.create({
  name: 'placeholderPerLine',

  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey('placeholderPerLine'),
        props: {
          decorations: (state) => {
            const { doc, selection } = state
            const decorations: Decoration[] = []

            const { $anchor } = selection

            doc.descendants((node, pos) => {
              const isCursorInNode = pos <= $anchor.pos && $anchor.pos <= pos + node.nodeSize

              if (
                node.isTextblock &&
                node.content.size === 0 &&
                isCursorInNode
              ) {
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: 'is-empty-with-placeholder',
                  'data-placeholder': 'Type / for commands',
                })
                decorations.push(decoration)
              }
            })

            return DecorationSet.create(doc, decorations)
          },
        },
      }),
    ]
  },
})
</file>

<file path="src/sandbox/_providers/CodeContextProvider.tsx">
import { createContext, useContext, useState, ReactNode, SetStateAction, Dispatch, useEffect } from 'react';
import { codeContext } from '../types/blueprints';
import * as monaco from 'monaco-editor';

type CodeContextType = {
  codeWindows: codeContext[];
  setCodeWindows: Dispatch<SetStateAction<codeContext[]>>;

  activeCodeWindow: string | null;
  setActiveCodeWindow: Dispatch<SetStateAction<string | null>>;

  codeWindowSize: number;
  setCodeWindowSize: Dispatch<SetStateAction<number>>;

  currentMonacoInstance: typeof monaco | null;
  setCurrentMonacoInstance: Dispatch<SetStateAction<typeof monaco | null>>;

  currentEditorInstance: monaco.editor.IStandaloneCodeEditor | null;
  setCurrentEditorInstance: Dispatch<SetStateAction<monaco.editor.IStandaloneCodeEditor | null>>;
};

const CodeContext = createContext<CodeContextType | undefined>(undefined);

export const CodeProvider = ({ children }: { children: ReactNode }) => {
  const [codeWindows, setCodeWindows] = useState<codeContext[]>([]);
  const [activeCodeWindow, setActiveCodeWindow] = useState<string | null>(null);
  const [codeWindowSize, setCodeWindowSize] = useState<number>(16);
  const [currentMonacoInstance, setCurrentMonacoInstance] = useState<typeof monaco | null>(null);
  const [currentEditorInstance, setCurrentEditorInstance] = useState<monaco.editor.IStandaloneCodeEditor | null>(null);

  useEffect(() => {
    let size = codeWindowSize;
    if (codeWindowSize < 6) {
      setCodeWindowSize(6);
      size = 6;
    } else if (codeWindowSize > 100) {
      setCodeWindowSize(100);
      size = 100;
    }
    currentEditorInstance?.updateOptions({ fontSize: size });
  }, [codeWindowSize])

  return (
    <CodeContext.Provider value={{ 
      codeWindows, 
      setCodeWindows,

      activeCodeWindow,
      setActiveCodeWindow,

      codeWindowSize,
      setCodeWindowSize,

      currentMonacoInstance,
      setCurrentMonacoInstance,

      currentEditorInstance,
      setCurrentEditorInstance
    }}>
      {children}
    </CodeContext.Provider>
  );
};

export const useCode = () => {
  const context = useContext(CodeContext);
  if (!context) {
    throw new Error('useCode must be used within a CodeProvider');
  }
  return context;
};
</file>

<file path="src/sandbox/_providers/MenusContextProvider.tsx">
import { createContext, useContext, useState, ReactNode, SetStateAction, Dispatch, useEffect, useRef } from 'react';
import { CreateComponentMenuVisibleState } from '../types/createComponentMenuTypes';

type MenusContextType = {
  createComponentMenuOpen: CreateComponentMenuVisibleState;
  setCreateComponentMenuOpen: Dispatch<SetStateAction<CreateComponentMenuVisibleState>>;

  createComponentMenuPosition: { x: number; y: number } | null;
  setCreateComponentMenuPosition: Dispatch<SetStateAction<{ x: number; y: number } | null>>;
};

const MenusContext = createContext<MenusContextType | undefined>(undefined);

export const MenusProvider = ({ children }: { children: ReactNode }) => {
  const [createComponentMenuOpen, setCreateComponentMenuOpen] = useState<CreateComponentMenuVisibleState>(CreateComponentMenuVisibleState.CLOSED);
  const [createComponentMenuPosition, setCreateComponentMenuPosition] = useState<{ x: number; y: number } | null>(null);

  useEffect(() => {

    if (!createComponentMenuPosition) { return; }

    const maxHeight = window.innerHeight;
    const maxWidth = window.innerWidth;
    const minHeight = 280; // value has no relation to menu height, just a comfortable min height
    const minWidth = 20; // value has no relation to menu width, just a comfortable min width

    const menuHeight = 312 / 2; // menu opens half up and half down from the cursor thats why half height
    const menuWidth = 288; // full width because it only opens to the right

    let newX = createComponentMenuPosition.x;
    let newY = createComponentMenuPosition.y;

    if (createComponentMenuPosition.x + menuWidth > maxWidth) {
      newX = maxWidth - menuWidth - 40;
    } else if (createComponentMenuPosition.y + menuHeight > maxHeight) {
      newY = maxHeight - menuHeight - 40;
    }

    if (createComponentMenuPosition && createComponentMenuPosition.x < minWidth) {
      newX = minWidth;
    } else if (createComponentMenuPosition && createComponentMenuPosition.y < minHeight) {
      newY = minHeight;
    }

    if (newX !== createComponentMenuPosition.x || newY !== createComponentMenuPosition.y) {
      setCreateComponentMenuPosition({ x: newX, y: newY });
    }

  }, [createComponentMenuPosition]);

  return (
    <MenusContext.Provider value={{ 
      createComponentMenuOpen, 
      setCreateComponentMenuOpen,

      createComponentMenuPosition, 
      setCreateComponentMenuPosition
    }}>
      {children}
    </MenusContext.Provider>
  );
};

export const useMenus = () => {
  const context = useContext(MenusContext);
  if (!context) {
    throw new Error('useMenus must be used within a MenusProvider');
  }
  return context;
};
</file>

<file path="src/sandbox/types/NotesOptionsTypes.ts">
import { faCode, faDivide, faHeading, faInfo, faListCheck, faListDots, faListNumeric, faParagraph } from "@fortawesome/free-solid-svg-icons";

export enum NoteOptions {
  PARAGRAPH = "Paragraph",
  HEADING1 = "Heading 1",
  HEADING2 = "Heading 2",
  HEADING3 = "Heading 3",
  UNORDERED_LIST = "Unordered List",
  ORDERED_LIST = "Ordered List",
  TASK_LIST = "Task List",
  DIVIDER = "Divider",
  HINT = "Hint",
  CODE_BLOCK = "Code Block",
}

export const NoteOptionsIcons: { [key in NoteOptions]: any } = {
  [NoteOptions.PARAGRAPH]: faParagraph,
  [NoteOptions.HEADING1]: faHeading,
  [NoteOptions.HEADING2]: faHeading,
  [NoteOptions.HEADING3]: faHeading,
  [NoteOptions.UNORDERED_LIST]: faListDots,
  [NoteOptions.ORDERED_LIST]: faListNumeric,
  [NoteOptions.TASK_LIST]: faListCheck,
  [NoteOptions.DIVIDER]: faDivide,
  [NoteOptions.HINT]: faInfo,
  [NoteOptions.CODE_BLOCK]: faCode,
}

export enum NoteOptionsVisibleState {
  OPEN = "OPEN",
  CLOSED = "CLOSED",
}

export const NoteOptionsCommands: { [key in NoteOptions]: (editor: any) => void } = {
  [NoteOptions.PARAGRAPH]: (editor) =>
    editor.chain().focus().setParagraph().run(),

  [NoteOptions.HEADING1]: (editor) =>
    editor.chain().focus().toggleHeading({ level: 1 }).run(),

  [NoteOptions.HEADING2]: (editor) =>
    editor.chain().focus().toggleHeading({ level: 2 }).run(),

  [NoteOptions.HEADING3]: (editor) =>
    editor.chain().focus().toggleHeading({ level: 3 }).run(),

  [NoteOptions.UNORDERED_LIST]: (editor) =>
    editor.chain().focus().toggleBulletList().run(),

  [NoteOptions.ORDERED_LIST]: (editor) =>
    editor.chain().focus().toggleOrderedList().run(),

  [NoteOptions.TASK_LIST]: (editor) =>
    editor.chain().focus().toggleTaskList().run(),

  [NoteOptions.DIVIDER]: (editor) =>
    editor.chain().focus().setHorizontalRule().run(),

  [NoteOptions.HINT]: (editor) =>
    // Assuming 'Hint' maps to Blockquote, or a custom node if you have one
    editor.chain().focus().toggleBlockquote().run(),

  [NoteOptions.CODE_BLOCK]: (editor) => {
    // Insert the code block
    editor.chain().focus().setCodeBlock({
      language: 'typescript',
      code: '\n\n\n\n\n\n\n\n\n\n'
    }).run();

    // Poll for Monaco editor to be registered and ready
    let attempts = 0;
    const maxAttempts = 20; // 2 seconds max

    const pollForMonaco = () => {
      attempts++;
      console.log(`🔍 [Auto-focus] Attempt ${attempts}/${maxAttempts}`);

      // The newly inserted code block is automatically selected by TipTap
      const selectedCodeBlock = document.querySelector('.code-block.selected');
      console.log('  Selected code block found:', !!selectedCodeBlock);

      if (!selectedCodeBlock) {
        if (attempts < maxAttempts) {
          setTimeout(pollForMonaco, 100);
        } else {
          console.log('  ❌ Code block never appeared');
        }
        return;
      }

      const monacoId = selectedCodeBlock.getAttribute('data-monaco-id');
      console.log('  Monaco ID:', monacoId);

      if (!monacoId) {
        if (attempts < maxAttempts) {
          setTimeout(pollForMonaco, 100);
        } else {
          console.log('  ❌ Monaco ID never assigned');
        }
        return;
      }

      const monacoEditor = (window as any).__monacoEditors?.[monacoId];
      console.log('  Monaco editor instance:', !!monacoEditor);

      if (monacoEditor) {
        monacoEditor.focus();
        console.log('  ✅ Monaco focused!');
      } else if (attempts < maxAttempts) {
        setTimeout(pollForMonaco, 100);
      } else {
        console.log('  ❌ Monaco editor never registered');
      }
    };

    setTimeout(pollForMonaco, 100);
  },
};
</file>

<file path="src/test/_api/testApi.ts">
import { PrismaClient } from '@prisma/client';
import { AuthProps, SessionLayout } from 'config';

interface Functions {
  prisma: PrismaClient;

  saveSession: (sessionId: string, data: any) => Promise<boolean>;
  getSession: (sessionId: string) => Promise<any | null>;
  deleteSession: (sessionId: string) => Promise<boolean>;

  tryCatch: <T, P>(func: (values: P) => Promise<T> | T, params?: P) => Promise<[any, T | null]>;

  [key: string]: any; // allows for other functions that are not defined as a type but do exist in the functions folder
};

interface ApiParams {
  data: Record<string, any>;
  functions: Functions;
  user: SessionLayout;
};


const auth: AuthProps = {
  login: true, //? checks if the session data has an id. 
  additional: [
    // { key: 'groupId', mustBeFalsy: false }, //? checks if the groupId is truethy, so if groupId is an empty string or 0 it will not pass
    // { key: 'admin', value: true }, //? checks if admin = true
    // { key: 'email', type: 'string' }, //? checks if the email is a string
    // { key: 'updatedAt', nullish: false } //? checks if the updatedAt is not null or undefined 
    //? you can perform certain checks with more than 1 condition but in the end they all have there own use case.
  ]
}

const main = async ({ data, functions, user }: ApiParams) => {
  console.log(data)
  console.log(user)
  console.log('you just called the randomApi.ts')
  return { status: 'success', result: { name: 'John' } }
}

export { auth, main }
</file>

<file path="src/test/page.tsx">
import { joinRoom } from "src/_sockets/socketInitializer";
import { useEffect } from 'react';
import notify from "src/_functions/notify";
import { setMenuHandlerRef } from "src/_functions/menuHandler";
import { syncRequest, useSyncEvents } from "src/_sockets/syncRequest";
import { apiRequest } from "src/_sockets/apiRequest";
import { useSession } from "src/_providers/SessionProvider";
import { useMenuHandler } from "src/_components/MenuHandler";
import { confirmDialog } from "src/_components/ConfirmMenu";

export const template = 'home';
export default function Home() {
  const { session } = useSession();

  useEffect(() => {
    joinRoom('test');
  }, [])

  const ref = useMenuHandler();
  setMenuHandlerRef(ref);

  const { upsertSyncEventCallback } = useSyncEvents();

  upsertSyncEventCallback('updateCounter', ({ serverData }) => {
    const counter = document.getElementById('counter');
    if (!counter) { return; }
    const count = parseInt(counter.innerText);
    counter.innerText = (serverData.increase ? count + 1 : count - 1).toString();
  })

  return (
    <div className="h-full flex flex-grow flex-col items-center justify-center gap-4">
      <button className="px-6 rounded-md cursor-pointer h-10 bg-pink-500 text-white" 
        onClick={() => { void syncRequest({ name: 'updateCounter', data: { product: 'shoes', increase: true }, receiver: 'test' }) }}>
        click me to increase shoes counter over all clients <strong>(sync request)!!</strong>
      </button>
      <button className="px-6 rounded-md cursor-pointer h-10 bg-pink-500 text-white" 
        onClick={() => { void syncRequest({ name: 'updateCounter', data: { product: 'shoes', increase: false }, receiver: 'test' }) }}>
        click me to decrease shoes counter over all clients <strong>(sync request)!!</strong>
      </button>
      <div className="shoesCounter bg-pink-500 p-2 rounded-md text-white">
        shoes: <strong id="counter">0</strong>
      </div>
      <button className="min-w-40 px-6  rounded-md cursor-pointer h-10 bg-green-500 text-white"
        onClick={() => { void apiRequest({ name: 'testApi' })}}>
          click me to call an testApi <strong>(check client and server console)</strong>
      </button>
      <button className="min-w-40 px-6 rounded-md cursor-pointer h-10 bg-orange-500 text-white"
        onClick={() => { void apiRequest({ name: 'logout' }) }}>
          logout
      </button>
      <button className="bg-purple-500 text-white rounded-md p-2 cursor-pointer"
        onClick={() => { notify.success({ key: 'test', params: [{ key: 'name', value: session?.name || 'loading' }] }) }}>
        Click me for a notification!!
      </button>
      <button 
        className="min-w-40 px-6 rounded-md cursor-pointer h-10 bg-primary text-white"
        onClick={() => {
          ref.open(
            <div className="p-4 gap-4 flex flex-col">

              <h2>Menu</h2>
              <button className="w-20 rounded-md cursor-pointer h-8 bg-red-500 text-white"
                onClick={() => { ref.close() }}
              >close</button>
              <button className="w-20 rounded-md cursor-pointer h-8 bg-red-500 text-white"
                onClick={() => { ref.open(
                  <div className="p-4 gap-4 flex flex-col">
                    <h2>Menu 2</h2>
                    <button className="w-20 rounded-md cursor-pointer h-8 bg-red-500 text-white"
                      onClick={() => { ref.close() }}
                    >close</button>
                    <button className="w-20 rounded-md cursor-pointer h-8 bg-red-500 text-white"
                      onClick={async () => {
                        const result = await confirmDialog({
                          title: 'test',
                          content: <p>test <strong>test2</strong></p>,
                          input: 'test'
                        })
                        console.log(`Confirm Dialog returned: ${result}`);
                      }}
                    >
                      open
                    </button>
                  </div>, { dimBackground: true, background: 'bg-orange-200', size:'sm'  }
                )}}
              >
                open
              </button>
            </div>, { dimBackground: true, background: 'bg-white', size: 'md' }
          )
        }}
      >
        click me to open external menu
      </button>
    </div>
  );
}
</file>

<file path="tailwind.config.js">
// tailwind.config.js
module.exports = {
  darkMode: "class",
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {}
    },
  },
  plugins: [
    require("@tailwindcss/container-queries"),
    require("@tailwindcss/typography"),
  ],
};
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import path from 'path';
// import tsconfigPaths from 'vite-tsconfig-paths'

// https://vite.dev/config/
export default defineConfig({
  base: '/',
  plugins: [
    react(),
    // tsconfigPaths()
  ],
  build: {
    rollupOptions: {
      external: (id) => { // this is just for the server side to tell these files will be available at runtime, to ignore files in build process go to tsconfig.app.json
        
        // Match if path includes /api/
        if (/\/api\//.test(id)) { return true; }
  
        // Ignore files in a sync folder ending with _server.ts
        if (/\/sync\/.*\/.*_server\.ts$/.test(id) || /\/sync\/.*_server\.ts$/.test(id)) { return true; }

        return false;
      },
    },
    target: 'esnext', // This makes sure the server redirects all 404s to index.html
  },
  resolve: {
    alias: {
      'src': path.resolve(__dirname, './src'),
      'config': path.resolve(__dirname, './config'),
    },
  },
  server: {
    watch: {
      usePolling: true,
      ignored: [
        "**/src/**/**/*{api,sync}/**"
      ]
    },
  },
})
</file>

<file path="src/_providers/SessionProvider.tsx">
import { dev, SessionLayout } from 'config';
import { createContext, useContext, useState, ReactNode, useEffect } from 'react';
import { apiRequest } from 'src/_sockets/apiRequest';
import { socket, useSocket } from 'src/_sockets/socketInitializer';

type UserContextType = {
  session: SessionLayout | null;
  // setSession: Dispatch<SetStateAction<SessionLayout | null>>;
  sessionLoaded: boolean;
};

let latestSession: SessionLayout | null = null;

const UserContext = createContext<UserContextType | undefined>(undefined);

export const SessionProvider = ({ children }: { children: ReactNode }) => {
  const [session, setSession] = useState<SessionLayout | null>(null);
  const [sessionLoaded, setSessionLoaded] = useState(false);
  useSocket(session); //? starts the socket connection

  useEffect(() => {
    console.log('jowjowjowj');
    latestSession = session;
  }, [session])

  useEffect(() => {
    (async () => {
      const response = await apiRequest({ name: 'session' }) as SessionLayout | null;
      setSession(response);
      setSessionLoaded(true);
    })()
  }, [])

  useEffect(() => {
    if (!socket) return;

    const handler = (data: string) => {
      if (dev) { console.log('updateSession', JSON.parse(data)); }
      const parsed = JSON.parse(data) as SessionLayout;
      setSession(prev => ({
        ...(prev as SessionLayout),
        ...parsed,
        avatar: parsed?.avatar + '?v=' + Date.now()
      }));
    }

    socket.on('updateSession', handler)

    return () => {
      if (!socket) return;
      socket.off('updateSession', handler);
    }
    
  // }, [socket])
  }, [])

  return (
    <UserContext.Provider value={{ session, sessionLoaded }}>
      {children}
    </UserContext.Provider>
  );
};

// 5. Create a custom hook for easier usage
export const useSession = () => {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useSession must be used within a SessionProvider');
  }
  return context;
};

export const getCurrentSession = () => latestSession;
</file>

<file path="src/_sockets/socketInitializer.ts">
import { toast } from "sonner";
import { io, Socket } from 'socket.io-client';
import config, { dev, backendUrl, SessionLayout } from "config";
import { useSocketStatus } from "../_providers/socketStatusProvider";
import { RefObject, useEffect, useRef } from "react";
import { initSyncRequest, useSyncEventTrigger } from "./syncRequest";

export let socket: Socket | null = null;

let responseIndex = 0;
export const incrementResponseIndex = () => {
  return responseIndex = responseIndex + 1;
}

export function useSocket(session: SessionLayout | null) {
  const { socketStatus, setSocketStatus } = useSocketStatus();
  const { triggerSyncEvent } = useSyncEventTrigger();
  const sessionRef = useRef(session);

  useEffect(() => {
    console.log('bamibamiba', session);
    sessionRef.current = session;
  }, [session])

  useEffect(() => {
    const socketOptions: any = {
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: Infinity,
      autoConnect: true,
      withCredentials: true,
      auth: {}
    };

    if (import.meta.env.VITE_SESSION_BASED_TOKEN === "true") {
      const token = sessionStorage.getItem("token");
      if (token) {
        socketOptions.auth = { token };
      }
    }

    socket = io(backendUrl, socketOptions);

    const handleVisibility = async () => {
      if (!config.socketActivityBroadcaster) { return; }

      console.log(document.visibilityState)
        if (!socket) { return; }

      //? user switched tab or navigated away
      if (document.visibilityState === "hidden") {
        socket.emit("intentionalDisconnect");

      //? user switched back to the tab
      } else if (document.visibilityState === "visible") {
        if (socketStatus.self.status !== "CONNECTED") { 
          socket.connect();
        }
        socket?.emit("intentionalReconnect");
      }
    };
    document.addEventListener("visibilitychange", handleVisibility);

    if (config.socketActivityBroadcaster) {
      initSyncRequest({
        socketStatus, 
        setSocketStatus,
        sessionRef: sessionRef as RefObject<SessionLayout>
      })
    } else {
      socket.on("connect", () => {
        console.log("Connected to server");
      });

      socket.on("disconnect", () => {
        console.log("Disconnected, trying to reconnect...");
      });

      socket.on("reconnect_attempt", (attempt) => {
        console.log(`Reconnecting attempt ${attempt}...`);
      });

      socket.on("connect_error", (err) => {
        if (dev) {
          console.error(`Connection error: ${err.message}`);
          toast.error(`Connection error: ${err.message}`);
        }
      });

    }
    
    socket.on("logout", (status: "success" | "error") => {
      if (status === "success") {
        if (import.meta.env.VITE_SESSION_BASED_TOKEN === "true") {
          sessionStorage.clear();
        }
        window.location.href = config.loginPageUrl;
      } else {
        console.error("Logout failed");
        toast.error("Logout failed");
      }
    });

    socket.on("sync", ({ cb, clientData, serverData, message, status }) => {
      const path = window.location.pathname;
      if (dev) console.log("Server Sync Response:", { cb, clientData, serverData, status, message });

      if (status === "error") {
        if (dev) {
          console.log(message);
          toast.error(message);
        }
        return;
      }

      triggerSyncEvent(`sync${path}/${cb}`, clientData, serverData);
    });


    return () => {
      if (socket) {
        socket.disconnect();
        socket = null;
        socket = null;
        setSocketStatus(prev => ({
        ...prev,
        self: {
          status: "DISCONNECTED",
          reconnectAttempt: undefined,
          endTime: undefined,
        }
      }));
      }

      document.removeEventListener("visibilitychange", handleVisibility)
    };

  }, []);

  return socket;
}


export const waitForSocket = async () => {

  let i = 0;
  while (!socket) {
    await new Promise((resolve) => setTimeout(resolve, 10));
    i++
    if (i > 500) { 
      if (dev) {
        console.error("Socket is not initialized, giving up");
        toast.error("Socket is not initialized, giving up");
      }
      return false 
    } //? we give it 500 * 10 so 5000ms or 5s to load the socket connection
  }

  return true
}

export const joinRoom = async (group: string) => {
  return new Promise(async (resolve) => {
    if (!group || typeof group!== "string") {
      if (dev) {
        console.error("Invalid group");
        toast.error("Invalid group");
      }
      return resolve(null);
    }
  
    if (!await waitForSocket()) { return resolve(null); }
    if (!socket) { return resolve(null); }
  
    const tempIndex = incrementResponseIndex();
    socket.emit('joinRoom', { group, responseIndex: tempIndex });
  
    socket.once(`joinRoom-${tempIndex}`, () => {
      return resolve(true);
    });
  })
}

export const updateLocationRequest = async ({ location }: {location: { pathName: string, searchParams: Record<string, string>, previousLocation: string | null }}) => {
  if (!location.pathName || !location.searchParams) {
    if (dev) {
      console.error("Invalid location");
      toast.error("Invalid location"); 
    }
    return null;
  }

  if (!await waitForSocket()) { return }
  if (!socket) { return null; }

  socket.emit('updateLocation', location);
}
</file>

<file path="src/sandbox/_components/drawing/DrawingTopMenu.tsx">
import { ErasingMode, useDrawing } from "src/sandbox/_providers/DrawingContextProvider";
import { useEffect, useState, useRef } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faEraser, faPencilAlt, faAlignCenter, faSquare, faCircle, faDiamond, faMousePointer, faSlash, faRulerCombined, faArrowRight, faFillDrip, faDownload, faObjectGroup, faFont } from "@fortawesome/free-solid-svg-icons";
import { clipStrokesToRect } from "src/sandbox/_functions/drawing/clipUtils";
import Tooltip from "src/_components/Tooltip";

export default function DrawingTopMenu() {

  const {
    drawingEnabled,
    erasing,
    setErasing,
    activeShape,
    setActiveShape,
    selectionMode,
    setSelectionMode,
    showMeasurements,
    setShowMeasurements,
    showDrawings,
    selectedStrokeIds,
    setSelectedStrokeIds,
    strokes,
    marqueeMode,
    setMarqueeMode,
    marqueeBox,
    setMarqueeBox,
    fillMode,
    setFillMode,
    textMode,
    setTextMode
  } = useDrawing();

  const [lastErasingMode, setLastErasingMode] = useState<ErasingMode>(ErasingMode.DISABLED);
  const [erasingOptionMenu, setErasingOptionMenu] = useState(false);
  const [exportMenuOpen, setExportMenuOpen] = useState(false);
  const [_, setOpenColorPicker] = useState(false);
  const colorPickerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (colorPickerRef.current && !colorPickerRef.current.contains(event.target as Node)) {
        setOpenColorPicker(false);
      }

      if (!(event.target as HTMLElement).closest('.drawingOptionMenu')) {
        setErasingOptionMenu(false);
        setExportMenuOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [])

  useEffect(() => {
    setActiveShape(null)
    setErasing(ErasingMode.DISABLED)
  }, [showDrawings])

  useEffect(() => {
    setLastErasingMode(erasing);
  }, [erasing]);

  return (
    <div 
      className={`
        absolute top-4 left-1/2 -translate-x-1/2 z-50 
        flex gap-4 select-none items-start text-text 
        transition-all duration-200 origin-top
        ${drawingEnabled ? 'opacity-100 scale-100' : 'opacity-0 scale-80'}
      `}
      onClick={(e) => {
        e.stopPropagation();
        e.preventDefault();
      }}
      onDragStart={(e) => e.preventDefault()}
    >
      <div className="bg-background2 border p-2 gap-2 flex border-border2 rounded-lg">
        {/* Selection Mode */}
        <Tooltip
          content={"Select Tool"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            className={`
              flex p-2 text-text border-b 
              ${selectionMode ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape(null)
              setSelectionMode(true)
              setFillMode(false)
              setTextMode(false)
              setMarqueeMode(false)
              setMarqueeBox(null)
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faMousePointer} size="xs" />
          </button>
        </Tooltip>

        {/* Area Select (Marquee) */}
        <Tooltip
          content={"Area Select (Marquee)"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            className={`
              flex p-2 text-text border-b 
              ${marqueeMode ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape(null)
              setSelectionMode(false)
              setFillMode(false)
              setTextMode(false)
              setMarqueeMode(true)
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faObjectGroup} size="xs" />
          </button>
        </Tooltip>
      </div>

      <div className="flex gap-2 p-2 bg-background2 border border-border2 rounded-lg">
        {/* Draw mode */}
        <Tooltip
          content={"Draw mode"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            className={`
              flex p-2 text-text border-b 
              ${!erasing && !activeShape && !selectionMode && !fillMode && !marqueeMode && !textMode ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape(null)
              setSelectionMode(false)
              setFillMode(false)
              setTextMode(false)
              setMarqueeMode(false)
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faPencilAlt} size="xs" />
          </button>
        </Tooltip>

        {/* Fill Tool */}
        <Tooltip
          content={"Fill Tool"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            className={`
              flex p-2 text-text border-b 
              ${fillMode ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape(null)
              setSelectionMode(false)
              setFillMode(true)
              setTextMode(false)
              setMarqueeMode(false)
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faFillDrip} size="xs" />
          </button>
        </Tooltip>

        <Tooltip
          content={"Text Tool"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            className={`
              flex p-2 text-text border-b 
              ${textMode ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape(null)
              setSelectionMode(false)
              setFillMode(false)
              setTextMode(true)
              setMarqueeMode(false)
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faFont} size="xs" />
          </button>
        </Tooltip>



        {/* Eraser with options */}
        <button
          className={`relative drawingOptionMenu`}
          onClick={() => {
            // if (lastErasingMode) {
            //   setErasing(lastErasingMode);
            //   setActiveShape(null);
            //   setSelectionMode(false);
            //   setFillMode(false);
            //   setMarqueeMode(false);
            //   setSelectedStrokeIds([]);
            //   setTextMode(false);
            // }
            setErasingOptionMenu(prev => !prev)
          }}
        >
          <Tooltip
            content={"Select erase mode"}
            offsetY={"100% - 12px"}
            offsetX={"50%"}
            className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
            condition={!erasingOptionMenu}
          >
            <div 
              className={`
                flex p-2 text-text border-b 
                ${erasing ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
              `}>
              <FontAwesomeIcon icon={lastErasingMode == ErasingMode.FULL ? faEraser : faAlignCenter} size="xs" />
            </div>
          </Tooltip>
          <div
            onClick={(e) => e.stopPropagation()}
            className={`
              absolute bg-background2 border border-border2 rounded-lg p-2 top-0 left-0 translate-y-full -translate-x-1/4 flex gap-2 transition-all duration-150
              ${erasingOptionMenu ? 'opacity-100 scale-100' : 'scale-90 opacity-0'}
            `}
          >
            <Tooltip
              content={"Erase complete drawing"}
              offsetY={"100% - 12px"}
              offsetX={"50%"}
              className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
            >
              <div
                className={`
                  relative flex p-2 text-text border-b
                  ${lastErasingMode == ErasingMode.FULL ? 'border-text' : 'border-transparent hover:bg-background2-hover rounded'}
                `}
                onClick={() => {
                  setErasing(ErasingMode.FULL)
                  setActiveShape(null)
                  setSelectionMode(false);
                  setFillMode(false);
                  setMarqueeMode(false);
                  setSelectedStrokeIds([])
                  setTextMode(false)
                }}
              ><FontAwesomeIcon icon={faEraser} size="xs" /></div>
            </Tooltip>
            <Tooltip
              content={"Erase partial drawing"}
              offsetY={"100% - 12px"}
              offsetX={"50%"}
              className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
            >
              <div
                className={`
                  relative flex p-2 text-text border-b
                  ${lastErasingMode == ErasingMode.PARTIAL ? 'border-text' : 'border-transparent hover:bg-background2-hover rounded'}
                `}
                onClick={() => {
                  setErasing(ErasingMode.PARTIAL)
                  setActiveShape(null)
                  setSelectionMode(false);
                  setFillMode(false);
                  setMarqueeMode(false);
                  setSelectedStrokeIds([])
                  setTextMode(false)
                }}
              ><FontAwesomeIcon icon={faAlignCenter} size="xs" /></div>
            </Tooltip>
          </div>
        </button>

      </div>

      <div className="flex gap-2 p-2 bg-background2 border border-border2 rounded-lg">
        {/* Shapes */}
        <Tooltip
          content={"Draw Arrow"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            className={`
              flex p-2 text-text border-b 
              ${activeShape == 'arrow' ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape('arrow')
              setSelectionMode(false);
              setFillMode(false);
              setTextMode(false);
              setMarqueeMode(false);
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faArrowRight} size="xs" />
          </button>
        </Tooltip>

        {/* Draw Line */}
        <Tooltip
          content={"Draw Line"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            // className={`flex p-2 rounded transition-colors ${activeShape === 'line' ? 'bg-primary text-white' : 'hover:bg-primary-hover text-text-secondary border-transparent'}`}
            className={`
              flex p-2 text-text border-b 
              ${activeShape == 'line' ? 'xborder-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape('line')
              setSelectionMode(false);
              setFillMode(false);
              setTextMode(false);
              setMarqueeMode(false);
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faSlash} size="xs" />
          </button>
        </Tooltip>

        {/* Draw Square */}
        <Tooltip
          content={"Draw Square"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            // className={`flex p-2 rounded transition-colors ${activeShape === 'square' ? 'bg-primary text-white' : 'hover:bg-primary-hover text-text-secondary border-transparent'}`}
            className={`
              flex p-2 text-text border-b 
              ${activeShape == 'square' ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape('square')
              setSelectionMode(false);
              setFillMode(false);
              setTextMode(false);
              setMarqueeMode(false);
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faSquare} size="xs" />
          </button>
        </Tooltip>

        {/* Draw Circle */}
        <Tooltip
          content={"Draw Circle"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            // className={`flex p-2 rounded transition-colors ${activeShape === 'circle' ? 'bg-primary text-white' : 'hover:bg-primary-hover text-text-secondary border-transparent'}`}
            className={`
              flex p-2 text-text border-b 
              ${activeShape == 'circle' ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape('circle')
              setSelectionMode(false);
              setFillMode(false);
              setTextMode(false);
              setMarqueeMode(false);
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faCircle} size="xs" />
          </button>
        </Tooltip>

        {/* Draw Diamond */}
        <Tooltip
          content={"Draw Diamond"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            // className={`flex p-2 rounded transition-colors ${activeShape === 'diamond' ? 'bg-primary text-white' : 'hover:bg-primary-hover text-text-secondary'}`}
            className={`
              flex p-2 text-text border-b 
              ${activeShape == 'diamond' ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => {
              setErasing(ErasingMode.DISABLED)
              setActiveShape('diamond')
              setSelectionMode(false);
              setFillMode(false);
              setTextMode(false);
              setMarqueeMode(false);
              setSelectedStrokeIds([])
            }}
          >
            <FontAwesomeIcon icon={faDiamond} size="xs" />
          </button>
        </Tooltip>

      </div>

      <div className="flex gap-2 p-2 bg-background2 border border-border2 rounded-lg">

        {/* Toggle Measurements */}
        <Tooltip
          content={"Toggle Measurements"}
          offsetY={"100% - 12px"}
          offsetX={"50%"}
          className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
        >
          <button
            // className={`flex p-2 rounded transition-colors ${showMeasurements ? 'bg-primary text-white' : 'hover:bg-primary-hover text-text-secondary'}`}
            className={`
              flex p-2 text-text border-b 
              ${showMeasurements ? 'border-text' : 'hover:bg-background2-hover rounded border-transparent'}
            `}
            onClick={() => setShowMeasurements(!showMeasurements)}
          >
            <FontAwesomeIcon icon={faRulerCombined} size="xs" />
          </button>
        </Tooltip>

        {/* Export Menu */}
        <div className="relative drawingOptionMenu">
          <Tooltip
            content={"Export"}
            offsetY={"100% - 12px"}
            offsetX={"50%"}
            className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
            condition={!exportMenuOpen} // Hide tooltip when menu is open
          >
            <button
              // className={`flex p-2 rounded transition-colors ${exportMenuOpen ? 'bg-primary text-white' : 'hover:bg-primary-hover text-text-secondary'}`}
            className={`
              flex p-2 text-text border-b hover:bg-background2-hover rounded border-transparent
            `}
              onClick={() => {
                setExportMenuOpen(prev => !prev);
                // Close other menus if needed
                setErasingOptionMenu(false);
              }}
            >
              <FontAwesomeIcon icon={faDownload} size="xs" />
            </button>
          </Tooltip>

          {exportMenuOpen && (
            <div className="absolute top-full right-0 pt-4 w-32 z-50">
              <div className="bg-background2 border border-border2 rounded-lg shadow-xl p-1">
                <button
                  className="w-full text-left px-3 py-2 text-sm text-text-secondary hover:bg-background2-hover rounded"
                  onClick={() => {
                    import('src/sandbox/_functions/drawing/exportUtils').then(mod => {
                      const box = marqueeBox || undefined;
                      // If marquee box exists, CLIP strokes to the box.
                      // Otherwise respect selection.
                      const strokesToExport = box
                        ? clipStrokesToRect(strokes, box)
                        : (selectedStrokeIds.length > 0 ? strokes.filter(s => selectedStrokeIds.includes(s.id)) : strokes);

                      mod.downloadSvg(strokesToExport, box);
                      setExportMenuOpen(false);
                    })
                  }}
                >
                  Export SVG
                </button>
                <button
                  className="w-full text-left px-3 py-2 text-sm text-text-secondary hover:bg-background2-hover rounded"
                  onClick={() => {
                    import('src/sandbox/_functions/drawing/exportUtils').then(mod => {
                      const box = marqueeBox || undefined;
                      const strokesToExport = box
                        ? clipStrokesToRect(strokes, box)
                        : (selectedStrokeIds.length > 0 ? strokes.filter(s => selectedStrokeIds.includes(s.id)) : strokes);

                      mod.downloadPng(strokesToExport, box);
                      setExportMenuOpen(false);
                    })
                  }}
                >
                  Export PNG
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="src/sandbox/_functions/codeEditor/autocompletions/reactHooks.ts">
export function ReactHooksImporter(monaco: typeof import("monaco-editor")) {
  const reactHooks = [
    "useState",
    "useEffect",
    "useMemo",
    "useCallback",
    "useContext",
    "useRef"
  ];

  const completion = monaco.languages.registerCompletionItemProvider("typescript", {
    provideCompletionItems: (model, position) => {
      const word = model.getWordUntilPosition(position);
      const range = new monaco.Range(
        position.lineNumber,
        word.startColumn,
        position.lineNumber,
        word.endColumn
      );
      const suggestions = reactHooks.map((hook) => ({
        label: hook,
        kind: monaco.languages.CompletionItemKind.Function,
        insertText: hook,
        range, // Monaco will replace the current word
        command: {
          id: "insertReactImport",
          title: "Add React Import",
          arguments: [hook, model] // pass hook name and model
        }
      }));
      return { suggestions };
    }
  });

  monaco.editor.registerCommand("insertReactImport", (_, ...args) => {
    const [hook, model] = args;
    const lines = model.getLinesContent();

    // Check if a React import already exists
    const importLineIndex = lines.findIndex((line: string[]) => line.includes('from "react"'));
    if (importLineIndex >= 0) {
      const line = lines[importLineIndex];
      if (!line.includes(hook)) {
        // Add hook to existing import
        let newLine = "";
        if (line.includes("{")) {
          newLine = line.replace('{', `{ ${hook},`);
        } else {
          newLine = line.replace(' from', `, { ${hook} } from`);
        }
        model.applyEdits([{
          range: new monaco.Range(importLineIndex + 1, 1, importLineIndex + 1, line.length + 1),
          text: newLine
        }]);
      }
    } else {
      // Insert new import at top
      model.applyEdits([{
        range: new monaco.Range(1, 1, 1, 1),
        text: `import { ${hook} } from "react";\n`
      }]);
    }
  });

  return completion;
}
</file>

<file path="src/sandbox/_functions/files/fileUtils.ts">
import { IconDefinition } from "@fortawesome/fontawesome-svg-core";
import {
  faFile,
  faFileCode,
  faFileImage,
  faFilePdf,
  faFileZipper,
  faFileLines,
  faFileVideo,
  faFileAudio,
} from "@fortawesome/free-solid-svg-icons";

export function getFileExtension(fileName: string): string {
  if (!fileName) return '';
  const parts = fileName.split('.');
  return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : '';
}

export function getMimeTypeCategory(mimeType: string): 'text' | 'image' | 'pdf' | 'video' | 'audio' | 'binary' {
  if (mimeType.startsWith('text/')) return 'text';
  if (mimeType.startsWith('image/')) return 'image';
  if (mimeType === 'application/pdf') return 'pdf';
  if (mimeType.startsWith('video/')) return 'video';
  if (mimeType.startsWith('audio/')) return 'audio';

  if (mimeType.includes('javascript') || mimeType.includes('json') || mimeType.includes('xml')) {
    return 'text';
  }

  return 'binary';
}

export function getMonacoLanguage(extension: string): string {
  const languageMap: Record<string, string> = {
    js: 'javascript',
    jsx: 'javascript',
    ts: 'typescript',
    tsx: 'typescript',
    json: 'json',
    css: 'css',
    scss: 'scss',
    less: 'less',
    html: 'html',
    xml: 'xml',
    md: 'markdown',
    lua: 'lua',
    py: 'python',
    rb: 'ruby',
    go: 'go',
    rs: 'rust',
    java: 'java',
    c: 'c',
    cpp: 'cpp',
    cs: 'csharp',
    php: 'php',
    sh: 'shell',
    bat: 'bat',
    ps1: 'powershell',
    yaml: 'yaml',
    yml: 'yaml',
    toml: 'toml',
    ini: 'ini',
    sql: 'sql',
    txt: 'plaintext',
  };

  return languageMap[extension.toLowerCase()] || 'plaintext';
}

export function readFileAsText(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target?.result as string);
    reader.onerror = reject;
    reader.readAsText(file);
  });
}

export function readFileAsBase64(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const result = e.target?.result as string;
      // Remove the data:*/*;base64, prefix
      const base64 = result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

export function validateFileSize(file: File, maxSizeBytes: number): boolean {
  return file.size <= maxSizeBytes;
}

export function getFileIcon(extension: string, mimeType: string): IconDefinition {
  const ext = extension.toLowerCase();

  const codeExtensions = ['js', 'jsx', 'ts', 'tsx', 'json', 'xml', 'html', 'css', 'scss', 'less', 'lua', 'py', 'rb', 'go', 'rs', 'java', 'c', 'cpp', 'cs', 'php', 'sh', 'bat'];
  if (codeExtensions.includes(ext)) {
    return faFileCode;
  }

  const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp', 'bmp', 'ico'];
  if (imageExtensions.includes(ext) || mimeType.startsWith('image/')) {
    return faFileImage;
  }

  if (ext === 'pdf' || mimeType === 'application/pdf') {
    return faFilePdf;
  }

  const archiveExtensions = ['zip', 'rar', '7z', 'tar', 'gz', 'bz2'];
  if (archiveExtensions.includes(ext)) {
    return faFileZipper;
  }

  const videoExtensions = ['mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv', 'webm'];
  if (videoExtensions.includes(ext) || mimeType.startsWith('video/')) {
    return faFileVideo;
  }

  const audioExtensions = ['mp3', 'wav', 'ogg', 'flac', 'aac', 'm4a'];
  if (audioExtensions.includes(ext) || mimeType.startsWith('audio/')) {
    return faFileAudio;
  }

  const textExtensions = ['txt', 'md', 'log'];
  if (textExtensions.includes(ext)) {
    return faFileLines;
  }

  return faFile;
}

export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  //? some beatiful AI slop
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}
</file>

<file path="src/sandbox/_functions/grid/onMouseDown.ts">
import { useGrid } from "../../_providers/GridContextProvider";
import { useDrawing } from "../../_providers/DrawingContextProvider";
import { CreateComponentMenuVisibleState } from "../../types/createComponentMenuTypes";
import { useBuilderPanel } from "../../_providers/BuilderPanelContextProvider";
import { useMenus } from "../../_providers/MenusContextProvider";

export default function useOnMouseDown() {

  const {
    setDragging,
    draggingRef,
    lastPos,
    posMouseDown
  } = useGrid();

  const {
    lastPositionWindowDivider,
    windowDividerDragging,
    setWindowDivider
  } = useBuilderPanel();

  const {
    drawingEnabled
  } = useDrawing();

  const {
    setCreateComponentMenuOpen
  } = useMenus();

  const handleMouseDown = (e: MouseEvent) => {
    // e.preventDefault();

    // if (e.buttons == 1) { return; } //? left button
    // if (e.buttons == 2) { return; } //? right button
    if (
      drawingEnabled
      && (
        e.buttons == 1 //? left button 
        || e.buttons == 2 //? right button
      )
    ) { return; }

    const elem = document.elementFromPoint(e.clientX, e.clientY) as HTMLElement;
    if (elem && elem.closest('#createComponentMenu')) { return; }

    draggingRef.current = true;

    setTimeout(() => {
      if (!draggingRef.current) { return; }
      setDragging(true);
    }, 100);

    lastPos.current = { x: e.clientX, y: e.clientY };
    posMouseDown.current = { x: e.clientX, y: e.clientY };

    setCreateComponentMenuOpen(prev => {
      if (e.buttons == 4) {
        return CreateComponentMenuVisibleState.FORCECLOSE;
      }

      if (prev === CreateComponentMenuVisibleState.OPEN) {
        return CreateComponentMenuVisibleState.FORCECLOSE;
      }
      return CreateComponentMenuVisibleState.CLOSED;
    });
  };

  const handleWindowDivider = (e: MouseEvent) => {
    e.preventDefault();

    windowDividerDragging.current = true;

    setTimeout(() => {
      if (!windowDividerDragging.current) { return; }
      setWindowDivider(true);
    }, 100);

    lastPositionWindowDivider.current = e.clientX;
  }

  return { handleMouseDown, handleWindowDivider }
}
</file>

<file path="src/sandbox/_functions/grid/onMouseWheel.ts">
import { useEffect, useCallback } from "react";
import { useGrid } from "../../_providers/GridContextProvider";
import { toast } from "sonner";

// const zoomLevels = [0.1, 0.2, 0.3, 0.4, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4, 5];
const zoomLevels = [
  0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45,
  0.5, 0.625, 0.75, 0.875, 1, 1.125, 1.25, 1.375,
  1.5, 1.75, 2, 2.5, 3, 3.5, 4, 4.5, 5
];
const minZoom = zoomLevels[0];
const maxZoom = zoomLevels[zoomLevels.length - 1];

export default function useOnMouseWheel() {

  const { containerRef, zoomRef, setZoom, setOffset } = useGrid();

  const handleWheel = useCallback((e: WheelEvent) => {
    // Check if the event target or any parent has overflow-y-auto or overflow-auto
    let element = e.target as HTMLElement;
    while (element && element !== containerRef.current) {
      const style = window.getComputedStyle(element);
      if (style.overflowY === 'auto' || style.overflowY === 'scroll' ||
        style.overflow === 'auto' || style.overflow === 'scroll') {
        // Let the browser handle natural scrolling
        return;
      }
      element = element.parentElement as HTMLElement;
    }

    // Prevent default scroll behavior to avoid overscroll bounce
    e.preventDefault();

    const usingMouseWheel = Math.abs(e.deltaY) > 50;
    const currentZoom = zoomRef.current; // Always get the latest zoom value

    let newZoom;
    if (usingMouseWheel) {
      //? here we handle zooming logic with the mouse wheel

      // const currentIndex = zoomLevels.findIndex(level => level >= currentZoom);
      const closestIndex = zoomLevels.reduce((closestIdx, level, idx) => {
        const currentDiff = Math.abs(level - currentZoom);
        const closestDiff = Math.abs(zoomLevels[closestIdx] - currentZoom);
        return currentDiff < closestDiff ? idx : closestIdx;
      }, 0);
      let newIndex = closestIndex;

      if (e.deltaY < 0) {
        newIndex = Math.min(zoomLevels.length - 1, closestIndex + 1);
      } else {
        newIndex = Math.max(0, closestIndex - 1);
      }
      newZoom = zoomLevels[newIndex];

    } else {
      //? here we handle both the zooming and padding (offset) logic with the trackpad

      const zooming = e.ctrlKey
      if (zooming) {
        const divider =
          currentZoom < 1
            ? 70
            : currentZoom < 3
              ? 30
              : 10
        const additional = Math.abs(e.deltaY) / divider
        if (e.deltaY < 0) { //? negative value so user is zooming in
          newZoom = Math.min(maxZoom, currentZoom + additional);
        } else { //? positive value so user is zooming out
          newZoom = Math.max(minZoom, currentZoom - additional)
        }
      } else {
        // Panning with touchpad (no ctrl key)

        // Always apply both X and Y deltas to prevent axis locking
        // even if one axis has very small values
        const speed = 1;
        const deltaX = e.deltaX;
        const deltaY = e.deltaY;

        // Only pan if there's meaningful movement
        if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
          return setOffset(prev => ({
            x: prev.x - deltaX / currentZoom * speed,
            y: prev.y - deltaY / currentZoom * speed,
          }));
        }
      }
    }

    if (!newZoom) { return; }

    const mx = e.clientX;
    const my = e.clientY;

    setOffset(prev => ({
      x: mx - ((mx - prev.x) / currentZoom) * newZoom,
      y: my - ((my - prev.y) / currentZoom) * newZoom,
    }));

    setZoom(newZoom);
  }, [containerRef, zoomRef, setZoom, setOffset]);

  // Register wheel event as non-passive to ensure preventDefault works
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // We need to add the event listener with { passive: false } to allow preventDefault
    container.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      container.removeEventListener('wheel', handleWheel);
    };
  }, [handleWheel, containerRef]);

  return { handleWheel };
}
</file>

<file path="src/settings/page.tsx">
import { useCallback, useEffect, useState } from "react";
import notify from "src/_functions/notify";
import ThemeToggler from "src/_components/ThemeToggler";
import { backendUrl } from "config";
import { useUpdateLanguage } from "src/_components/TranslationProvider";
import Avatar from "src/_components/Avatar";
import { useTranslator } from "src/_functions/translator";
import { apiRequest, apiRequestReponse } from "src/_sockets/apiRequest";
import { useSession } from "src/_providers/SessionProvider";

const incrementAvatarVersion = (url: string) => {
  const match = url.match(/[?&]v=(\d+)/);
  return match ? parseInt(match[1]) + 1 : 1;
}

export const template = 'main';
export default function Home() {

  const { session } = useSession();
  const { updateTheme } = ThemeToggler();
  const setLanguage = useUpdateLanguage();
  const translate = useTranslator();

  const [loaded, setLoaded] = useState(false);
  const [newLanguage, setNewLanguage] = useState<'nl' | 'en' | 'de' | 'fr'>(session?.language as 'nl' | 'en' |'de' | 'fr' || '');
  const [newAvatar, setNewAvatar] = useState<string>(session?.avatar || '');
  const [newName, setNewName] = useState<string>(session?.name || '');
  const [newTheme, setNewTheme] = useState<'light' | 'dark'>(session?.theme || 'dark');

  if (!session) return null;

  let url;

  if (newAvatar.includes('base64')) {
    url = new URL(newAvatar, window.location.origin);
    url.search = ""; // remove query params
  }

  const displayUrl = newAvatar.includes('base64') 
    ? url?.toString() 
    : newAvatar.startsWith("http")
    ? newAvatar
    : `${backendUrl}/uploads/${session.avatar}`
  console.log(displayUrl)

  const normalizeAvatar = (url: string) => url.split('?')[0];

  const saveUser = useCallback(async () => {
    if (!loaded) {
      return setLoaded(true);
    }

    if (
      newLanguage == session.language
      && normalizeAvatar(newAvatar) === normalizeAvatar(session.avatar)
      && newName == session.name
      && newTheme == session.theme
    ) {
      notify.info({ key: 'settings.noChangesMade' })
      return;
    }
    const response = await apiRequest({
      name: 'updateUser',
      data: {
        language: newLanguage != session.language? newLanguage : undefined,
        avatar: newAvatar != session.avatar? newAvatar : undefined,
        name: newName != session.name? newName : undefined,
        theme: newTheme != session.theme? newTheme : undefined,
      },
    }) as apiRequestReponse
    if (response.status === 'success') {
      notify.success({ key: 'settings.updatedUser' })
    } else {
      notify.error({ key: 'settings.failedUpdateUser' })
    }
  }, [newLanguage, newAvatar, newName, newTheme, session]);


  //? we trigger saveUser when the newAvatar changes so that the avatar is saved immidiatly, we dont call the saveUser in the onchange callback cause than it causes a race codition between the function calling and newAvatar having the new value
  useEffect(() => {
    if (!newAvatar) return;
    
    saveUser();
  }, [newAvatar])

  return (
    <div className='flex items-center justify-center w-full h-full bg-background'>
      <div className="bg-container border-2 border-container-border flex flex-col p-8 gap-4 rounded-2xl max-w-[360px] w-[90%]">

        <div className="flex gap-4 items-center">
          { newAvatar || session.avatar ? (
            <img src={displayUrl} 
              className="rounded-xl min-w-28 max-w-28 object-cover aspect-square select-none"></img>
          ) : (
            <div className="rounded-xl min-w-28 max-w-28 object-cover aspect-square select-none">
              <Avatar
                user={{
                  name: session.name,
                  avatarFallback: session.avatarFallback
                }}
                textSize="text-4xl"
              />
            </div>
          )}
          <div className="space-y-2">
            <input type="file" className="hidden"></input>
            <button
              className="w-full py-1 bg-container2 border-container2-border border-2 rounded-md text-title font-semibold text-lg"
              onClick={() => {
                const input = document.querySelector('input[type="file"]') as HTMLInputElement;
                input.click();
                input.onchange = async () => {
                  const file = input.files?.[0];
                  if (!file) return;
                  const maxSize = 4 * 1024 * 1024; // 4 MB
                  if (file.size > maxSize) {
                    notify.error({ key:'settings.sizeToLarge' })
                    return;
                  }

                  notify.info({ key: 'settings.loadingImg' })
                  const reader = new FileReader();
                  reader.onload = async () => {
                    setNewAvatar(prevUrl => `${reader.result}?v=${incrementAvatarVersion(prevUrl||"")}`)
                    notify.success({ key: 'settings.imgLoaded' })
                  };
                  reader.readAsDataURL(file);
                }
              }}
            >
              {/* Change avatar */}
              {translate({ key: 'settings.changeAvatar' })}
            </button>
            {/* <button 
              className="w-full py-1 bg-wrong/50 border-wrong border-2 rounded-md text-title font-semibold text-lg"
              onClick={() => {
                ref.open(
                  <ConfirmMenu
                    title={(translate({ key: 'settings.changeAvatar' }))}
                    content={'asd'}
                    resolve={(success) => {
                      console.log(success)
                    }}
                  />
                )
              }}
            >
              {translate({ key: 'settings.deleteAvatar' })}
            </button> */}
            <div className="text-muted text-sm">
              {/* JPG, GIV or PNG. 1MB max. */}
              {translate({ key:'settings.changeAvatarDescription' })}
            </div>
          </div>
        </div>

        <div className="space-y-2 w-full">
          <div className="text-lg font-semibold">Name</div>
          <input 
            className={`w-full bg-container2 border-container2-border border-2 focus:outline-0 focus:border-container3-border transition-all duration-150 p-2 rounded-md`}
            value={newName}
            onChange={(e) => { setNewName(e.target.value) }}
          ></input>
        </div>

        <div className="w-full flex flex-col gap-2">
          <div className="text-lg font-semibold">
            {/* Language */}
            {translate({ key:'settings.language.title' })}
          </div>
          <div className="flex w-full gap-2">
            <button
              onClick={() => { 
                setNewLanguage('nl');
                setLanguage('nl');
               }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage == 'nl' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* NL */}
              {translate({ key:'settings.language.nl' })}
            </button>
            <button
              onClick={() => { 
                setNewLanguage('en'); 
                setLanguage('en');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage == 'en' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* EN */}
              {translate({ key:'settings.language.en' })}
            </button>
            <button
              onClick={() => { 
                setNewLanguage('de'); 
                setLanguage('de');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage == 'de' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* DE */}
              {translate({ key:'settings.language.de' })}
            </button>
            <button
              onClick={() => { 
                setNewLanguage('fr'); 
                setLanguage('fr');
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newLanguage == 'fr' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* FR */}
              {translate({ key:'settings.language.fr' })}
            </button>
          </div>
        </div>

        <div className="w-full flex flex-col gap-2">
          <div className="text-lg font-semibold">
            {/* Theme */}
            {translate({ key:'settings.theme.title' })}
          </div>
          <div className="flex w-full gap-2">
            <button
              onClick={() => { 
                setNewTheme('light');
                updateTheme('light'); 
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newTheme == 'light' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* Light mode */}
              {translate({ key:'settings.theme.light' })}
            </button>
            <button
              onClick={() => { 
                setNewTheme('dark');
                updateTheme('dark'); 
              }}
              className={`w-full border-2 p-2 rounded-md
                ${newTheme == 'dark' ? 'bg-container3 border-container3-border' : 'bg-container2 border-container2-border'}
                hover:bg-container3 hover:border-container3-border transition-all duration-300
              `}
            >
              {/* Dark mode */}
              {translate({ key:'settings.theme.dark' })}
            </button>
          </div>
        </div>

        <button 
          className="w-full bg-primary text-white py-2 rounded-lg"
          onClick={saveUser}
        >
          {/* Save data */}
          {translate({ key:'settings.saveChanges' })}
        </button>

      </div>
    </div>
  )
}
</file>

<file path="src/_components/Tooltip.tsx">
// Tooltip.tsx
import { useState, useRef, ReactNode } from "react";
import { motion, AnimatePresence } from "framer-motion";

interface TooltipProps {
  content: ReactNode;
  children: ReactNode;
  delay?: number;
  vertical?: "top" | "bottom"; // top or bottom
  horizontal?: "left" | "right"; // left, right
  offsetX?: number | string; // horizontal offset
  offsetY?: number | string; // vertical offset
  className?: string;
  condition?: boolean;
}

export default function Tooltip({
  content,
  children,
  delay = 0,
  offsetX = 0,
  offsetY = 0,
  className = "",
  condition
}: TooltipProps) {
  const [visible, setVisible] = useState(false);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  const showTooltip = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    timeoutRef.current = setTimeout(() => setVisible(true), delay);
  };

  const hideTooltip = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    setVisible(false);
  };

  // calculate absolute positioning
  const style: React.CSSProperties = {};

  if (typeof offsetY === "number") {
    // style.top = `${offsetY}px`;
    style.top = `calc(100% + ${offsetY}px)`;
  } else if (typeof offsetY === "string") {
    style.top = `calc(100% + ${offsetY})`;
  }

  if (typeof offsetX === "number") {
    style.left = `${offsetX}px`;
  } else if (typeof offsetX === "string") {
    style.left = `calc(${offsetX})`;
  }

  // simple animation based on vertical
  // const initial = { opacity: 0, y: vertical === "top" ? -5 : 5 };
  const initial = { opacity: 0, y: -5 };
  const animate = { opacity: 1, y: 0 };
  // const exit = { opacity: 0, y: vertical === "top" ? -5 : 5 };
  const exit = { opacity: 0, y: -5 };

  return (
    <div
      style={{ 
        display: "inline-flex", 
        position: "relative",
      }}
      onMouseEnter={showTooltip}
      onMouseLeave={hideTooltip}
    >
      {children}

      <AnimatePresence>
        {visible && (condition === undefined || condition) && (
          <motion.div
            initial={initial}
            animate={animate}
            exit={exit}
            transition={{ duration: 0.2 }}
            style={{
              position: "absolute",
              zIndex: 999,
              ...style,
            }}
          >
            <div className={`select-none ${className}`}>
              {content}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
</file>

<file path="src/NoteEditor.css">
/* Basic table styles for TipTap */
.ProseMirror table {
  border-collapse: collapse;
  margin: 0;
  overflow: hidden;
  table-layout: fixed;
  width: 100%;
}

.ProseMirror td,
.ProseMirror th {
  border: 2px solid #3f3f46;
  /* border-zinc-700 */
  box-sizing: border-box;
  min-width: 1em;
  padding: 3px 5px;
  position: relative;
  vertical-align: top;
}

.ProseMirror th {
  background-color: #27272a;
  /* bg-zinc-800 */
  font-weight: bold;
  text-align: left;
}

.ProseMirror .selectedCell:after {
  /* Disable the blue selection highlight */
  display: none;
}

.ProseMirror .column-resize-handle {
  background-color: #a1a1aa;
  /* zinc-400 */
  bottom: -2px;
  pointer-events: none;
  position: absolute;
  right: -2px;
  top: 0;
  width: 4px;
}

.ProseMirror p {
  margin: 0.5em 0;
}

/* Headings */
.ProseMirror h1 {
  font-size: 2em;
  font-weight: bold;
  margin: 0.67em 0;
  line-height: 1.2;
}

.ProseMirror h2 {
  font-size: 1.5em;
  font-weight: bold;
  margin: 0.83em 0;
  line-height: 1.3;
}

.ProseMirror h3 {
  font-size: 1.17em;
  font-weight: bold;
  margin: 1em 0;
}

/* Lists */
.ProseMirror ul,
.ProseMirror ol {
  padding-left: 1.5em;
  margin: 0.5em 0;
}

.ProseMirror ul {
  list-style-type: disc;
}

.ProseMirror ol {
  list-style-type: decimal;
}

.ProseMirror li {
  margin: 0.25em 0;
}

.ProseMirror li>p {
  margin: 0;
}

/* Blockquote (Hint) */
.ProseMirror blockquote {
  border-left: 4px solid var(--color-primary);
  background-color: var(--color-background2);
  padding: 0.5em 0.5em;
  margin: 0.5em 0;
  border-radius: 4px;
  color: var(--color-text);
}

.ProseMirror blockquote p {
  margin: 0.25em 0;
}

.ProseMirror blockquote p:first-child {
  margin-top: 0;
}

.ProseMirror blockquote p:last-child {
  margin-bottom: 0;
}

/* Placeholder text styling - shows on empty lines with cursor */
.ProseMirror .is-empty-with-placeholder::before {
  color: #71717a;
  /* text-zinc-500 for gray placeholder */
  content: attr(data-placeholder);
  pointer-events: none;
  position: absolute;
}

/* Task list styles */
.ProseMirror ul[data-type="taskList"] {
  list-style: none;
  padding-left: 0;
}

.ProseMirror ul[data-type="taskList"] li {
  display: flex;
  align-items: center;
  gap: 0.5em;
}

.ProseMirror ul[data-type="taskList"] li>label {
  flex: 0 0 auto;
  display: flex;
  align-items: center;
  user-select: none;
}

.ProseMirror ul[data-type="taskList"] li>div {
  flex: 1 1 auto;
}

.ProseMirror ul[data-type="taskList"] input[type="checkbox"] {
  cursor: pointer;
  appearance: none;
  width: 1.1em;
  height: 1.1em;
  border: 2px solid var(--color-border2);
  border-radius: 4px;
  background-color: var(--color-background);
  transition: all 0.15s ease;
  position: relative;
}

.ProseMirror ul[data-type="taskList"] input[type="checkbox"]:hover {
  border-color: var(--color-primary);
  background-color: var(--color-background-hover);
}

.ProseMirror ul[data-type="taskList"] input[type="checkbox"]:checked {
  background-color: var(--color-primary);
  border-color: var(--color-primary);
}

.ProseMirror ul[data-type="taskList"] input[type="checkbox"]:checked::after {
  content: "";
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%) rotate(45deg);
  width: 0.3em;
  height: 0.6em;
  border: solid white;
  border-width: 0 2px 2px 0;
}

/* Code block selection highlight */
.code-block.selected {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
  border-radius: 8px;
  transition: none !important;
}
</file>

<file path="src/sandbox/_components/drawing/DrawingSideMenu.tsx">
import { useDrawing } from "src/sandbox/_providers/DrawingContextProvider";
import { HexColorPicker } from "react-colorful";
import { useEffect, useState, useRef } from "react";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faPalette, faRedo, faUndo } from "@fortawesome/free-solid-svg-icons";
import { useKeyboardShortcuts } from "src/sandbox/_functions/drawing/useKeyboardShortcuts";

export default function DrawingSideMenu() {
  useKeyboardShortcuts();

  const {
    drawingEnabled,

    brushSize,

    brushColor,

    erasing,

    setHistoryIndex,
    strokeHistory,
    updateBrushColor,
    updateBrushSize,
    lineStyle,
    setLineStyle,
    strokes,
    setStrokes,
    selectedStrokeIds,
    setStrokeHistory,
    historyIndex
  } = useDrawing();

  // Helper to update line style (also updates selected strokes)
  const updateLineStyle = (style: 'solid' | 'dashed' | 'dotted') => {
    setLineStyle(style);
    if (selectedStrokeIds.length > 0) {
      const newStrokes = strokes.map(s => {
        if (selectedStrokeIds.includes(s.id)) {
          return { ...s, lineStyle: style };
        }
        return s;
      });
      setStrokes(newStrokes);
      setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), newStrokes]);
      setHistoryIndex(prev => prev + 1);
    }
  };

  const [openColorPicker, setOpenColorPicker] = useState(false);
  const colorPickerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (colorPickerRef.current && !colorPickerRef.current.contains(event.target as Node)) {
        setOpenColorPicker(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [])

  // if (!drawingEnabled) { return null }

  const colors = [
    "#ef4444", // Red
    "#ffba00", // Amber
    "#05df72", // Green
    "#22d3ee", // Cyan
    "#a855f7", // Purple
    "#ec4899", // Pink
  ];

  return (
    <div
      className={`
        absolute left-4 top-1/2 -translate-y-1/2 z-50 
        flex flex-col gap-3 p-3 w-36
        bg-background2 border border-border2 rounded-lg text-text select-none
        transition-all duration-200 origin-left
        ${drawingEnabled ? 'opacity-100 scale-100' : 'opacity-0 scale-80'}
      `}
      onClick={(e) => {
        e.stopPropagation();
        e.preventDefault();
      }}
      onDragStart={(e) => e.preventDefault()}
    >

      <div className="">
        <div className="flex justify-between items-center text-sm">
          <span>Size</span>
          {/* <span>{brushSize}px</span> */}
        </div>
        <div className="flex justify-between mt-1">
          <div
            className={`font-semibold w-8 h-8 rounded flex items-center justify-center bg-background border ${brushSize === (erasing ? 10 * 6 : 10) ? 'border-primary' : 'border-transparent hover:border-border cursor-pointer'}`}
            onClick={() => { updateBrushSize(erasing ? 10 * 6 : 10) }}
          >S</div>
          <div
            className={`font-semibold w-8 h-8 rounded flex items-center justify-center bg-background border ${brushSize === (erasing ? 30 * 6 : 30) ? 'border-primary' : 'border-transparent hover:border-border cursor-pointer'}`}
            onClick={() => { updateBrushSize(erasing ? 30 * 6 : 30) }}
          >M</div>
          <div
            className={`font-semibold w-8 h-8 rounded flex items-center justify-center bg-background border ${brushSize === (erasing ? 50 * 6 : 50) ? 'border-primary' : 'border-transparent hover:border-border cursor-pointer'}`}
            onClick={() => { updateBrushSize(erasing ? 50 * 6 : 50) }}
          >L</div>
        </div>
      </div>

      {/* Line Style */}
      <div className="">
        <span className="text-sm text-text-secondary">Style</span>
        <div className="flex justify-between mt-1">
          <div
            className={`w-8 h-8 rounded flex items-center justify-center cursor-pointer bg-background border ${lineStyle === 'solid' ? 'border-primary' : 'border-transparent hover:border-border'}`}
            onClick={() => updateLineStyle('solid')}
            title="Solid"
          >
            <svg width="16" height="2" viewBox="0 0 16 2">
              <line x1="0" y1="1" x2="16" y2="1" stroke="currentColor" strokeWidth="2" />
            </svg>
          </div>
          <div
            className={`w-8 h-8 rounded flex items-center justify-center cursor-pointer bg-background border ${lineStyle === 'dashed' ? 'border-primary' : 'border-transparent hover:border-border'}`}
            onClick={() => updateLineStyle('dashed')}
            title="Dashed"
          >
            <svg width="16" height="2" viewBox="0 0 16 2">
              <line x1="0" y1="1" x2="16" y2="1" stroke="currentColor" strokeWidth="2" strokeDasharray="4 2" />
            </svg>
          </div>
          <div
            className={`w-8 h-8 rounded flex items-center justify-center cursor-pointer bg-background border ${lineStyle === 'dotted' ? 'border-primary' : 'border-transparent hover:border-border'}`}
            onClick={() => updateLineStyle('dotted')}
            title="Dotted"
          >
            <svg width="16" height="2" viewBox="0 0 16 2">
              <line x1="0" y1="1" x2="16" y2="1" stroke="currentColor" strokeWidth="2" strokeDasharray="1 3" />
            </svg>
          </div>
        </div>
      </div>

      {/* Colors */}
      <div className="">
        <span className="text-sm text-text-secondary">Color</span>
        <div className="grid grid-cols-3 gap-2">
          {colors.map(color => (
            <button
              key={color}
              className={`w-full aspect-square rounded-md border transition-transform hover:scale-105 cursor-pointer ${brushColor === color ? '' : 'border-transparent'}`}
              style={{ backgroundColor: color }}
              onClick={() => {
                updateBrushColor(color);
              }}
            />
          ))}
        </div>
      </div>

      <div className="">
        {/* Custom Color Picker */}
        <div className="relative" ref={colorPickerRef}>
          <button
            className="w-full flex items-center p-2 bg-background border border-transparent hover:border-border rounded-md text-sm text-text-secondary transition-colors"
            onClick={() => setOpenColorPicker(!openColorPicker)}
          >
            <FontAwesomeIcon icon={faPalette} size="lg" />
            <div
              className="w-16 h-4 rounded-xl ml-auto"
              style={{ backgroundColor: brushColor }}
            />
          </button>

          {openColorPicker && (
            <div className="absolute top-full left-0 mt-2 z-50 shadow-xl rounded-lg overflow-hidden">
              <HexColorPicker color={brushColor} onChange={(c) => {
                updateBrushColor(c);
              }} />
            </div>
          )}
        </div>
      </div>

      {/* Undo / Redo */}
      <div className="flex gap-2">
        <button
          className="flex-1 flex items-center justify-center py-2 bg-background border border-transparent hover:border-border rounded-md transition-all"
          onClick={() => setHistoryIndex(prev => Math.max(0, prev - 1))}
          disabled={strokeHistory.length === 0} // Simple check, logic might need refinement based on index
        >
          <FontAwesomeIcon icon={faUndo} size="sm" />
        </button>
        <button
          className="flex-1 flex items-center justify-center py-2 bg-background border border-transparent hover:border-border rounded-md transition-all"
          onClick={() => setHistoryIndex(prev => Math.min(prev + 1, strokeHistory.length))}
        >
          <FontAwesomeIcon icon={faRedo} size="sm" />
        </button>
      </div>

    </div>
  )
}
</file>

<file path="src/sandbox/_components/editor/BaseCodeEditor.tsx">
import { useEffect, useState } from "react";
import Editor, { useMonaco } from "@monaco-editor/react";
import * as monacoEditor from "monaco-editor";
import setCompilerOptions from "../../_functions/codeEditor/compilerOptions";
import loadAutoCompletions from "../../_functions/codeEditor/autocompletions/autocompletionHandler";
import traverseClickedComponent from "../../_functions/codeEditor/traverseClickedComponent";
import HoverTooltip from "src/sandbox/_functions/codeEditor/hoverTooltip";
import InitTailwindcss from "src/sandbox/_functions/codeEditor/tailwindcss/tailwindcss";
import generateThemes from "src/sandbox/_functions/codeEditor/themes/themes";

type BaseCodeEditorProps = {
  value: string;
  onChange: (value: string | undefined) => void;
  language?: string;
  theme?: string;
  options?: monacoEditor.editor.IStandaloneEditorConstructionOptions;
  path?: string;
  onMount?: (editor: monacoEditor.editor.IStandaloneCodeEditor, monaco: typeof monacoEditor) => void;
  onHeightUpdateStart?: () => void;
  onHeightUpdateEnd?: () => void;
}

export default function BaseCodeEditor({
  value,
  onChange,
  language = "typescript",
  theme = "vs-dark",
  options,
  path = "file:///App.tsx",
  onMount
}: BaseCodeEditorProps) {
  const monacoInstance = useMonaco();
  const [editor, setEditor] = useState<monacoEditor.editor.IStandaloneCodeEditor | null>(null);

  const userComponents = [
    { name: "Dropdown", code: "export function Dropdown() { return <div>...</div> }" },
    { name: "MyButton", code: "export function MyButton() { return <button>Click</button> }" }
  ];

  // Determine if we should use the custom theme (only for TS/JS)
  const isTypeScriptOrJavaScript = ['typescript', 'javascript', 'tsx', 'jsx'].includes(language);
  const editorTheme = isTypeScriptOrJavaScript ? "trae-dark" : "vs-dark";

  useEffect(() => {
    if (!monacoInstance) return;

    setCompilerOptions(monacoInstance);
    generateThemes(monacoInstance);

    if (isTypeScriptOrJavaScript) {
      monacoInstance.editor.setTheme("trae-dark");
    } else {
      monacoInstance.editor.setTheme("vs-dark");
    }

    const disposeAutoCompletions = loadAutoCompletions(monacoInstance);
    return () => {
      disposeAutoCompletions();
    };
  }, [monacoInstance, isTypeScriptOrJavaScript]);

  useEffect(() => {
    if (!editor) { return; }

    HoverTooltip(editor);

    traverseClickedComponent({
      editor,
      userComponents
    });
  }, [editor]);

  useEffect(() => {
    if (!monacoInstance || !editor) { return; }

    const disposTailwind = InitTailwindcss(monacoInstance, editor);
    return () => {
      disposTailwind();
    }
  }, [monacoInstance, editor]);

  const [height, setHeight] = useState<string | number>("100%");

  return (
    <div className="flex flex-col w-full" style={{ height }}>
      <Editor
        height="100%"
        width="100%"
        language={language}
        path={path}
        value={value}
        theme={editorTheme}
        onMount={(editor, monaco) => {
          setEditor(editor);
          if (monaco) {
            monaco.editor.setTheme(editorTheme);
          }
          if (onMount) onMount(editor, monaco);

          if (options?.scrollBeyondLastLine === false) {
            const MAX_HEIGHT = 700; // Match the maxHeight in CodeBlockComponent

            const updateHeight = () => {
              const contentHeight = editor.getContentHeight();
              // Cap at max height to prevent updates beyond CSS maxHeight
              const cappedHeight = Math.min(contentHeight, MAX_HEIGHT);
              setHeight(cappedHeight);
            };

            editor.onDidContentSizeChange(updateHeight);
            updateHeight(); // Initial size
          }
        }}
        onChange={onChange}
        options={{
          fontSize: 16,
          minimap: { enabled: false },
          automaticLayout: true,
          autoClosingBrackets: "always",
          tabCompletion: "on",
          "semanticHighlighting.enabled": true,
          ...options
        }}
      />
    </div>
  );
}
</file>

<file path="src/sandbox/_components/files/File.tsx">
import { useState } from 'react';
import { useBlueprints } from '../../_providers/BlueprintsContextProvider';
import { file } from '../../types/blueprints';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { getFileIcon, getMimeTypeCategory, formatFileSize, getMonacoLanguage, getFileExtension } from '../../_functions/files/fileUtils';
import { useBuilderPanel, BuilderMenuMode } from '../../_providers/BuilderPanelContextProvider';
import { useCode } from '../../_providers/CodeContextProvider';
import { isBabelCompatible } from '../../_functions/files/babelUtils';
import { faCode, faDownload, faEdit, faTrash } from '@fortawesome/free-solid-svg-icons';

type FileProps = {
  fileBlueprint: file;
}

export default function File({ fileBlueprint }: FileProps) {
  const { setBlueprints } = useBlueprints();
  const { setBuilderMenuMode, setWindowDividerPosition } = useBuilderPanel();
  const { setCodeWindows, activeCodeWindow, setActiveCodeWindow, codeWindows } = useCode();
  const [isEditingName, setIsEditingName] = useState(false);
  const [editedName, setEditedName] = useState(fileBlueprint.name);

  // Derive file properties from name and code
  const fileExtension = getFileExtension(fileBlueprint.name);
  
  // Properly determine MIME type from extension
  const getMimeTypeFromExtension = (ext: string): string => {
    const mimeTypes: Record<string, string> = {
      // Images
      'png': 'image/png',
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'gif': 'image/gif',
      'svg': 'image/svg+xml',
      'webp': 'image/webp',
      'bmp': 'image/bmp',
      'ico': 'image/x-icon',
      // Text
      'txt': 'text/plain',
      'md': 'text/markdown',
      'json': 'application/json',
      'xml': 'text/xml',
      'html': 'text/html',
      'css': 'text/css',
      'js': 'text/javascript',
      'jsx': 'text/javascript',
      'ts': 'text/typescript',
      'tsx': 'text/typescript',
      // Other
      'pdf': 'application/pdf',
      'zip': 'application/zip',
    };
    return mimeTypes[ext.toLowerCase()] || 'application/octet-stream';
  };
  
  const mimeType = getMimeTypeFromExtension(fileExtension);
  // Use stored size if available, otherwise calculate from code
  const fileSize = fileBlueprint.size ?? (fileBlueprint.code ? new Blob([fileBlueprint.code]).size : 0);
  
  const mimeCategory = getMimeTypeCategory(mimeType);
  const icon = getFileIcon(fileExtension, mimeType);
  const isTextFile = mimeCategory === 'text';
  const isImage = mimeCategory === 'image';

  const handleNameSave = () => {
    if (editedName.trim()) {
      setBlueprints(prev => ({
        ...prev,
        files: prev.files.map(f =>
          f.id === fileBlueprint.id ? {...f, name: editedName.trim()} : f
        )
      }));
    }
    setIsEditingName(false);
  };

  const handleDelete = () => {
    // Remove from blueprints
    setBlueprints(prev => ({
      ...prev,
      files: prev.files.filter(f => f.id !== fileBlueprint.id)
    }));

    // Remove from code windows if open
    setCodeWindows(prev => prev.filter(cw => cw.id !== fileBlueprint.id));

    // If this file was the active window, switch to another window
    if (activeCodeWindow === fileBlueprint.id) {
      const remainingWindows = codeWindows.filter(cw => cw.id !== fileBlueprint.id);
      if (remainingWindows.length > 0) {
        setActiveCodeWindow(remainingWindows[0].id);
      } else {
        setActiveCodeWindow('');
      }
    }
  };

  const handleViewContent = () => {
    if (!isTextFile) return;

    // Detect language from file extension
    const language = getMonacoLanguage(fileExtension);

    // Open editor panel
    setBuilderMenuMode(BuilderMenuMode.CODE);
    setWindowDividerPosition(prev => prev || 50);

    // Add file to code windows
    setCodeWindows(prev => {
      const exists = prev.find(cw => cw.id === fileBlueprint.id);
      if (exists) {
        return prev;
      }
      return [
        ...prev,
        {
          id: fileBlueprint.id,
          name: fileBlueprint.name,
          code: fileBlueprint.code,
          language: language
        }
      ]
    });

    // Set as active window
    setActiveCodeWindow(fileBlueprint.id);
  };

  const handleDownload = () => {
    const blob = isImage 
      ? new Blob([Uint8Array.from(atob(fileBlueprint.code || ''), c => c.charCodeAt(0))], { type: mimeType })
      : new Blob([fileBlueprint.code || ''], { type: mimeType });
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileBlueprint.name || 'download';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const handleToggleViewMode = () => {
    setBlueprints(prev => ({
      ...prev,
      files: prev.files.map(f =>
        f.id === fileBlueprint.id
          ? { ...f, viewMode: f.viewMode === 'rendered' ? 'card' : 'rendered' }
          : f
      )
    }));
  };

  // Check if file is Babel-compatible
  const isFileBabelCompatible = isBabelCompatible(fileBlueprint.name);

  return (
    <div
      className="absolute pointer-events-auto"
      style={{
        left: fileBlueprint.position.x,
        top: fileBlueprint.position.y,
      }}
      onMouseDown={(e) => {
        console.log(e.button)
        if (e.button == 1) { return; }
        e.stopPropagation()
      }}
      onClick={(e) => e.stopPropagation()}
    >
      <div className="bg-background2 border border-border rounded-lg shadow-lg p-4 w-80">
        {/* Header with icon and name */}
        <div className="flex items-start gap-3 mb-3">
          <div className="text-3xl text-primary mt-1">
            <FontAwesomeIcon icon={icon} />
          </div>
          <div className="flex-1 min-w-0">
            {/* {isEditingName ? ( */}
              <input
                type="text"
                value={editedName}
                onChange={(e) => setEditedName(e.target.value)}
                onBlur={handleNameSave}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') handleNameSave();
                  if (e.key === 'Escape') {
                    setEditedName(fileBlueprint.name);
                    setIsEditingName(false);
                  }
                  e.stopPropagation();
                }}
                onClick={(e) => {
                  setIsEditingName(true);
                  e.stopPropagation()
                }}
                className={`
                  w-full px-2 h-11 rounded text-text focus:outline-none border focus:border-primary
                  ${isEditingName ? " bg-background" : "border-transparent"}
                `}
                // autoFocus
              />
            {/* ) : (
              <h3
                className="font-semibold text-text flex items-center truncate cursor-pointer hover:text-primary h-11"
                onClick={(e) => {
                  e.stopPropagation();
                  setIsEditingName(true);
                }}
              >
                {fileBlueprint.name}
              </h3>
            )} */}
            <p className="text-sm text-muted mt-1">
              {formatFileSize(fileSize)}
            </p>
          </div>
        </div>

        {/* Preview area */}
        {isImage && (
          <div className="mb-3 rounded overflow-hidden border border-border bg-background">
            <img
              src={fileBlueprint.code ? `data:${mimeType};base64,${fileBlueprint.code}` : 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"/>'}
              alt={fileBlueprint.name}
              className="w-full h-auto max-h-48 object-contain"
              onError={(e) => {
                console.error('Image failed to load:', fileBlueprint.name);
                e.currentTarget.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"><text x="10" y="20" fill="white">Image failed to load</text></svg>';
              }}
            />
          </div>
        )}

        {isTextFile && fileBlueprint.code && (
          <div className="mb-3 p-3 rounded bg-background border border-border">
            <pre className="text-xs text-muted font-mono whitespace-pre-wrap break-words line-clamp-3">
              {fileBlueprint.code.substring(0, 100)}
              {fileBlueprint.code.length > 100 && '...'}
            </pre>
          </div>
        )}

        <div className='flex flex-col gap-2'>
          <div className='gap-2 w-full flex'>
            {isFileBabelCompatible && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  handleToggleViewMode();
                }}
                className="flex-1 px-4 py-2.5 text-white rounded-lg bg-primary font-medium flex items-center justify-center gap-2 cursor-pointer"
              >
                <FontAwesomeIcon icon={faCode}/>
                {fileBlueprint.viewMode === 'rendered' ? 'Card View' : 'Render'}
              </button>
            )}
            {isTextFile && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  handleViewContent();
                }}
                className="flex-1 px-4 py-2.5 text-white rounded-lg bg-secondary font-medium flex items-center justify-center gap-2 cursor-pointer"
              >
                <FontAwesomeIcon icon={faEdit} />
                View/Edit
              </button>
            )}
          </div>

          <div className="flex gap-2">
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleDownload();
              }}
              className="px-4 py-2.5 bg- font-medium text-correct bg-correct/20 rounded-xl border border-correct/50 cursor-pointer"
            >
              <FontAwesomeIcon icon={faDownload} />
            </button>
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleDelete();
              }}
              className="px-4 py-2.5 bg- font-medium text-wrong bg-wrong/20 rounded-xl border border-wrong/50 cursor-pointer"
              title="Delete file"
            >
              <FontAwesomeIcon icon={faTrash} />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/sandbox/_components/notes/Note.tsx">
import { note } from "src/sandbox/types/blueprints";
import { useBlueprints } from "src/sandbox/_providers/BlueprintsContextProvider";
import NoteEditor from "./NoteEditor";
import { useNotes } from "src/sandbox/_providers/NotesContextProvider";
import { NoteOptionsVisibleState } from "src/sandbox/types/NotesOptionsTypes";
import { useMenus } from "src/sandbox/_providers/MenusContextProvider";
import { CreateComponentMenuVisibleState } from "src/sandbox/types/createComponentMenuTypes";

export default function Note({ note }: { note: note }) {
  const { setBlueprints } = useBlueprints();
  const {
    noteOptionsMenuOpen,
    setNoteOptionsMenuOpen,
    setWasNoteRecentlyActive
  } = useNotes();

  const {
    createComponentMenuOpen,
    setCreateComponentMenuOpen
  } = useMenus();

  const handleUpdate = (newContent: any) => {
    if (!newContent) {
      setBlueprints(prev => ({
        ...prev,
        notes: prev.notes.filter(n => n.id !== note.id)
      }));
      return;
    }

    setBlueprints(prev => ({
      ...prev,
      notes: prev.notes.map(n => n.id === note.id ? { ...n, content: JSON.stringify(newContent) } : n)
    }));
  };

  return (
    <div
      className="absolute bg-background border border-border shadow-lg rounded-lg overflow-hidden flex flex-col"
      style={{
        left: note.position.x,
        top: note.position.y,
        minWidth: note.width,
        minHeight: note.height
      }}
      onMouseDown={(e) => {
        // Middle click
        if (e.button === 1) {
          e.preventDefault();
          return;
        }

        // Track that we're now active in a note
        setWasNoteRecentlyActive(true);

        if (noteOptionsMenuOpen == NoteOptionsVisibleState.OPEN) {
          setNoteOptionsMenuOpen(NoteOptionsVisibleState.CLOSED);
        }
        if (createComponentMenuOpen == CreateComponentMenuVisibleState.OPEN) {
          setCreateComponentMenuOpen(CreateComponentMenuVisibleState.CLOSED)
        }
        e.stopPropagation()
      }}
      onMouseUp={(e) => {
        if (e.button === 1) return;

        e.stopPropagation()
      }}
      onClick={(e) => {
        e.stopPropagation()
      }}
      draggable={false}
    >

      <div className="flex-1 overflow-hidden relative">
        <NoteEditor
          title={note.title}
          initialContent={note.content}
          onUpdate={handleUpdate}
        />
      </div>

    </div>
  )
}
</file>

<file path="src/sandbox/_functions/grid/onMouseUp.ts">
import { useEffect } from "react";
import { useGrid } from "../../_providers/GridContextProvider";
import { useCode } from "../../_providers/CodeContextProvider";
import { CreateComponentMenuVisibleState } from "../../types/createComponentMenuTypes";
import { BuilderMenuMode, useBuilderPanel } from "../../_providers/BuilderPanelContextProvider";
import { useMenus } from "../../_providers/MenusContextProvider";
import { useNotes } from "src/sandbox/_providers/NotesContextProvider";
import { NoteOptionsVisibleState } from "src/sandbox/types/NotesOptionsTypes";

export default function useOnMouseUp() {

  const {
    setDragging,
    draggingRef,
    posMouseDown
  } = useGrid();

  const {
    noteOptionsMenuOpen,
    wasNoteRecentlyActive,
    setWasNoteRecentlyActive
  } = useNotes();

  const {
    lastPositionWindowDivider,
    windowDividerDragging,
    setWindowDivider,
    setWindowDividerPosition,
    setBuilderMenuMode,
    setPrevBuilderMenuMode
  } = useBuilderPanel();

  const {
    setCreateComponentMenuPosition,
    setCreateComponentMenuOpen
  } = useMenus();

  const {
    activeCodeWindow,
    setActiveCodeWindow
  } = useCode();

  const handleOnMouseUp = (e: MouseEvent, leaveEvent: boolean) => {
    e.preventDefault();
    draggingRef.current = false;
    setDragging(false);

    const lastX = posMouseDown.current.x;
    const lastY = posMouseDown.current.y;
    if (!lastX || !lastY) { return };

    const elem = document.elementFromPoint(e.clientX, e.clientY) as HTMLElement;
    if (elem && elem.closest('#createComponentMenu')) { return; }

    if (elem && elem.closest('.VIEW')) { return; }
    if (elem && elem.closest('.MENU')) { return; }
    if (elem && elem.closest('.dropdown')) { return; }

    const horizontalDifference = Math.abs(lastX - e.clientX);
    const verticalDifference = Math.abs(lastY - e.clientY);
    if (horizontalDifference < 2 && verticalDifference < 2) {

      if (!leaveEvent) {
        setActiveCodeWindow(null);
        setBuilderMenuMode(prev => {
          if (prev !== BuilderMenuMode.CLOSED) {
            setPrevBuilderMenuMode(prev);
          }
          return BuilderMenuMode.CLOSED;
        });
      }

      if (activeCodeWindow) { return; }
      if (noteOptionsMenuOpen == NoteOptionsVisibleState.OPEN) { return; }

      // Don't open menu if user was recently active in a note
      if (wasNoteRecentlyActive) {
        setWasNoteRecentlyActive(false);
        return;
      }

      setCreateComponentMenuOpen(prev => {
        if (prev === CreateComponentMenuVisibleState.FORCECLOSE) {
          return CreateComponentMenuVisibleState.CLOSED;
        }
        return CreateComponentMenuVisibleState.OPEN;
      });
      setCreateComponentMenuPosition({ x: e.clientX, y: e.clientY });
    }
  };

  useEffect(() => {
    const onMouseUp = (e: MouseEvent) => {
      e.preventDefault();

      setWindowDivider(false);
      windowDividerDragging.current = false;

      setWindowDividerPosition(lastPositionWindowDivider.current = 50);
    }

    const handleMouseUp = (e: MouseEvent) => onMouseUp(e);
    const handleMouseLeave = (e: MouseEvent) => onMouseUp(e);

    window.addEventListener("mouseup", handleMouseUp, { passive: false });
    window.addEventListener("mouseleave", handleMouseLeave, { passive: false });
    return () => {
      window.removeEventListener("mouseup", handleMouseUp);
      window.removeEventListener("mouseleave", handleMouseLeave);
    };
  }, [])

  return { handleOnMouseUp }

}
</file>

<file path="src/sandbox/_providers/BlueprintsContextProvider.tsx">
import { createContext, useContext, useState, ReactNode, SetStateAction, Dispatch, useEffect, useCallback, useRef } from 'react';
import { blueprints, file, note } from '../types/blueprints';

// =============================================================================
// CHANGE TYPES - Operations that can be undone/redone
// =============================================================================
export type GridChange =
  | { type: 'create'; itemType: 'file'; item: file }
  | { type: 'create'; itemType: 'note'; item: note }
  | { type: 'delete'; itemType: 'file'; item: file }
  | { type: 'delete'; itemType: 'note'; item: note };
// Future: | { type: 'move'; itemType: 'file' | 'note'; id: string; from: Position; to: Position }

// =============================================================================
// SYNC EVENT CALLBACKS - Hooks for future coop integration
// =============================================================================
export type SyncEventCallbacks = {
  // Called when local user deletes an item via undo
  // Return false to cancel the delete (e.g., if another user is editing)
  onBeforeDelete?: (change: GridChange) => boolean | Promise<boolean>;

  // Called after a change is applied locally (for socket emission)
  onChangeApplied?: (change: GridChange, direction: 'do' | 'undo' | 'redo') => void;

  // Called when ownership transfer is needed
  // e.g., client1 deletes but client2 is editing -> client2 keeps it
  onOwnershipTransfer?: (itemId: string, newOwnerId: string) => void;
};

type BlueprintsContextType = {
  // Current state (merged: local + remote in future)
  blueprints: blueprints;
  setBlueprints: Dispatch<SetStateAction<blueprints>>;

  // Remote state from other coop users (for future sync)
  remoteBlueprints: blueprints;
  setRemoteBlueprints: Dispatch<SetStateAction<blueprints>>;

  instances: blueprints[];
  setInstances: Dispatch<SetStateAction<blueprints[]>>;

  highlightInstances: boolean;
  setHighlightInstances: Dispatch<SetStateAction<boolean>>;

  // Change-based history
  localChanges: GridChange[];
  changeIndex: number;

  // Actions
  applyChange: (change: GridChange) => void;
  undoChange: () => Promise<void>;
  redoChange: () => void;

  // Sync callbacks registration
  setSyncCallbacks: (callbacks: SyncEventCallbacks) => void;

  // Helpers
  canUndo: boolean;
  canRedo: boolean;
};

const BlueprintsContext = createContext<BlueprintsContextType | undefined>(undefined);

// =============================================================================
// HELPER: Apply a change to blueprints
// =============================================================================
const applyChangeToBlueprints = (bp: blueprints, change: GridChange): blueprints => {
  if (change.type === 'create') {
    if (change.itemType === 'file') {
      return { ...bp, files: [...bp.files, change.item] };
    } else {
      return { ...bp, notes: [...bp.notes, change.item as note] };
    }
  } else if (change.type === 'delete') {
    if (change.itemType === 'file') {
      return { ...bp, files: bp.files.filter(f => f.id !== change.item.id) };
    } else {
      return { ...bp, notes: bp.notes.filter(n => n.id !== (change.item as note).id) };
    }
  }
  return bp;
};

// =============================================================================
// HELPER: Get inverse of a change (for undo)
// =============================================================================
const getInverseChange = (change: GridChange): GridChange => {
  if (change.type === 'create') {
    return { ...change, type: 'delete' };
  } else {
    return { ...change, type: 'create' };
  }
};

// =============================================================================
// PROVIDER
// =============================================================================
export const BlueprintsProvider = ({ children }: { children: ReactNode }) => {
  // Local blueprints (items created/owned by this user)
  const [localBlueprints, setLocalBlueprints] = useState<blueprints>({
    files: [],
    notes: [],
    drawings: [],
  });

  // Remote blueprints from coop users (for future sync)
  const [remoteBlueprints, setRemoteBlueprints] = useState<blueprints>({
    files: [],
    notes: [],
    drawings: [],
  });

  // Merged state for rendering
  const [blueprints, setBlueprints] = useState<blueprints>({
    files: [],
    notes: [],
    drawings: [],
  });

  // Merge local + remote whenever either changes
  useEffect(() => {
    setBlueprints({
      files: [...localBlueprints.files, ...remoteBlueprints.files],
      notes: [...localBlueprints.notes, ...remoteBlueprints.notes],
      drawings: [...localBlueprints.drawings, ...remoteBlueprints.drawings],
    });
  }, [localBlueprints, remoteBlueprints]);

  const [instances, setInstances] = useState<blueprints[]>([]);
  const [highlightInstances, setHighlightInstances] = useState(true);

  // Change-based history (only YOUR changes, not remote)
  const [localChanges, setLocalChanges] = useState<GridChange[]>([]);
  const [changeIndex, setChangeIndex] = useState<number>(-1); // -1 = no changes yet

  // Sync callbacks (registered by sync system)
  const syncCallbacksRef = useRef<SyncEventCallbacks>({});
  const setSyncCallbacks = useCallback((callbacks: SyncEventCallbacks) => {
    syncCallbacksRef.current = callbacks;
  }, []);

  // Apply a new change (create/delete)
  const applyChange = useCallback((change: GridChange) => {
    // Truncate any redo history
    setLocalChanges(prev => [...prev.slice(0, changeIndex + 1), change]);
    setChangeIndex(prev => prev + 1);

    // Apply to local blueprints
    setLocalBlueprints(prev => applyChangeToBlueprints(prev, change));

    // Notify sync system
    syncCallbacksRef.current.onChangeApplied?.(change, 'do');
  }, [changeIndex]);

  // Undo last change
  const undoChange = useCallback(async () => {
    if (changeIndex < 0) return;

    const changeToUndo = localChanges[changeIndex];
    const inverseChange = getInverseChange(changeToUndo);

    // If this is a delete operation (undoing a create), check with sync system
    // This is where ownership transfer logic can happen
    if (inverseChange.type === 'delete') {
      const shouldProceed = await syncCallbacksRef.current.onBeforeDelete?.(inverseChange);
      if (shouldProceed === false) {
        // Sync system blocked the delete (e.g., another user is editing)
        // The item should be transferred to remote ownership
        const itemId = inverseChange.item.id;

        // Move item from local to remote
        if (inverseChange.itemType === 'file') {
          const item = localBlueprints.files.find(f => f.id === itemId);
          if (item) {
            setLocalBlueprints(prev => ({
              ...prev,
              files: prev.files.filter(f => f.id !== itemId)
            }));
            setRemoteBlueprints(prev => ({
              ...prev,
              files: [...prev.files, item]
            }));
          }
        } else {
          const item = localBlueprints.notes.find(n => n.id === itemId);
          if (item) {
            setLocalBlueprints(prev => ({
              ...prev,
              notes: prev.notes.filter(n => n.id !== itemId)
            }));
            setRemoteBlueprints(prev => ({
              ...prev,
              notes: [...prev.notes, item]
            }));
          }
        }

        // Remove this change from history (it's now owned by remote)
        setLocalChanges(prev => prev.filter((_, i) => i !== changeIndex));
        setChangeIndex(prev => prev - 1);
        return;
      }
    }

    // Apply inverse change
    setLocalBlueprints(prev => applyChangeToBlueprints(prev, inverseChange));
    setChangeIndex(prev => prev - 1);

    // Notify sync system
    syncCallbacksRef.current.onChangeApplied?.(inverseChange, 'undo');
  }, [changeIndex, localChanges, localBlueprints]);

  // Redo change
  const redoChange = useCallback(() => {
    if (changeIndex >= localChanges.length - 1) return;

    const changeToRedo = localChanges[changeIndex + 1];

    setLocalBlueprints(prev => applyChangeToBlueprints(prev, changeToRedo));
    setChangeIndex(prev => prev + 1);

    // Notify sync system
    syncCallbacksRef.current.onChangeApplied?.(changeToRedo, 'redo');
  }, [changeIndex, localChanges]);

  const canUndo = changeIndex >= 0;
  const canRedo = changeIndex < localChanges.length - 1;

  return (
    <BlueprintsContext.Provider value={{
      blueprints,
      setBlueprints,

      remoteBlueprints,
      setRemoteBlueprints,

      instances,
      setInstances,

      highlightInstances,
      setHighlightInstances,

      localChanges,
      changeIndex,

      applyChange,
      undoChange,
      redoChange,

      setSyncCallbacks,

      canUndo,
      canRedo,
    }}>
      {children}
    </BlueprintsContext.Provider>
  );
};

export const useBlueprints = () => {
  const context = useContext(BlueprintsContext);
  if (!context) {
    throw new Error('useBlueprints must be used within a BlueprintsProvider');
  }
  return context;
};
</file>

<file path="src/sandbox/types/createComponentMenuTypes.ts">
export enum CreateComponentMenuVisibleState {
  OPEN = "OPEN",
  FORCECLOSE = "FORCECLOSE",
  CLOSED = "CLOSED",
}
</file>

<file path="src/sandbox/_components/menus/BottomLeftMenu.tsx">
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import Tooltip from "src/_components/Tooltip";
import { faEyeSlash, faPen, faBorderAll, faEye, faBorderNone, faUndo, faRedo } from "@fortawesome/free-solid-svg-icons";
import { useDrawing } from "src/sandbox/_providers/DrawingContextProvider";
import { useBlueprints } from "src/sandbox/_providers/BlueprintsContextProvider";

export default function BottomLeftMenu() {

  const {
    drawingEnabled,
    setDrawingEnabled,
    showDrawings,
    setShowDrawings,
  } = useDrawing();

  const {
    highlightInstances,
    setHighlightInstances,
    canUndo,
    canRedo,
    undoChange,
    redoChange
  } = useBlueprints();

  return (
    <div className={`
      MENU
      absolute bottom-4 left-4 z-50 text-text text-sm flex items-center gap-2
    `}>

      {/* draw icon */}
      <Tooltip
        content={drawingEnabled ? "Disable drawing mode" : "Enable drawing mode"}
        offsetY={"-200% - 12px"}
        offsetX={"50%"}
        className="bg-background2 p-2 text-nowrap border border-border2 rounded"
      >
        <div
          className={`
            MENU
            p-2 rounded-full bg-background2 outline
            ${drawingEnabled ? "outline-border2" : "outline-none"}
          `}
          onClick={() => setDrawingEnabled(!drawingEnabled)}
        >
          <FontAwesomeIcon
            className="pointer-events-none"
            icon={faPen}
          />
        </div>
      </Tooltip>

      {/* Hide drawings */}
      <Tooltip
        content={showDrawings ? "Hide drawings" : "Show drawings"}
        offsetY={"-200% - 12px"}
        offsetX={"50%"}
        className={`bg-background2 p-2 text-nowrap border border-container2-border rounded`}
      >
        <div
          className={`
            MENU
            p-2 rounded-full bg-background2 outline
            ${showDrawings ? "outline-border2" : "outline-none"}
          `}
          onClick={() => setShowDrawings(!showDrawings)}
        >
          <FontAwesomeIcon
            className="pointer-events-none"
            icon={showDrawings ? faEye : faEyeSlash}
          />
        </div>
      </Tooltip>

      {/* Toggle Outlines */}
      <Tooltip
        content={highlightInstances ? "Hide outlines" : "Show outlines"}
        offsetY={"-200% - 12px"}
        offsetX={"50%"}
        className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
      >
        <div
          className={`
            MENU
            p-2 rounded-full bg-background2 outline
            ${highlightInstances ? "outline-border2" : "outline-none"}
          `}
          onClick={() => setHighlightInstances(prev => !prev)}
        >
          <FontAwesomeIcon
            className="pointer-events-none"
            icon={highlightInstances ? faBorderAll : faBorderNone}
          />
        </div>
      </Tooltip>

      {/* Undo */}
      <Tooltip
        content={"Undo (Ctrl+Z)"}
        offsetY={"-200% - 12px"}
        offsetX={"50%"}
        className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
      >
        <div
          className={`
            MENU
            p-2 rounded-full bg-background2 outline outline-none
            ${canUndo ? "cursor-pointer hover:outline-border2" : "opacity-50 cursor-not-allowed"}
          `}
          onClick={() => canUndo && undoChange()}
        >
          <FontAwesomeIcon
            className="pointer-events-none"
            icon={faUndo}
          />
        </div>
      </Tooltip>

      {/* Redo */}
      <Tooltip
        content={"Redo (Ctrl+Y)"}
        offsetY={"-200% - 12px"}
        offsetX={"50%"}
        className={`bg-background2 p-2 text-nowrap border border-border2 rounded`}
      >
        <div
          className={`
            MENU
            p-2 rounded-full bg-background2 outline outline-none
            ${canRedo ? "cursor-pointer hover:outline-border2" : "opacity-50 cursor-not-allowed"}
          `}
          onClick={() => canRedo && redoChange()}
        >
          <FontAwesomeIcon
            className="pointer-events-none"
            icon={faRedo}
          />
        </div>
      </Tooltip>

      {/* Toggle Selector mode */}
      {/* <Tooltip
        content={highlightInstances ? "Hide outlines" : "Show outlines"}
        offsetY={"-200% - 12px"}
        offsetX={"50%"}
        className={`bg-container2 p-2 text-nowrap border border-container2-border rounded`}
      >
        <div
          className={`
            MENU
            p-2 rounded-full bg-container2 outline
            ${highlightInstances ? "outline-primary" : "outline-none"}
          `}
          onClick={() => setHighlightInstances(prev => !prev)}
        >
          <FontAwesomeIcon
            className="pointer-events-none"
            icon={faBorderAll}
          />
        </div>
      </Tooltip> */}

      {/* //? disabled for now cause editor rerenders every time we time so the zoomsize gets reset, also it dont work with the scroll option */}
      {/* <Tooltip
        content={"Change zoom level"}
        offsetY={"-200% - 12px"}
        offsetX={"20px"}
        className={`bg-container2 p-2 text-nowrap border border-container2-border rounded`}
      >
        <div className={`
          MENU
          p-2 rounded-full bg-container2 flex gap-1 items-center
        `}>
          <div 
            className="hover:bg-background h-6 w-6 rounded-full flex items-center justify-center"
            onClick={() => { setCodeWindowSize(prev => prev - 2) }}
          >
            <FontAwesomeIcon
              icon={faMinus}
            />
          </div>
          <div>{Math.round(codeWindowSize/16 * 100)}%</div>
          <div 
            className="hover:bg-background h-6 w-6 rounded-full flex items-center justify-center"
            onClick={() => { setCodeWindowSize(prev => prev + 2) }}
          >
            <FontAwesomeIcon
              icon={faPlus}
            />
          </div>
        </div>  
      </Tooltip> */}

    </div>
  )
}
</file>

<file path="src/sandbox/_functions/codeEditor/compilerOptions.ts">
import reactIndex from "../../../types/react/index.d.ts?raw";
import reactGlobal from "../../../types/react/global.d.ts?raw";
import reactDom from "../../../types/react-dom.d.ts?raw";
import reactJsxRuntime from "../../../types/react-jsx-runtime.d.ts?raw";
import { typescript } from "monaco-editor";
// import reactHooksGlobals from "../../../types/react-hooks.d.ts?raw";

export default function setCompilerOptions(monaco: typeof import("monaco-editor")) {

  //? monaco.languages.typescript is deprecated, but using monaco.typescript or just the typescript export from monaco which is recommended it crashes the editor
  const ts = monaco.languages.typescript as any;
  // const ts = monaco.typescript;
  // const ts = typescript;

  ts.typescriptDefaults.setCompilerOptions({
    target: ts.ScriptTarget.ESNext,
    module: ts.ModuleKind.ESNext,
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    jsx: ts.JsxEmit.ReactJSX,
    jsxFactory: "React.createElement",
    jsxFragmentFactory: "React.Fragment",
    allowJs: true,
    esModuleInterop: true,
    allowSyntheticDefaultImports: true,
    skipLibCheck: true,
    isolatedModules: true,
  });

  // const model = monaco.editor.getModels()[0];
  // if (model) {
  //   monaco.editor.setModelLanguage(model, "typescript");
  // }

  // Inject all React-related types
  ts.typescriptDefaults.addExtraLib(
    reactIndex,
    "file:///node_modules/@types/react/index.d.ts"
  );
  ts.typescriptDefaults.addExtraLib(
    reactGlobal,
    "file:///node_modules/@types/react/global.d.ts"
  );
  ts.typescriptDefaults.addExtraLib(
    reactDom,
    "file:///node_modules/@types/react-dom/index.d.ts"
  );
  ts.typescriptDefaults.addExtraLib(
    reactJsxRuntime,
    "file:///node_modules/@types/react/jsx-runtime.d.ts"
  );
  // ts.typescriptDefaults.addExtraLib(
  //   reactHooksGlobals,
  //   "file:///react-hooks-globals.d.ts"
  // );


  const userComponents = [
    { name: "Dropdown", code: "export function Dropdown() { return <div>...</div> }" },
    { name: "MyButton", code: "export function MyButton() { return <button>Click</button> }" }
  ];

  const componentIndex = `
    declare module "components" {
      import React from "react";
      ${userComponents.map(c => `export { ${c.name} } from "components/${c.name}";`).join("\n")}
    }
  `;

  ts.typescriptDefaults.addExtraLib(
    componentIndex,
    "file:///components/index.d.ts"
  );

  userComponents.forEach((c) => {
    ts.typescriptDefaults.addExtraLib(
      `
        declare module "components/${c.name}" {
          import React from "react";
          export const ${c.name}: React.FC<any>;
        }
      `,
      `file:///components/${c.name}.d.ts`
    );
  });

  ts.typescriptDefaults.addExtraLib(
    `
      import * as components from "components";
      declare global {
        const { ${userComponents.map(c => c.name).join(", ")} } = components;
      }
    `,
    "file:///globalComponents.d.ts"
  );




  // this line in the code editor
  // import { MyButton } from "components/ComponentTest";

  // ts.typescriptDefaults.addExtraLib(
  //   `
  //   declare module "components/ComponentTest" {
  //     import React from "react";
  //     export function MyButton(props: { label: string }) {
  //       return <button>{props.label}</button>;
  //     };
  //   }
  //   `,
  //   `file:///components/ComponentTest.d.ts`
  // );
}
</file>

<file path="src/sandbox/_functions/grid/onFileDrop.ts">
import { useGrid } from "../../_providers/GridContextProvider";
import { useBlueprints, GridChange } from "../../_providers/BlueprintsContextProvider";
import { useDrawing } from "../../_providers/DrawingContextProvider";
import { getFileExtension, getMimeTypeCategory, getMonacoLanguage, readFileAsBase64, readFileAsText, validateFileSize } from "../files/fileUtils";
import { file } from "../../types/blueprints";

export default function useOnFileDrop() {
  const { zoom, offset } = useGrid();
  const { applyChange } = useBlueprints();
  const { drawingEnabled } = useDrawing();

  const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

  const handleDragOver = (e: DragEvent) => {
    // Don't allow drag-and-drop when drawing is enabled
    if (drawingEnabled) { return; }

    // Check if dragging files
    if (e.dataTransfer?.types.includes('Files')) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
    }
  };

  const handleDrop = async (e: DragEvent) => {
    // Don't allow drag-and-drop when drawing is enabled
    if (drawingEnabled) {
      console.log('[DROP EVENT] Blocked - drawing is enabled');
      return;
    }

    e.preventDefault();

    const files = e.dataTransfer?.files;
    if (!files || files.length === 0) return;

    // Process each file
    for (let i = 0; i < files.length; i++) {
      const droppedFile = files[i];

      // Validate file size
      if (!validateFileSize(droppedFile, MAX_FILE_SIZE)) {
        alert(`File "${droppedFile.name}" exceeds 5MB limit. File size: ${(droppedFile.size / 1024 / 1024).toFixed(2)}MB`);
        continue;
      }

      try {
        const mimeCategory = getMimeTypeCategory(droppedFile.type);
        const extension = getFileExtension(droppedFile.name);
        const monacoLanguage = getMonacoLanguage(extension);

        // Check if the file extension is a known text/code type by checking if Monaco recognizes it
        // This handles cases where browsers don't provide proper MIME types for code files (.tsx, .ts, etc.)
        const isKnownTextExtension = monacoLanguage !== 'plaintext' || extension === 'txt';

        let fileContent: string = '';

        // Read file based on type - prioritize extension check for code files
        if (isKnownTextExtension || mimeCategory === 'text') {
          fileContent = await readFileAsText(droppedFile);
        } else if (mimeCategory === 'image') {
          fileContent = await readFileAsBase64(droppedFile);
        } else {
          // Binary files (PDF, ZIP, etc.)
          fileContent = await readFileAsBase64(droppedFile);
        }

        // Convert screen coordinates to world coordinates
        const worldX = (e.clientX - offset.x) / zoom;
        const worldY = (e.clientY - 50 - offset.y) / zoom;

        // Create new file blueprint (offset each file slightly)
        const newFile: file = {
          id: `file-${Date.now()}-${i}`,
          position: { x: worldX + (i * 20), y: worldY + (i * 20) },
          name: droppedFile.name,
          code: fileContent,
          size: droppedFile.size,
        };

        // Apply change for this file
        const change: GridChange = {
          type: 'create',
          itemType: 'file',
          item: newFile
        };
        applyChange(change);
      } catch (error) {
        console.error('Error reading file:', error);
        alert(`Failed to read file "${droppedFile.name}". Please try again.`);
      }
    }
  };

  return { handleDragOver, handleDrop };
}
</file>

<file path="src/sandbox/_providers/DrawingContextProvider.tsx">
import { createContext, useContext, useState, ReactNode, SetStateAction, Dispatch, useEffect } from 'react';

export type DrawingPoint = {
  x: number;
  y: number;
  color: string;
  size: number;
}

export type LineStyle = 'solid' | 'dashed' | 'dotted';

export type StrokeData = {
  id: string;
  points: DrawingPoint[];
  fill?: string;
  text?: string;
  width?: number; // For text bounds
  height?: number; // For text bounds
  lineStyle?: LineStyle; // Line style: solid, dashed, or dotted
}

export enum ErasingMode {
  DISABLED,
  PARTIAL,
  FULL
}

export type ShapeType = 'square' | 'circle' | 'diamond' | 'line' | 'arrow';

type DrawingContextType = {
  strokes: StrokeData[];
  setStrokes: Dispatch<SetStateAction<StrokeData[]>>;

  currentPoints: DrawingPoint[];
  setCurrentPoints: Dispatch<SetStateAction<DrawingPoint[]>>;

  brushSize: number;
  setBrushSize: Dispatch<SetStateAction<number>>;

  brushColor: string;
  setBrushColor: Dispatch<SetStateAction<string>>;

  drawingEnabled: boolean;
  setDrawingEnabled: Dispatch<SetStateAction<boolean>>;

  showDrawings: boolean;
  setShowDrawings: Dispatch<SetStateAction<boolean>>;

  erasing: ErasingMode;
  setErasing: Dispatch<SetStateAction<ErasingMode>>;

  activeShape: ShapeType | null;
  setActiveShape: Dispatch<SetStateAction<ShapeType | null>>;

  selectionMode: boolean;
  setSelectionMode: Dispatch<SetStateAction<boolean>>;

  selectedStrokeIds: string[];
  setSelectedStrokeIds: Dispatch<SetStateAction<string[]>>;

  // Feature Toggles
  showMeasurements: boolean;
  setShowMeasurements: Dispatch<SetStateAction<boolean>>;

  snappingEnabled: boolean;
  setSnappingEnabled: Dispatch<SetStateAction<boolean>>;

  marqueeMode: boolean;
  setMarqueeMode: Dispatch<SetStateAction<boolean>>;
  marqueeBox: { x: number, y: number, width: number, height: number } | null;
  setMarqueeBox: Dispatch<SetStateAction<{ x: number, y: number, width: number, height: number } | null>>;

  fillMode: boolean;
  setFillMode: Dispatch<SetStateAction<boolean>>;

  textMode: boolean;
  setTextMode: Dispatch<SetStateAction<boolean>>;

  strokeHistory: StrokeData[][]
  setStrokeHistory: Dispatch<SetStateAction<StrokeData[][]>>
  historyIndex: number
  setHistoryIndex: Dispatch<SetStateAction<number>>

  lineStyle: LineStyle;
  setLineStyle: Dispatch<SetStateAction<LineStyle>>;

  updateBrushColor: (color: string) => void;
  updateBrushSize: (size: number) => void;
};

const DrawingContext = createContext<DrawingContextType | undefined>(undefined);

export const DrawingProvider = ({ children }: { children: ReactNode }) => {
  const [strokes, setStrokes] = useState<StrokeData[]>([])
  const [currentPoints, setCurrentPoints] = useState<DrawingPoint[]>([])
  const [drawingEnabled, setDrawingEnabled] = useState(false);
  const [showDrawings, setShowDrawings] = useState(true);

  const [strokeHistory, setStrokeHistory] = useState<StrokeData[][]>([[]])
  const [historyIndex, setHistoryIndex] = useState<number>(0);

  //? tools in the drawing menu when drawing is enabled
  const [brushSize, setBrushSize] = useState<number>(10)
  const [brushColor, setBrushColor] = useState<string>('#FFFFFF')
  const [erasing, setErasing] = useState<ErasingMode>(ErasingMode.DISABLED);
  const [activeShape, setActiveShape] = useState<ShapeType | null>(null);

  const [selectionMode, setSelectionMode] = useState<boolean>(false);
  const [selectedStrokeIds, setSelectedStrokeIds] = useState<string[]>([]);

  const [showMeasurements, setShowMeasurements] = useState<boolean>(false);
  const [snappingEnabled, setSnappingEnabled] = useState<boolean>(true); // Default to true as per request "fix when moving around objects like figma"

  const [marqueeMode, setMarqueeMode] = useState<boolean>(false);
  const [marqueeBox, setMarqueeBox] = useState<{ x: number, y: number, width: number, height: number } | null>(null);
  const [fillMode, setFillMode] = useState<boolean>(false);
  const [textMode, setTextMode] = useState<boolean>(false);
  const [lineStyle, setLineStyle] = useState<LineStyle>('solid');

  // Sync strokes to history when historyIndex changes (for undo/redo)
  useEffect(() => {
    if (strokeHistory.length > 0 && historyIndex >= 0 && historyIndex < strokeHistory.length) {
      setStrokes(strokeHistory[historyIndex]);
    }
  }, [historyIndex, strokeHistory]);

  // Clamp historyIndex to valid range
  useEffect(() => {
    if (historyIndex >= strokeHistory.length && strokeHistory.length > 0) {
      setHistoryIndex(strokeHistory.length - 1);
    }
  }, [historyIndex, strokeHistory.length]);

  // Clear selection when switching away from marquee mode
  useEffect(() => {
    if (!marqueeMode) {
      setMarqueeBox(null);
    }
  }, [marqueeMode]);

  useEffect(() => {
    if (erasing !== ErasingMode.DISABLED && brushSize < 60) {
      setBrushSize(Math.min(300, brushSize * 6))
    } else if (erasing === ErasingMode.DISABLED) {
      setBrushSize(Math.max(10, brushSize / 6))
    }
  }, [erasing])

  return (
    <DrawingContext.Provider value={{
      strokes,
      setStrokes,

      currentPoints,
      setCurrentPoints,

      brushSize,
      setBrushSize,

      brushColor,
      setBrushColor,

      drawingEnabled,
      setDrawingEnabled,

      showDrawings,
      setShowDrawings,

      erasing,
      setErasing,

      activeShape,
      setActiveShape,

      selectionMode,
      setSelectionMode,

      selectedStrokeIds,
      setSelectedStrokeIds,

      showMeasurements,
      setShowMeasurements,

      snappingEnabled,
      setSnappingEnabled,

      marqueeMode,
      setMarqueeMode,
      marqueeBox,
      setMarqueeBox,

      fillMode,
      setFillMode,
      textMode,
      setTextMode,
      strokeHistory,
      setStrokeHistory,
      historyIndex,
      setHistoryIndex,
      lineStyle,
      setLineStyle,

      // Helper to update color (handling selection logic)
      updateBrushColor: (color: string) => {
        setBrushColor(color);
        if (selectedStrokeIds.length > 0) {
          const newStrokes = strokes.map(s => {
            if (selectedStrokeIds.includes(s.id)) {
              return {
                ...s,
                // If the shape has a fill, update it to match the new color
                fill: s.fill ? color : undefined,
                points: s.points.map(p => ({ ...p, color }))
              };
            }
            return s;
          });
          setStrokes(newStrokes);
          setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), newStrokes]);
          setHistoryIndex(prev => prev + 1);
        } else if (selectionMode) {
          // If in selection mode but nothing selected, switch to drawing (disable selection mode)
          setSelectionMode(false);
        }
        if (erasing) setErasing(ErasingMode.DISABLED);
      },

      updateBrushSize: (size: number) => {
        setBrushSize(size);
        if (selectedStrokeIds.length > 0) {
          const newStrokes = strokes.map(s => {
            if (selectedStrokeIds.includes(s.id)) {
              return {
                ...s,
                points: s.points.map(p => ({ ...p, size }))
              };
            }
            return s;
          });
          setStrokes(newStrokes);
          setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), newStrokes]);
          setHistoryIndex(prev => prev + 1);
        }
      }
    }}>
      {children}
    </DrawingContext.Provider>
  );
};

export const useDrawing = () => {
  const context = useContext(DrawingContext);
  if (!context) {
    throw new Error('useDrawing must be used within a DrawingProvider');
  }
  return context;
};
</file>

<file path="src/sandbox/_providers/GridContextProvider.tsx">
import { createContext, useContext, useState, ReactNode, RefObject, SetStateAction, Dispatch, useRef } from 'react';

type GridContextType = {
  containerRef: RefObject<HTMLDivElement | null>;
  draggingRef: RefObject<boolean>;
  lastPos: RefObject<{ x: number; y: number }>;
  posMouseDown: RefObject<{ x: number; y: number }>;
  zoomRef: RefObject<number>;

  dragging: boolean;
  setDragging: Dispatch<SetStateAction<boolean>>;

  zoom: number;
  setZoom: Dispatch<SetStateAction<number>>;

  offset: { x: number; y: number };
  setOffset: Dispatch<SetStateAction<{ x: number; y: number }>>;
};

const GridContext = createContext<GridContextType | undefined>(undefined);

export const GridProvider = ({ children }: { children: ReactNode }) => {
  const [zoom, setZoom] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);

  const containerRef = useRef<HTMLDivElement>(null);
  const draggingRef = useRef(false);
  const lastPos = useRef({ x: 0, y: 0 });
  const posMouseDown = useRef({ x: 0, y: 0 });
  const zoomRef = useRef(1);

  // Keep zoomRef in sync with zoom state
  zoomRef.current = zoom;

  return (
    <GridContext.Provider value={{
      containerRef,
      draggingRef,
      lastPos,
      posMouseDown,
      zoomRef,

      dragging,
      setDragging,

      zoom,
      setZoom,

      offset,
      setOffset,
    }}>
      {children}
    </GridContext.Provider>
  );
};

export const useGrid = () => {
  const context = useContext(GridContext);
  if (!context) {
    throw new Error('useGrid must be used within a GridProvider');
  }
  return context;
};
</file>

<file path="src/sandbox/types/blueprints.ts">
import { Viewports } from "./viewportMapping";

export type note = {
  id: string;
  position: { x: number; y: number; };
  title: string; // Title of the note for display and search
  content: string; // JSON content from TipTap
  width: number;
  height: number;
}

export type drawing = {
  id: string;
  position: { x: number; y: number; };
}

export type codeContext = {
  id: string;
  name: string;
  code: string;
  language?: string; // Optional language for Monaco editor
}

/**
 * Unified file type - replaces component, screen, and previous file type
 * Babel compatibility is determined dynamically from filename extension
 */
export type file = {
  id: string;
  position: { x: number; y: number };
  name: string; // Full filename with extension (e.g., "MyComponent.tsx")
  code: string; // Source code content

  // Optional viewport settings for rendered files
  viewport?: Viewports;
  rendered?: boolean;
  // viewport?: {
  //   width: number;
  //   height: number;
  //   enabled: boolean;
  // };

  // View mode: 'card' shows file card UI, 'rendered' shows Babel-compiled output
  viewMode?: 'card' | 'rendered';

  // Metadata
  size?: number; // Original file size in bytes
  lastModified?: number;
}

export type blueprints = {
  files: file[];
  notes: note[];
  drawings: drawing[];
}
</file>

<file path="src/sandbox/_components/drawing/DrawingLayer.tsx">
import { useRef, useState, useEffect } from 'react'
import { useGrid } from '../../_providers/GridContextProvider'
import { useDrawing } from 'src/sandbox/_providers/DrawingContextProvider'
import { RenderDrawingPath } from '../../_functions/drawing/RenderDrawingPath'
import useDrawingEvents from 'src/sandbox/_functions/drawing/useDrawingEvents'
import notify from 'src/_functions/notify'
import { getStrokesBoundingBox } from '../../_functions/drawing/selectionUtils'
import { measureTextDimensions } from '../../_functions/drawing/sharedUtils'

import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faTrash } from '@fortawesome/free-solid-svg-icons'

export default function DrawingLayer() {

  const {
    strokes,
    setStrokes,

    currentPoints,
    setCurrentPoints,

    drawingEnabled,
    showDrawings,

    brushSize,
    erasing,

    strokeHistory,
    setStrokeHistory,
    historyIndex,
    setHistoryIndex,

    selectedStrokeIds,
    setSelectedStrokeIds,
    selectionMode,
    showMeasurements,
    lineStyle
  } = useDrawing();

  const {
    zoom,
    offset,
  } = useGrid();

  const {
    handleDrawing,
    handlePointerUp,
    selectionBox,
    dragOffset,
    activeSnappingGuides,
    cursorStyle,
    editingTextId
  } = useDrawingEvents();

  const { marqueeBox } = useDrawing(); // Get persistent marquee box


  useEffect(() => {
    setStrokes(strokeHistory[historyIndex] || [])
    setCurrentPoints([])
  }, [historyIndex, strokeHistory, setStrokes, setCurrentPoints])

  useEffect(() => {
    if (!drawingEnabled) { return }
    // setCurrentPoints([])
    // setStrokes([])

    if (showDrawings) { return }
    notify.info({ key: "drawingsDisabled" })

  }, [drawingEnabled])

  const overlayRef = useRef<SVGSVGElement | null>(null)
  const [eraserPos, setEraserPos] = useState<{ x: number, y: number } | null>(null)

  // Calculate selection bounding box
  // We need to account for dragOffset for the selected strokes
  const getSelectionBounds = () => {
    if (selectedStrokeIds.length === 0) return null;

    // Create temporary stroke objects with applied drag if needed
    const selectedStrokes = strokes
      .filter(s => selectedStrokeIds.includes(s.id))
      .map(s => {
        if (dragOffset) {
          return {
            ...s,
            points: s.points.map(p => ({ ...p, x: p.x + dragOffset.x, y: p.y + dragOffset.y }))
          };
        }
        return s;
      });

    return getStrokesBoundingBox(selectedStrokes);
  }

  const selectionBounds = getSelectionBounds();

  return (
    <div className={`${!drawingEnabled ? "pointer-events-none" : "" }`} draggable={false} onDragStart={(e) => e.preventDefault()} style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}>
      {showDrawings && (
        <svg
          ref={overlayRef}
          width="100%"
          height="100%"
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            overflow: 'visible',
            touchAction: 'none',
            userSelect: 'none',
            WebkitUserSelect: 'none',
            cursor: cursorStyle ? cursorStyle : (drawingEnabled ? (erasing ? 'none' : 'crosshair') : 'default')
          }}
          className={`${drawingEnabled ? (erasing ? 'cursor-none' : '') : 'pointer-events-none'}`}
          onDragStart={(e) => e.preventDefault()}
          onMouseDown={(e) => { e.preventDefault(); }}
          onPointerDown={(e) => handleDrawing(e, setEraserPos, overlayRef)}
          onPointerMove={(e) => handleDrawing(e, setEraserPos, overlayRef)}
          onPointerUp={handlePointerUp}
          onPointerLeave={() => setEraserPos(null)}
        />
      )}

      <div
        draggable={false}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          transform: `translate(${offset.x}px, ${offset.y}px) scale(${zoom})`,
          transformOrigin: '0 0',
          pointerEvents: 'none',
        }}
        className={`h-full w-full`}
      >
        {showDrawings && (
          <svg
            width="100%"
            height="100%"
            style={{ overflow: 'visible', pointerEvents: 'none' }}
          >
            {strokes.map(s => {
              const isSelected = selectedStrokeIds.includes(s.id);
              const transform = isSelected && dragOffset ? `translate(${dragOffset.x}, ${dragOffset.y})` : undefined;

              if (s.text !== undefined) {
                const p = s.points[0];
                const isEditing = editingTextId === s.id;
                const fontSize = s.points[0].size || 20;

                // Calculate dimensions dynamically from content
                const { width: calculatedWidth, height: calculatedHeight } = measureTextDimensions(s.text, fontSize);

                return (
                  <g key={s.id} transform={transform} style={{ opacity: isSelected && dragOffset ? 0.7 : 1 }}>
                    <foreignObject
                      x={p.x}
                      y={p.y}
                      width={calculatedWidth}
                      height={calculatedHeight}
                      style={{ overflow: 'visible' }}
                    >
                      {isEditing ? (
                        <textarea
                          ref={(el) => { if (el) { el.focus(); } }}
                          className="bg-transparent outline-none resize-none text-text-primary w-full h-full p-1"
                          style={{
                            fontSize: fontSize,
                            lineHeight: '1.2',
                            fontFamily: 'sans-serif',
                            color: s.points[0].color,
                            overflow: 'hidden',
                            whiteSpace: 'pre',
                            caretColor: '#FFFFFF',
                            fontWeight: 500
                          }}
                          value={s.text}
                          onChange={(e) => {
                            // Update text
                            const val = e.target.value;

                            // Measure width using canvas context
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            let measuredWidth = 50;
                            if (context) {
                              context.font = `${fontSize}px sans-serif`;
                              const lines = val.split('\n');
                              let maxWidth = 0;
                              lines.forEach(line => {
                                const w = context.measureText(line).width;
                                if (w > maxWidth) maxWidth = w;
                              });
                              measuredWidth = Math.max(50, maxWidth + 20); // Add padding
                            }

                            // Update height
                            e.target.style.height = 'auto';
                            e.target.style.height = e.target.scrollHeight + 'px';
                            const newHeight = e.target.scrollHeight;

                            setStrokes(prev => prev.map(st => {
                              if (st.id === s.id) {
                                return { ...st, text: val, width: measuredWidth, height: Math.max(30, newHeight) };
                              }
                              return st;
                            }));
                          }}
                          onPointerDown={(e) => e.stopPropagation()}
                        />
                      ) : (
                        <div
                          className="p-1 w-full h-full select-none"
                          style={{
                            fontSize: fontSize,
                            lineHeight: '1.2',
                            fontFamily: 'sans-serif',
                            color: s.points[0].color,
                            pointerEvents: 'none',
                            whiteSpace: 'pre'
                          }}
                        >
                          {s.text}
                        </div>
                      )}
                    </foreignObject>
                  </g>
                )
              }

              return (
                <g key={s.id} transform={transform} style={{ opacity: isSelected && dragOffset ? 0.7 : 1 }}>
                  <RenderDrawingPath points={s.points} zoom={zoom} fill={s.fill} strokeData={s} />
                </g>
              );
            })}

            {/* Selection Bounding Box */}
            {selectionBounds && drawingEnabled && (selectionMode || selectedStrokeIds.length > 0) && (
              <>
                <rect
                  x={selectionBounds.minX}
                  y={selectionBounds.minY}
                  width={selectionBounds.maxX - selectionBounds.minX}
                  height={selectionBounds.maxY - selectionBounds.minY}
                  fill="none"
                  stroke="#00aaff"
                  strokeWidth={Math.max(1, 1 / zoom)}
                  strokeDasharray="4 4"
                  vectorEffect="non-scaling-stroke"
                />

                {/* Resize Handles - Hide if editing text */}
                {!editingTextId && (
                  <>
                    <rect
                      x={selectionBounds.minX - 4 / zoom}
                      y={selectionBounds.minY - 4 / zoom}
                      width={8 / zoom}
                      height={8 / zoom}
                      fill="white"
                      stroke="#00aaff"
                      strokeWidth={1 / zoom}
                      style={{ cursor: 'nwse-resize', pointerEvents: 'auto' }}
                      onPointerDown={(e) => handleDrawing(e, setEraserPos, overlayRef)}
                    />
                    <rect
                      x={selectionBounds.maxX - 4 / zoom}
                      y={selectionBounds.minY - 4 / zoom}
                      width={8 / zoom}
                      height={8 / zoom}
                      fill="white"
                      stroke="#00aaff"
                      strokeWidth={1 / zoom}
                      style={{ cursor: 'nesw-resize', pointerEvents: 'auto' }}
                      onPointerDown={(e) => handleDrawing(e, setEraserPos, overlayRef)}
                    />
                    <rect
                      x={selectionBounds.maxX - 4 / zoom}
                      y={selectionBounds.maxY - 4 / zoom}
                      width={8 / zoom}
                      height={8 / zoom}
                      fill="white"
                      stroke="#00aaff"
                      strokeWidth={1 / zoom}
                      style={{ cursor: 'nwse-resize', pointerEvents: 'auto' }}
                      onPointerDown={(e) => handleDrawing(e, setEraserPos, overlayRef)}
                    />
                    <rect
                      x={selectionBounds.minX - 4 / zoom}
                      y={selectionBounds.maxY - 4 / zoom}
                      width={8 / zoom}
                      height={8 / zoom}
                      fill="white"
                      stroke="#00aaff"
                      strokeWidth={1 / zoom}
                      style={{ cursor: 'nesw-resize', pointerEvents: 'auto' }}
                      onPointerDown={(e) => handleDrawing(e, setEraserPos, overlayRef)}
                    />

                    <foreignObject
                      x={selectionBounds.maxX + 10 / zoom}
                      y={selectionBounds.minY}
                      width={40 / zoom}
                      height={40 / zoom}
                      style={{ overflow: 'visible', pointerEvents: 'auto' }}
                    >
                      <button
                        className="flex items-center justify-center bg-background2 rounded-full text-wrong outline-1 outline-wrong hover:bg-background2-hover transition-colors"
                        style={{
                          width: 32 / zoom,
                          height: 32 / zoom,
                          fontSize: 14 / zoom,
                          pointerEvents: 'auto',
                          cursor: 'pointer'
                        }}
                        onPointerDown={(e) => {
                          e.stopPropagation();
                          const newStrokes = strokes.filter(s => !selectedStrokeIds.includes(s.id));
                          setStrokes(newStrokes);
                          setStrokeHistory(prev => [...prev.slice(0, historyIndex + 1), newStrokes]);
                          setHistoryIndex(prev => prev + 1);
                          setSelectedStrokeIds([]);
                        }}
                      >
                        <FontAwesomeIcon icon={faTrash} />
                      </button>
                    </foreignObject>
                  </>
                )}
              </>
            )}

            {activeSnappingGuides && activeSnappingGuides.map((guide, i) => {
              if (guide.orientation === 'vertical') {
                return (
                  <line
                    key={`guide-${i}`}
                    x1={guide.position}
                    y1={-100000}
                    x2={guide.position}
                    y2={100000}
                    stroke="#ff0044"
                    strokeWidth={1 / zoom}
                    strokeDasharray="4 4"
                    vectorEffect="non-scaling-stroke"
                  />
                );
              } else {
                return (
                  <line
                    key={`guide-${i}`}
                    x1={-100000}
                    y1={guide.position}
                    x2={100000}
                    y2={guide.position}
                    stroke="#ff0044"
                    strokeWidth={1 / zoom}
                    strokeDasharray="4 4"
                    vectorEffect="non-scaling-stroke"
                  />
                );
              }
            })}

            {selectionBox && (
              <rect
                x={selectionBox.x}
                y={selectionBox.y}
                width={selectionBox.width}
                height={selectionBox.height}
                fill="rgba(0, 170, 255, 0.1)"
                stroke="#00aaff"
                strokeWidth={Math.max(1, 1 / zoom)}
                vectorEffect="non-scaling-stroke"
              />
            )}

            {marqueeBox && (
              <rect
                x={marqueeBox.x}
                y={marqueeBox.y}
                width={marqueeBox.width}
                height={marqueeBox.height}
                fill="rgba(0, 170, 255, 0.05)"
                stroke="#00aaff"
                strokeWidth={Math.max(2, 2 / zoom)}
                strokeDasharray="8 4"
                vectorEffect="non-scaling-stroke"
              />
            )}

            {currentPoints.length > 1 && <g><RenderDrawingPath points={currentPoints} zoom={zoom} strokeData={{ lineStyle }} /></g>}

            {showMeasurements && strokes.map(s => {
              const isSelected = selectedStrokeIds.includes(s.id);
              let strokeToCheck = s;
              if (isSelected && dragOffset) {
                strokeToCheck = {
                  ...s,
                  points: s.points.map(p => ({ ...p, x: p.x + dragOffset.x, y: p.y + dragOffset.y }))
                };
              }

              const bounds = getStrokesBoundingBox([strokeToCheck]);
              if (!bounds) return null;
              const width = Math.round(bounds.maxX - bounds.minX);
              const height = Math.round(bounds.maxY - bounds.minY);

              if (width <= 0 && height <= 0) return null;
              if (width < 2 && height < 2) return null;

              return (
                <g key={`measure-${s.id}`}>
                  {width > 0 && (
                    <text
                      x={bounds.minX + (bounds.maxX - bounds.minX) / 2}
                      y={bounds.minY - 10 / zoom}
                      fill="#00aaff"
                      fontSize={12 / zoom}
                      textAnchor="middle"
                      pointerEvents="none"
                      style={{ userSelect: 'none' }}
                    >
                      {width}
                    </text>
                  )}
                  {height > 0 && (
                    <text
                      x={bounds.minX - 10 / zoom}
                      y={bounds.minY + (bounds.maxY - bounds.minY) / 2}
                      fill="#00aaff"
                      fontSize={12 / zoom}
                      textAnchor="end"
                      dominantBaseline="middle"
                      pointerEvents="none"
                      style={{ userSelect: 'none' }}
                    >
                      {height}
                    </text>
                  )}
                </g>
              )
            })}

            {showMeasurements && currentPoints.length > 0 && (() => {
              let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
              for (const p of currentPoints) {
                if (p.x < minX) minX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.x > maxX) maxX = p.x;
                if (p.y > maxY) maxY = p.y;
              }
              if (minX === Infinity) return null;

              const width = Math.round(maxX - minX);
              const height = Math.round(maxY - minY);

              return (
                <g>
                  <text
                    x={minX + width / 2}
                    y={minY - 10 / zoom}
                    fill="#00aaff"
                    fontSize={12 / zoom}
                    textAnchor="middle"
                    pointerEvents="none"
                    style={{ userSelect: 'none' }}
                  >
                    {width}
                  </text>
                  <text
                    x={minX - 10 / zoom}
                    y={minY + height / 2}
                    fill="#00aaff"
                    fontSize={12 / zoom}
                    textAnchor="end"
                    dominantBaseline="middle"
                    pointerEvents="none"
                    style={{ userSelect: 'none' }}
                  >
                    {height}
                  </text>
                </g>
              );
            })()}

            {erasing && eraserPos && (
              <circle
                cx={eraserPos.x}
                cy={eraserPos.y}
                r={brushSize / 2}
                fill="none"
                stroke="white"
                strokeDasharray="4 4"
                strokeWidth={1 / zoom}
                vectorEffect="non-scaling-stroke"
              />
            )}
          </svg>
        )}
      </div>
    </div>
  )
}
</file>

<file path="src/sandbox/_components/notes/CodeBlockComponent.tsx">
import { NodeViewWrapper, ReactNodeViewRenderer } from '@tiptap/react'
import { useCallback, useState } from 'react'
import CodeMirrorEditor from '../editor/CodeMirrorEditor'
import { EditorView } from '@codemirror/view'
import { Node, mergeAttributes } from '@tiptap/core'

export const CustomCodeBlock = Node.create({
  name: 'codeBlock',
  group: 'block',
  atom: true,

  addAttributes() {
    return {
      language: {
        default: 'typescript',
      },
      code: {
        default: '',
      }
    }
  },

  parseHTML() {
    return [
      {
        tag: 'pre',
        getAttrs: (element) => {
          if (typeof element === 'string') return false;
          const code = element.querySelector('code')?.textContent || '';
          const language = element.getAttribute('data-language') || 'typescript';
          return { code, language };
        },
      },
    ]
  },

  renderHTML({ node, HTMLAttributes }) {
    const code = node.attrs.code;
    const codeText = typeof code === 'string' ? code : (code || '');

    return [
      'pre',
      mergeAttributes(HTMLAttributes, {
        'data-language': node.attrs.language || 'typescript',
      }),
      ['code', {}, codeText]
    ]
  },

  addNodeView() {
    return ReactNodeViewRenderer(CodeBlockComponent)
  },

  addCommands() {
    return {
      setCodeBlock: (attributes: any) => ({ commands }: any) => {
        return commands.insertContent({
          type: this.name,
          attrs: attributes,
        })
      },
    }
  },
})

function CodeBlockComponent({ node, updateAttributes, selected }: any) {
  const [language, setLanguage] = useState(node.attrs.language || 'typescript');

  // Ensure we have a stable unique ID for this code block instance
  const [uniqueId] = useState(() => node.attrs.id || `cm-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`);

  // Track whether CodeMirror is focused to hide outline while typing
  const [isFocused, setIsFocused] = useState(false);

  const onChange = useCallback((value: string | undefined) => {
    updateAttributes({ code: value });
  }, [updateAttributes]);

  return (
    <NodeViewWrapper
      className={`code-block my-4 rounded-md overflow-hidden border border-border bg-background shadow-sm ${selected && !isFocused ? 'selected' : ''}`}
      data-code-block-id={uniqueId}
    >
      <div className="flex items-center justify-between bg-background2 px-3 py-1 border-b border-border">
        <select
          contentEditable={false}
          value={language}
          onChange={(e) => {
            setLanguage(e.target.value);
            updateAttributes({ language: e.target.value });
          }}
          onMouseDown={(e) => { e.stopPropagation(); }}
          onClick={(e) => { e.stopPropagation(); }}
          className="bg-transparent text-xs text-text outline-none cursor-pointer"
        >
          <option className='bg-background2' value="typescript">TypeScript</option>
          <option className='bg-background2' value="javascript">JavaScript</option>
          <option className='bg-background2' value="html">HTML</option>
          <option className='bg-background2' value="css">CSS</option>
          <option className='bg-background2' value="json">JSON</option>
          <option className='bg-background2' value="python">Python</option>
        </select>
        {/* <div className="text-xs text-muted-foreground">Monaco Editor</div> */}
      </div>
      <div
        className="relative"
        style={{ minHeight: '50px', display: 'flex', flexDirection: 'column' }}
        contentEditable={false}
        onClick={() => {
          // Activate editing on click
          const codeMirrorView = (window as any).__codeMirrorEditors?.[uniqueId];
          if (codeMirrorView && codeMirrorView.enableEditing) {
            codeMirrorView.enableEditing();
          }
        }}
      >
        <CodeMirrorEditor
          value={node.attrs.code || ''}
          onChange={onChange}
          language={language}
          enableCaretTracking={true}
          preventInitialFocus={true}
          onMount={(view) => {
            // Add enableEditing method to view for external focus
            (view as any).enableEditing = () => {
              view.dispatch({
                effects: (view as any)._editableCompartment?.reconfigure?.(EditorView.editable.of(true))
              })
              view.focus()
            }

            // Store globally for keyboard navigation (like Monaco did)
            (window as any).__codeMirrorEditors = (window as any).__codeMirrorEditors || {};
            (window as any).__codeMirrorEditors[uniqueId] = view;
          }}
          onEscape={() => {
            const tiptapEditor = document.querySelector('.ProseMirror');
            if (tiptapEditor) {
              (tiptapEditor as HTMLElement).focus();
            }
          }}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
        />
      </div>
    </NodeViewWrapper>
  )
}
</file>

<file path="src/sandbox/_components/notes/NoteEditor.tsx">
import { useEditor, EditorContent } from '@tiptap/react'
import { useEffect } from 'react'
import StarterKit from '@tiptap/starter-kit'
import TaskList from '@tiptap/extension-task-list'
import TaskItem from '@tiptap/extension-task-item'
import { NodeSelection } from '@tiptap/pm/state'
import { getCaretPosition, CaretPosition } from '../../_functions/notes/getCaretPosition'
import { PlaceholderPerLine } from '../../_functions/notes/PlaceholderPerLine'

// Styling
import 'src/NoteEditor.css'


import { handleCaretPositionChange } from 'src/sandbox/_functions/notes/handleCaretPosition'
import { CustomCodeBlock } from './CodeBlockComponent'
import { useNotes } from 'src/sandbox/_providers/NotesContextProvider'
import { NoteOptionsVisibleState } from 'src/sandbox/types/NotesOptionsTypes'


type NoteEditorProps = {
  title?: string;
  initialContent?: string | object;
  onUpdate: (content: any) => void;
  isEditable?: boolean;
  onCaretPositionChange?: (position: CaretPosition | null) => void;
}

export default function NoteEditor({ title, initialContent, onUpdate, isEditable = true, onCaretPositionChange }: NoteEditorProps) {

  const handleCaretPosition = handleCaretPositionChange();

  const {
    setNoteOptionsMenuOpen,
    setNoteOptionsMenuPosition,
    setLastActiveEditor
  } = useNotes();

  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        codeBlock: false, // implementation is replaced by CustomCodeBlock
      }),
      CustomCodeBlock,
      PlaceholderPerLine,
      TaskList,
      TaskItem.configure({
        nested: true,
        HTMLAttributes: {
          class: 'task-item',
        },
      }),
    ],
    content: initialContent ? (typeof initialContent === 'string' ? JSON.parse(initialContent) : initialContent) : { type: 'doc', content: [] },
    onUpdate: ({ editor }) => {
      const json = editor.getJSON();
      onUpdate(json);
    },
    editable: isEditable,
    editorProps: {
      attributes: {
        class: 'prose prose-sm dark:prose-invert max-w-none focus:outline-none p-4 min-h-[150px]',
      },
      handleKeyDown: (view, event) => {
        // Only adjust viewport position for navigation keys, not while typing
        const isNavigationKey = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'PageUp', 'PageDown', 'Home', 'End', 'Enter', 'Backspace'].includes(event.key);
        if (isNavigationKey) {
          handleCaretPosition(getCaretPosition(editor));
        }

        const { $anchor } = editor.state.selection;
        const isAtFirstLine = $anchor.parentOffset === 0 && $anchor.parent === editor.state.doc.firstChild;

        //? when removing a line and we are at the top of the note and the note is empty we remove the note
        if (
          event.key === 'Backspace'
          && editor.isEmpty
          && isAtFirstLine
        ) {
          onUpdate(null);
          return true;
        }


        if (event.key == "/") {
          const { state } = editor;
          const { selection } = state;
          const currentNode = $anchor.parent;

          if (currentNode.textContent !== "") { return; }

          const caretPos = getCaretPosition(editor);

          // Save editor and cursor position before opening menu
          setLastActiveEditor({
            editor: editor,
            position: selection.anchor
          });

          setNoteOptionsMenuPosition({
            x: caretPos ? caretPos.absoluteX : 0,
            y: caretPos ? caretPos.absoluteY : 0,
          });
          setNoteOptionsMenuOpen(NoteOptionsVisibleState.OPEN);
          return true;
        }

        if (event.key === 'Enter' && !event.shiftKey) {
          const { state } = view;
          const { selection } = state;

          if (selection instanceof NodeSelection) {
            const node = selection.node;

            if (node && node.type.name === 'codeBlock') {
              setTimeout(() => {
                const selectedCodeBlock = document.querySelector('.code-block.selected');
                const editorId = selectedCodeBlock?.getAttribute('data-code-block-id');

                if (editorId) {
                  const codeMirrorView = (window as any).__codeMirrorEditors?.[editorId];

                  if (codeMirrorView && codeMirrorView.enableEditing) {
                    codeMirrorView.enableEditing();
                  }
                }
              }, 50);
              return true; // Prevent default Enter behavior
            }
          }

          return false;
        }

        return false;
      }
    },
  })

  if (!editor) { return null }

  return (
    <div
      className="note-editor w-full flex flex-col bg-background text-text"
    >
      {/* Toolbar */}
      <div className="flex items-center gap-1 p-2 border-b border-border text-sm font-semibold overflow-x-auto">
        {title || 'Untitled Note'}
      </div>
      <div className="p-4">
        <EditorContent editor={editor} className="prose prose-zinc dark:prose-invert max-w-none focus:outline-none" />
      </div>
    </div>
  )
}
</file>

<file path="src/sandbox/_components/editor/Editor.tsx">
import { faClose, faCode, faPenToSquare } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { useCode } from "src/sandbox/_providers/CodeContextProvider";
import BuilderMenu from "./BuilderMenu";
import CodeEditor from "./CodeEditor";
import { memo, useEffect } from "react";
import { BuilderMenuMode, useBuilderPanel } from "src/sandbox/_providers/BuilderPanelContextProvider";

const Editor = () => {

  const { builderMenuMode, setBuilderMenuMode } = useBuilderPanel();

  const {
    codeWindows,
    setCodeWindows,
    activeCodeWindow,
    setActiveCodeWindow
  } = useCode();

  useEffect(() => {
    if (codeWindows.length === 0) {
      setBuilderMenuMode(BuilderMenuMode.CLOSED);
    }

  }, [builderMenuMode, codeWindows, activeCodeWindow]);

  return (
    <div className="flex-1 flex flex-col overflow-hidden">
      {/* BUILDER MENU CONTENT HERE PLEASE */}
      <div className="w-full pt-2 pr-2 border-b border-border flex">
        <div className="group/tabs flex flex-1 max-w-[calc(100%-100px)] overflow-y-hidden ">
          {codeWindows.map((cw, index) => (
            <div 
              key={index} 
              className={`
                group p-2 flex gap-2 items-center text-text transition-all duration-200 flex-shrink-0 min-w-0 max-w-60
                ${cw.id == activeCodeWindow ? "bg-background" : "cursor-pointer hover:bg-background"}
              `}
              onClick={() => setActiveCodeWindow(cw.id)}
            >
              <img src="/languages/react.png" alt={cw.name} className="w-4 flex-shrink-0" />
              <h1 className="select-none truncate flex-1 min-w-0">
                {cw.name?.includes('.') ? cw.name : `${cw.name || 'Untitled'}.tsx`}
              </h1>
              <div className="flex items-center justify-center flex-shrink-0">
                <div className={`hover:bg-background2 px-0.5 rounded transition-all duration-200 ${cw.id == activeCodeWindow ? "" : "opacity-0 group-hover:opacity-100"} `}>
                  <FontAwesomeIcon
                    className={`cursor-pointer text-muted`}
                    icon={faClose}
                    onClick={(e) => {
                      e.stopPropagation();
                      setActiveCodeWindow(
                        codeWindows[index - 1] ? codeWindows[index - 1].id :
                        codeWindows[index + 1] ? codeWindows[index + 1].id :
                        ""
                      );
                      setCodeWindows(prev => prev.filter(w => w.id !== cw.id))
                    }}
                  />
                </div>
              </div>
            </div>
          ))}
        </div>
        <div className="ml-auto flex">
          <div 
            className={`p-2 gap-2 flex items-center justify-center text-text ${builderMenuMode == BuilderMenuMode.CODE ? "bg-background" : "cursor-pointer hover:bg-background bg-background2"}`}
            onClick={() => setBuilderMenuMode(BuilderMenuMode.CODE)}
          >
            <FontAwesomeIcon
            className="text-text"
            icon={faCode}
            ></FontAwesomeIcon>
            {/* <h1>Code</h1> */}
          </div>
          <div 
            className={`p-2 gap-2 flex items-center justify-center text-text ${builderMenuMode == BuilderMenuMode.BUILDER ? "bg-background" : "cursor-pointer hover:bg-background bg-background2"}`}
            onClick={() => setBuilderMenuMode(BuilderMenuMode.BUILDER)}
          >
            <FontAwesomeIcon
            icon={faPenToSquare}
            ></FontAwesomeIcon>
            {/* <h1>Builder</h1> */}
          </div>
        </div>

      </div>
      <div className="h-full w-full">
        {builderMenuMode === BuilderMenuMode.CODE ? (
          <CodeEditor />
        ) : builderMenuMode === BuilderMenuMode.BUILDER ? (
          <BuilderMenu />
        ) : null}
      </div>
    </div>
  )
}

export default memo(Editor);

          // <div className="flex">
          //   <div 
          //     className={`group py-2 px-4 flex gap-2 items-center border-b-2 transition-border duration-200
          //       ${builderMenuMode === BuilderMenuMode.CODE ? "border-title" : "hover:border-muted border-transparent cursor-pointer"}
          //     `}
          //     onClick={() => { setBuilderMenuMode(BuilderMenuMode.CODE) }}
          //   >
          //     <div 
          //       className="flex gap-2 items-center"
          //     >
          //       <FontAwesomeIcon
          //         icon={faCode}
          //       ></FontAwesomeIcon>
          //       <h1>Code</h1>
          //     </div>
          //     <FontAwesomeIcon
          //       className={`text-muted cursor-pointer hover:text-title ${builderMenuMode == BuilderMenuMode.CODE ? "" : "opacity-0"} group-hover:opacity-100`}
          //       onClick={(e) => { 
          //         e.stopPropagation();
          //         setBuilderMenuMode(BuilderMenuMode.CLOSED);
          //         setActiveCodeWindow(null);
          //       }}
          //       icon={faClose}
          //     ></FontAwesomeIcon>
          //   </div>
          //   <div 
          //     className={`group py-2 px-4 flex gap-2 items-center border-b-2 transition-border duration-200
          //       ${builderMenuMode === BuilderMenuMode.BUILDER ? "border-title" : "hover:border-muted border-transparent cursor-pointer"}
          //     `}
          //     onClick={() => { setBuilderMenuMode(BuilderMenuMode.BUILDER) }}
          //   >
          //     <div 
          //       className="flex gap-2 items-center"
          //     >
          //       <FontAwesomeIcon
          //         icon={faPenToSquare}
          //       ></FontAwesomeIcon>
          //       <h1>Builder</h1>
          //     </div>
          //     <FontAwesomeIcon
          //       className={`text-muted cursor-pointer hover:text-title ${builderMenuMode == BuilderMenuMode.BUILDER ? "" : "opacity-0"} group-hover:opacity-100`}
          //       onClick={(e) => { 
          //         e.stopPropagation();
          //         setBuilderMenuMode(BuilderMenuMode.CLOSED);
          //         setActiveCodeWindow(null);
          //       }}
          //       icon={faClose}
          //     ></FontAwesomeIcon>
          //   </div>
          // </div>
</file>

<file path="src/sandbox/_components/editor/CodeEditor.tsx">
import { useMemo } from "react";
import { useCode } from "../../_providers/CodeContextProvider";
import { useBlueprints } from "../../_providers/BlueprintsContextProvider";
import BaseCodeEditor from "./BaseCodeEditor";

export default function CodeEditor() {
  const {
    activeCodeWindow,
    codeWindows,
    setCurrentEditorInstance,
    setCurrentMonacoInstance
  } = useCode();
  const { blueprints, setBlueprints } = useBlueprints();

  const { code, setCode, language } = useMemo(() => {
    // First, get the language from the code window (where we stored it)
    const activeWindow = codeWindows.find(cw => cw.id === activeCodeWindow);
    const windowLanguage = activeWindow?.language;

    // Find file in blueprints
    const fileItem = blueprints.files?.find(f => f.id === activeCodeWindow);

    if (!fileItem) {
      return {
        code: "",
        setCode: () => { },
        language: "typescript"
      };
    }

    // Determine language - prioritize code window language, then default to typescript
    const lang = windowLanguage || "typescript";

    return {
      code: fileItem.code,
      setCode: (newCode: string) => {
        setBlueprints(prev => ({
          ...prev,
          files: prev.files?.map(f => f.id === activeCodeWindow ? { ...f, code: newCode } : f) || prev.files
        }));
      },
      language: lang
    };
  }, [blueprints, setBlueprints, activeCodeWindow, codeWindows]);

  return (
    <BaseCodeEditor
      value={code}
      onChange={(val) => val && setCode(val)}
      path={`file:///App.${language === 'typescript' ? 'tsx' : language}`}
      language={language}
      onMount={(editor, monaco) => {
        setCurrentEditorInstance(editor);
        if (monaco) {
          setCurrentMonacoInstance(monaco);
        }
      }}
    />
  );
}
</file>

<file path="src/sandbox/_components/menus/CreateComponentMenu.tsx">
import { motion, AnimatePresence } from "framer-motion";
import { useRef } from "react";
import { CreateComponentMenuVisibleState } from "src/sandbox/types/createComponentMenuTypes";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faFileMedical, faNoteSticky, faUpload } from "@fortawesome/free-solid-svg-icons";
import { useMenus } from "src/sandbox/_providers/MenusContextProvider";
import { useBlueprints, GridChange } from "src/sandbox/_providers/BlueprintsContextProvider";
import { useGrid } from "src/sandbox/_providers/GridContextProvider";
import { getFileExtension, getMimeTypeCategory, getMonacoLanguage, readFileAsBase64, readFileAsText, validateFileSize } from "src/sandbox/_functions/files/fileUtils";
import { inputDialog } from "src/_components/InputDialog";

export default function CreateComponentMenu() {

  const {
    createComponentMenuOpen,
    createComponentMenuPosition,
    setCreateComponentMenuOpen
  } = useMenus();

  const { applyChange } = useBlueprints();
  const { zoom, offset } = useGrid();

  const fileInputRef = useRef<HTMLInputElement>(null);

  const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

  // Get world coordinates from menu position
  const getWorldPosition = () => {
    if (!createComponentMenuPosition) return { x: 0, y: 0 };
    return {
      x: (createComponentMenuPosition.x - offset.x) / zoom,
      y: (createComponentMenuPosition.y - offset.y) / zoom
    };
  };

  // Validation function for file names - must have an extension
  const validateFileName = (name: string): string | null => {
    if (!name.trim()) {
      return 'File name is required';
    }

    const extension = getFileExtension(name);
    if (!extension) {
      return 'File name must include an extension (e.g., .txt, .tsx, .js)';
    }

    return null;
  };

  // Handle creating a new file
  const handleCreateFile = async () => {
    // Close the context menu first
    setCreateComponentMenuOpen(CreateComponentMenuVisibleState.CLOSED);

    const result = await inputDialog({
      title: 'Create New File',
      content: 'Enter a file name with extension (e.g., component.tsx)',
      nameLabel: 'File Name',
      namePlaceholder: 'myfile.tsx',
      nameValidation: validateFileName
    });

    if (!result) return; // User cancelled

    const worldPos = getWorldPosition();

    const newFile = {
      id: `file-${Date.now()}`,
      position: worldPos,
      name: result.name,
      code: '', // Empty file
      size: 0,
    };

    const change: GridChange = {
      type: 'create',
      itemType: 'file',
      item: newFile
    };
    applyChange(change);
  };

  // Handle creating a new note
  const handleCreateNote = async () => {
    // Close the context menu first
    setCreateComponentMenuOpen(CreateComponentMenuVisibleState.CLOSED);

    const result = await inputDialog({
      title: 'Add Note',
      nameLabel: 'Title',
      namePlaceholder: 'My Note'
    });

    if (!result) return; // User cancelled

    const worldPos = getWorldPosition();

    // Create initial TipTap JSON content with empty paragraph
    const initialContent = {
      type: 'doc',
      content: [
        { type: 'paragraph' }
      ]
    };

    const newNote = {
      id: `note-${Date.now()}`,
      position: worldPos,
      title: result.name,
      content: JSON.stringify(initialContent),
      width: 300,
      height: 200,
    };

    const change: GridChange = {
      type: 'create',
      itemType: 'note',
      item: newNote
    };
    applyChange(change);
  };

  // Handle file upload from input
  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0 || !createComponentMenuPosition) return;

    const file = files[0];

    // Validate file size
    if (!validateFileSize(file, MAX_FILE_SIZE)) {
      alert(`File size exceeds 5MB limit. File size: ${(file.size / 1024 / 1024).toFixed(2)}MB`);
      return;
    }

    try {
      const fileExtension = getFileExtension(file.name);
      const mimeCategory = getMimeTypeCategory(file.type);
      const monacoLanguage = getMonacoLanguage(fileExtension);

      // Check if the file extension is a known text/code type by checking if Monaco recognizes it
      // This handles cases where browsers don't provide proper MIME types for code files (.tsx, .ts, etc.)
      const isKnownTextExtension = monacoLanguage !== 'plaintext' || fileExtension === 'txt';

      let fileContent: string;

      // Read file based on type - prioritize extension check for code files
      if (isKnownTextExtension || mimeCategory === 'text') {
        fileContent = await readFileAsText(file);
      } else if (mimeCategory === 'image') {
        fileContent = await readFileAsBase64(file);
      } else {
        // Binary files (PDF, ZIP, etc.)
        fileContent = await readFileAsBase64(file);
      }

      const worldPos = getWorldPosition();

      // Create new file blueprint
      const newFile = {
        id: `file-${Date.now()}`,
        position: worldPos,
        name: file.name,
        code: fileContent,
        size: file.size,
      };

      // Add to blueprints with history
      const change: GridChange = {
        type: 'create',
        itemType: 'file',
        item: newFile
      };
      applyChange(change);

      // Close menu
      setCreateComponentMenuOpen(CreateComponentMenuVisibleState.CLOSED);

      // Reset input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    } catch (error) {
      console.error('Error reading file:', error);
      alert('Failed to read file. Please try again.');
    }
  };

  if (!createComponentMenuPosition) { return null; }

  return (
    <AnimatePresence>
      {createComponentMenuOpen == CreateComponentMenuVisibleState.OPEN && (
        <motion.div
          initial={{ opacity: 0, scale: 0.90, y: -5 }}
          animate={{ opacity: 1, scale: 1, y: 0 }}
          exit={{ opacity: 0, scale: 0.90, y: -5 }}
          transition={{ duration: 0.2 }}
          style={{
            position: "absolute",
            zIndex: 1000,
          }}
        >
          <div
            className="bg-background2 rounded gap-3 flex flex-col w-72 shadow-xl border border-border2 text-text"
            style={{
              position: "absolute",
              left: createComponentMenuPosition.x,
              top: createComponentMenuPosition.y,
              transform: 'translate(20px, calc(-100px + -50%))',
            }}
            id="createComponentMenu"
          >
            <div className="flex flex-col gap-2 p-3">
              <div className="text-xs font-bold text-text2 uppercase tracking-wider px-1">
                Create
              </div>
              <div
                className="p-2 hover:bg-background2-hover rounded cursor-pointer"
                onClick={() => fileInputRef.current?.click()}
              >
                <FontAwesomeIcon icon={faUpload} className="text-muted mr-2" />
                Upload File
              </div>
              <div
                className="p-2 hover:bg-background2-hover rounded cursor-pointer"
                onClick={handleCreateFile}
              >
                <FontAwesomeIcon icon={faFileMedical} className="text-muted mr-2" />
                Create New File
              </div>
              <div
                className="p-2 hover:bg-background2-hover rounded cursor-pointer"
                onClick={handleCreateNote}
              >
                <FontAwesomeIcon icon={faNoteSticky} className="text-muted mr-2" />
                Add Note
              </div>
            </div>

            {/* Hidden file input */}
            <input
              ref={fileInputRef}
              type="file"
              onChange={handleFileSelect}
              style={{ display: 'none' }}
            />
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  )
}
</file>

<file path="src/_components/TemplateProvider.tsx">
import { useEffect, useState } from 'react';
import Middleware from 'src/_components/Middleware';
import useRouter from './Router';
import { useLocation } from 'react-router-dom';
import Avatar from './Avatar';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faArrowLeft, faGear, faHome } from '@fortawesome/free-solid-svg-icons';
import { useSession } from '../_providers/SessionProvider';
import ThemeToggler from './ThemeToggler';
import { useSocketStatus } from 'src/_providers/socketStatusProvider';
import { apiRequest } from 'src/_sockets/apiRequest';
import config from "config";
import { GridProvider } from 'src/sandbox/_providers/GridContextProvider';
import Tooltip from './Tooltip';
import { CodeProvider } from 'src/sandbox/_providers/CodeContextProvider';
import { BlueprintsProvider } from 'src/sandbox/_providers/BlueprintsContextProvider';
import { DrawingProvider } from 'src/sandbox/_providers/DrawingContextProvider';
import { MenusProvider } from 'src/sandbox/_providers/MenusContextProvider';
import { BuilderPanelProvider } from 'src/sandbox/_providers/BuilderPanelContextProvider';
import { NotesProvider } from 'src/sandbox/_providers/NotesContextProvider';

const Templates = {
  main: MainTemplate,
  plain: PlainTemplate,
  sandbox: SandboxTemplate,
}
export type Template = 'plain' | 'main' | 'sandbox';

function MainTemplate({ children }: { children: React.ReactNode }) {

  const router = useRouter();
  const location = useLocation();
  const { session } = useSession();

  return (
    <div className="w-full h-full overflow-hidden flex flex-col text-title">

      <div className='w-full flex items-center p-2 bg-background border-border border-b-[1px] gap-4'>

        <div className='h-full flex gap-2 items-center'>
          <div className='min-w-8 max-w-8 h-8 rounded-full overflow-hidden'>
            <img src='/logo.png'></img>
          </div>
          <h1 className='font-semibold text-base line-clamp-1'>{session?.name}</h1>
        </div>

        <div className='h-full flex gap-2 items-center'>
          <div className='min-w-8 max-w-8 h-8'>
            {session && (
              <Avatar user={session} />
            )}
          </div>
          <h1 className='font-semibold text-base line-clamp-1'>{session?.name}</h1>
        </div>

        {/* {session?.location?.previousLocation && session?.location?.previousLocation !== session?.location?.pathName && (
          <Tooltip
            content="Go back to previous page"
            delay={300}
            offsetY={"5px"}
            offsetX={"5px"}
          >
            <button 
              className='p-2 bg-container2 border border-container2-border rounded-md cursor-pointer text-sm'
              onClick={() => {
                router(session.location?.previousLocation || config.loginRedirectUrl)
              }}
            >
              <FontAwesomeIcon icon={faArrowLeft} size='lg' />
            </button>
          </Tooltip>
        )} */}
        {/* 
        <Tooltip
          content={location.pathname == '/home' ? "Go to settings" : "Go to home page"}
          delay={300}
          offsetY={"5px"}
          offsetX={"5px"}
          className={`bg-container2 p-2 text-nowrap border border-container-border rounded`}
        >
          <button 
            className='p-2 bg-container2 border border-container2-border rounded-md cursor-pointer text-sm'
            onClick={() => {
              router(location.pathname == '/home' ? '/settings' : '/home')
            }}
          >
            <FontAwesomeIcon icon={location.pathname == '/home' ? faGear : faHome} size='lg' />
          </button>
        </Tooltip> */}

        {/* <button 
          className='bg-container2 border border-container2-border rounded-md py-2 px-6 cursor-pointer font-semibold'
          onClick={() => apiRequest({ name: 'logout' })}
        >
          Uitloggen
        </button> */}
      </div>

      <div className='overflow-hidden w-full flex-grow'>
        <Middleware>
          {children}
        </Middleware>
      </div>

    </div>
  )
}

function PlainTemplate({ children }: { children: React.ReactNode }) {
  const { updateTheme } = ThemeToggler();

  useEffect(() => {
    updateTheme(config.defaultTheme);
    document.documentElement.classList.toggle("dark", config.defaultTheme === "dark");
  }, [location]);

  return (
    <div className="w-full h-full">
      {children}
    </div>
  )
}

function SandboxTemplate({ children }: { children: React.ReactNode }) {
  const { updateTheme } = ThemeToggler();

  useEffect(() => {
    updateTheme(config.defaultTheme);
    document.documentElement.classList.toggle("dark", config.defaultTheme === "dark");
  }, [location]);

  return (
    <GridProvider>
      <BlueprintsProvider>
        <BuilderPanelProvider>
          <MenusProvider>
            <CodeProvider>
              <DrawingProvider>
                <NotesProvider>
                  <MainTemplate>
                    {children}
                  </MainTemplate>
                </NotesProvider>
              </DrawingProvider>
            </CodeProvider>
          </MenusProvider>
        </BuilderPanelProvider>
      </BlueprintsProvider>
    </GridProvider>
  )
}

export default function TemplateProvider({
  children,
  initialTemplate,
}: {
  children: React.ReactNode;
  initialTemplate: Template;
}) {
  const [template] = useState<Template>(initialTemplate);

  const TemplateComponent = Templates[template] || PlainTemplate;

  const { session } = useSession();
  const location = useLocation();
  const { updateTheme } = ThemeToggler();
  const { socketStatus } = useSocketStatus();

  useEffect(() => {
    if (session?.theme) {
      updateTheme(session.theme);
      document.documentElement.classList.toggle("dark", session.theme === "dark");
    }
  }, [session, location]);

  if (config.dev && config.socketActivityBroadcaster) {
    return (
      <div className='w-full h-full relative'>
        <div className='absolute top-2 right-2 z-50 bg-red-500 text-white px-2 py-1 rounded-md text-xs font-bold'>
          Socket status: {socketStatus.self.status}
          {socketStatus.self.status === "RECONNECTING" && socketStatus.self.reconnectAttempt ? ` (attempt ${socketStatus.self.reconnectAttempt})` : ''}
        </div>
        <TemplateComponent>{children}</TemplateComponent>
      </div>
    );
  }

  return (
    <TemplateComponent>{children}</TemplateComponent>
  );
}
</file>

<file path="src/sandbox/page.tsx">
import Grid from "./_components/grid/Grid";
import Editor from "./_components/editor/Editor";
import useOnMouseDown from "./_functions/grid/onMouseDown";
import { BuilderMenuMode, useBuilderPanel } from "./_providers/BuilderPanelContextProvider";
import { setMenuHandlerRef } from "src/_functions/menuHandler";
import { useMenuHandler } from "src/_components/MenuHandler";

export const template = 'sandbox';
export default function Home() {

  const ref = useMenuHandler();
  setMenuHandlerRef(ref);

  const {
    windowDividerDragging,
    builderMenuMode,
    windowDividerPosition,
  } = useBuilderPanel();

  const { handleWindowDivider } = useOnMouseDown();

  return (
    <div className="h-full w-full">

      <div className="flex h-full w-full relative">

        <div
          id="leftPanel"
          className={`
            h-full w-full bg-background 
            ${windowDividerDragging.current ? "" : "transition-all duration-300"}
          `}
          style={{
            width: builderMenuMode != "CLOSED" ? `${windowDividerPosition || 50}%` : '100%',
          }}
        >

          {/* <div className="flex h-[calc(100%-40px)]"> */}
          <div className="flex h-full">
            <Grid />
          </div>

        </div>

        <div
          className={`bg-background2 h-full w-2 ${builderMenuMode == BuilderMenuMode.CLOSED ? "hidden" : ""} cursor-col-resize`}
          onMouseDown={(e) => handleWindowDivider(e.nativeEvent)}
        ></div>

        <div
          id="rightPanel"
          className={`
            flex flex-col h-full bg-background2 overflow-hidden ${builderMenuMode == BuilderMenuMode.CLOSED ? "" : ""}
            ${windowDividerDragging.current ? "" : "transition-all duration-300"}
          `}
          style={{
            width: builderMenuMode != BuilderMenuMode.CLOSED ? `${100 - (windowDividerPosition || 50)}%` : '0%',
          }}
        >

          <Editor />
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/index.css">
@import "tailwindcss";

@theme {

  --color-background: #171B26;
  --color-background2: #1F2432;

  --color-background-hover: #1C2130;
  --color-background2-hover: #242B3A;

  --color-border: #2B3245;
  --color-border2: #3E465A;

  --color-text: #FFFFFF;
  --color-text2: #8B95A6;
  --color-text3: #6B7384;


  --color-background: #EFF6FF; /* blue-50 */

  --color-container: #FFFFFF; /* white */
  --color-container-border: #E5E7EB; /* gray-200 */
  --color-container-hover: #F3F4F6; /* gray-100 light hover */

  --color-container2: #F8FAFC; /* slate-50 */
  --color-container2-border: #E2E8F0; /* slate-200 */
  --color-container2-hover: #F1F5F9; /* light hover */

  --color-container3: #E5E7EB; /* gray-200 */
  --color-container3-border: #CBD5E1; /* gray-300 */
  --color-container3-hover: #D1D5DB; /* slightly darker */

  --color-container4: #F1F5F9; /* slate-100 */
  --color-container4-border: #E2E8F0; /* gray-200 */
  --color-container4-hover: #E2E8F0; /* slightly darker */

  --color-loadingScreen: #FAF9FF;

  --color-title: #000000; /* black */
  --color-common: #1E293B; /* slate-800 */
  --color-muted: #64748B; /* slate-500 */

  /* Correct / wrong */
  --color-correct: oklch(72.3% 0.219 149.579); /* green-500 */
  --color-correct-hover: oklch(62.7% 0.194 149.214); /* green-600 */

  --color-warning: oklch(79.5% 0.184 86.047); /* yellow-400 */
  --color-warning-hover: oklch(68.1% 0.162 75.834); /* yellow-500 */

  --color-wrong: oklch(63.7% 0.237 25.331); /* red-500 */
  --color-wrong-hover: oklch(57.7% 0.245 27.325); /* red-600 */

  --color-primary: #4f46e5;
  --color-secondary: #475569;

  --background-grid: 
    linear-gradient(90deg, #eee 1px, transparent 1px),
    linear-gradient(#eee 1px, transparent 1px);
  --background-grid-color: #ffffff; /* fallback base background */
}

.dark {
  --color-background: #171B26;
  --color-background2: #1F2432;

  --color-background-hover: #1E2230; /* 1C2130 */
  --color-background2-hover: #2A3042; /* 242B3A */

  --color-border: #2B3245;
  --color-border2: #3E465A;

  --color-text: #FFFFFF;
  --color-text2: #8B95A6;
  --color-text3: #6B7384;

  --color-correct: oklch(72.3% 0.219 149.579); /* green-500 */
  --color-correct-hover: oklch(62.7% 0.194 149.214); /* green-600 */

  --color-warning: oklch(79.5% 0.184 86.047); /* yellow-400 */
  --color-warning-hover: oklch(68.1% 0.162 75.834); /* yellow-500 */

  --color-wrong: oklch(63.7% 0.237 25.331); /* red-500 */
  --color-wrong-hover: oklch(57.7% 0.245 27.325); /* red-600 */

  --color-primary: #4f46e5;
  --color-secondary: #475569;

  --background-grid: #171B26;
  --background-grid-color: #171B26;
  --background-grid-old: 
    linear-gradient(90deg, #555 1px, transparent 1px),
    linear-gradient(#555 1px, transparent 1px);
}

.dark2 {
  --color-background: #10131B;          /* gray-900 */

  --color-container: #171B26; /* gray-800 */
  --color-container-border: #374151; /* gray-700 */
  --color-container-hover: #3F4B63; /* slightly lighter dark hover */

  --color-container2: #202636; /* gray-700 */
  --color-container2-border: #4B5563; /* gray-600 */
  --color-container2-hover: #565E72;

  --color-container3: #4B5563; /* gray-600 */
  --color-container3-border: #6B7280; /* gray-500 */
  --color-container3-hover: #727985;

  --color-container4: #1F2937; /* gray-800 */
  --color-container4-border: #374151; /* gray-700 */
  --color-container4-hover: #CBD5E1;

  --color-title: #FFFFFF;               /* white */
  --color-common: oklch(92.8% 0.006 264.531);              /* gray-200 */
  --color-muted: oklch(70.7% 0.022 261.325);               /* gray-400 */

  --color-correct: oklch(72.3% 0.219 149.579); /* green-500 */
  --color-correct-hover: oklch(62.7% 0.194 149.214); /* green-600 */

  --color-warning: oklch(79.5% 0.184 86.047); /* yellow-400 */
  --color-warning-hover: oklch(68.1% 0.162 75.834); /* yellow-500 */

  --color-wrong: oklch(63.7% 0.237 25.331); /* red-500 */
  --color-wrong-hover: oklch(57.7% 0.245 27.325); /* red-600 */

  --color-primary: oklch(62.3% 0.214 259.815); /* blue-500 */
  --color-primary-hover: oklch(67.3% 0.234 260.815);

  --background-grid: 
    linear-gradient(90deg, #555 1px, transparent 1px),
    linear-gradient(#555 1px, transparent 1px);
  --background-grid-color: #191d24cc; /* base background for dark mode */
}

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: white;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  /* Prevent overscroll bounce and improve touchpad panning */
  overscroll-behavior: none;
}

@layer utilities {
  .h-safe {
    height: calc(var(--vh, 1vh) * 100);
  }
  
  .bg-grid {
    background: var(--background-grid);
    background-color: var(--background-grid-color);
    background-size: 20px 20px; /* adjust grid spacing */
  }
}

/* ? tiny inline color box */
[class^="tw-color-"]::before {
  content: "";
  display: inline-block;
  width: 0.75em;
  height: 0.75em;
  border-radius: 2px;
  margin-right: 3px;
  transform: translateY(1px);
}

.inlineColorIcon {
  min-width: 12px;
  width: 12px;
  max-width: 12px;

  min-height: 12px;
  height: 12px;
  max-height: 12px;

  transform: translateY(50%);

  display: inline-block;
  border: white 1px solid;
}

.inlineColorIconGap {
  min-width: 3px;
  max-width: 3px;

  min-height: 3px;
  max-height: 3px;

  display: inline-block;
}
</file>

<file path="src/sandbox/_components/grid/Grid.tsx">
import { useEffect, useState } from "react";
import { useGrid } from "../../_providers/GridContextProvider";
import CreateComponentMenu from "../menus/CreateComponentMenu";
import { blueprints, file } from "../../types/blueprints";
import { useBlueprints } from "../../_providers/BlueprintsContextProvider";
import DrawingLayer from "../drawing/DrawingLayer";
import BottomLeftMenu from "../menus/BottomLeftMenu";
import DrawingSideMenu from "../drawing/DrawingSideMenu";
import DrawingTopMenu from "../drawing/DrawingTopMenu";
import Note from "../notes/Note";
import File from "../files/File";
import useOnMouseDown from "src/sandbox/_functions/grid/onMouseDown";
import useOnMouseUp from "src/sandbox/_functions/grid/onMouseUp";
import useOnMouseMove from "src/sandbox/_functions/grid/onMouseMove";
import useOnMouseWheel from "src/sandbox/_functions/grid/onMouseWheel";
import useOnFileDrop from "src/sandbox/_functions/grid/onFileDrop";
import { useGridKeyboardShortcuts } from "src/sandbox/_functions/grid/useGridKeyboardShortcuts";
import { isBabelCompatible } from "src/sandbox/_functions/files/babelUtils";
import NoteOptionsMenu from "../menus/NoteOptionsMenu";
import Render from "../files/Render";
import { Viewports } from "src/sandbox/types/viewportMapping";

const dummyData = {
  files: [
    {
      id: "view1",
      name: "View1.tsx",
      position: { x: 100, y: 100 },
      viewport: Viewports.LAPTOP,
      code:
        `import React, { useState, useEffect } from "react";
export default function View1() {

  const [name, setName] = useState("Mike")

  useEffect(() => {
    console.log(name)
  }, [name])

  return (
    <div className={"bg-blue-500"}>
      <div>hey {name}!!</div>
      <button 
        className="px-6 py-2"
        onClick={() => {setName(prev => prev == 'Mike' ? 'Jimbo' : 'Mike')}}
      >
        Click me
      </button>
    </div>
  );
}`
    },
    {
      id: "view2",
      name: "View2.tsx",
      position: { x: 1300, y: 1300 },
      // viewport: { width: 1440, height: 900, enabled: true },
      viewport: Viewports.TABLET,
      code: `
import React from "react";
export default function View2() {
  return <div>View 2</div>;
  return <div>View 2</div>;
  return <div>View 2</div>;
  return <div>View 2</div>;
}
      `
    },
    {
      id: "comp1",
      name: "Component1.tsx",
      position: { x: 2000, y: 100 },
      code: `
import React from "react";
export default function Component1() {
  return <div>Component 1</div>;
  return <div>Component 1</div>;
  return <div>Component 1</div>;
  return <div>Component 1</div>;
}
      `
    },
  ],
  notes: [
    {
      id: "note1",
      position: { x: 1900, y: 600 },
      title: "Project Notes",
      width: 400,
      height: 300,
      content: JSON.stringify({
        type: 'doc',
        content: [
          { type: 'heading', attrs: { level: 1 }, content: [{ type: 'text', text: 'Project Notes' }] },
          { type: 'paragraph', content: [{ type: 'text', text: 'Here is a sample note with a code block:' }] },
          { type: 'codeBlock', attrs: { language: 'typescript', code: "console.log('Hello World');" } }
        ]
      })
    }
  ],
  drawings: [],
}

export default function Grid() {
  const {
    containerRef,
    dragging,
    zoom,
    offset
  } = useGrid();


  const {
    blueprints,
    setBlueprints,
  } = useBlueprints();

  // Load initial data (dummy for now, from DB in future)
  // Uses setBlueprints directly since this is initial load, not a user action
  useEffect(() => {
    // For initial load, we set blueprints directly (no history entry)
    // In future: this will come from DB via socket sync
    setBlueprints(dummyData as blueprints);
  }, [])

  const [showZoom, setShowZoom] = useState(false);

  useEffect(() => {
    setShowZoom(true);
  }, [zoom]);

  useEffect(() => {
    if (!showZoom) { return; }
    const timeout = setTimeout(() => setShowZoom(false), 1000);
    return () => clearTimeout(timeout);
  }, [showZoom, zoom]);

  // Using the new hook approach
  useOnMouseWheel(); // Sets up wheel event listener internally
  useGridKeyboardShortcuts(); // Grid-level Ctrl+Z/Y for undo/redo
  const { handleMouseMove } = useOnMouseMove();
  const { handleOnMouseUp } = useOnMouseUp();
  const { handleMouseDown } = useOnMouseDown();
  const { handleDragOver, handleDrop } = useOnFileDrop();

  const [dragOver, setDragOver] = useState(false);

  // Calculate grid style values
  const spacing = zoom > 1 ? 50 : 100;
  const opacity = 0.2;
  const isLineGrid = zoom > 1;
  const snappedSize = Math.round(spacing * zoom);
  const snappedOffsetX = Math.round(offset.x);
  const snappedOffsetY = Math.round(offset.y);
  const dotSize = Math.max(1, Math.min(2, zoom * 2));

  return (
    //* THIS DIV IS THE GRID BACKGROUND
    <div
      style={{
        width: "100%",
        overflow: "hidden",
        position: "relative",
        cursor: dragging ? "grabbing" : "",

        // Prevent browser overscroll bounce and touch gesture interference
        overscrollBehavior: "none",
        touchAction: "none",

        // Use CSS variables for dynamic values to avoid expensive style recalculations
        // This prevents lag when DevTools Elements tab is open
        ['--grid-size' as string]: `${snappedSize}px`,
        ['--grid-offset-x' as string]: `${snappedOffsetX}px`,
        ['--grid-offset-y' as string]: `${snappedOffsetY}px`,
        ['--grid-opacity' as string]: opacity,
        ['--dot-size' as string]: `${dotSize}px`,

        backgroundSize: 'var(--grid-size) var(--grid-size)',
        backgroundPosition: 'var(--grid-offset-x) var(--grid-offset-y)',
        backgroundImage: isLineGrid
          ? `linear-gradient(rgba(255,255,255,var(--grid-opacity)) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,var(--grid-opacity)) 1px, transparent 1px)`
          : `radial-gradient(circle, rgba(255,255,255,var(--grid-opacity)) var(--dot-size), transparent var(--dot-size))`,
      }}
      className="bg-grid h-full"
      ref={containerRef}
      onContextMenu={(e) => e.preventDefault()} //? makes it so we cant open the menu on right click
      onMouseDown={(e) => handleMouseDown(e.nativeEvent)}
      onMouseUp={(e) => handleOnMouseUp(e.nativeEvent, false)}
      onMouseLeave={(e) => handleOnMouseUp(e.nativeEvent, true)}
      onMouseMove={(e) => handleMouseMove(e.nativeEvent)}
      onDragOver={(e) => {
        handleDragOver(e.nativeEvent);
        setDragOver(true);
      }}
      onDragLeave={() => setDragOver(false)}
      onDrop={(e) => {
        handleDrop(e.nativeEvent);
        setDragOver(false);
      }}
    >

      {/* percentage */}
      <div className={`absolute top-2 border border-border ${showZoom ? 'opacity-100' : 'opacity-0'} z-50 transition-all duration-200 left-2 bg-background text-text text-sm px-4 py-1 rounded`}>
        {(zoom * 100).toString().endsWith(".5") ? (zoom * 100).toFixed(1) : (zoom * 100).toFixed(0)}%
      </div>

      <div className="pointer-events-auto">
        <BottomLeftMenu />

        <CreateComponentMenu />

        <NoteOptionsMenu />

        <DrawingSideMenu />

        <DrawingTopMenu />
      </div>

      {/* //* THIS DIV MAKES IT SO THE PANNING AND ZOOMING AFFECTS THE CONTENT */}
      <div
        className="h-full w-full"
        style={{
          transform: `translate(${offset.x}px, ${offset.y}px) scale(${zoom})`,
          transformOrigin: "0 0",
          position: "absolute",
          top: 0,
          left: 0,
        }}
      >
        {/* Notes Layer */}
        {blueprints.notes.map((note) => (
          <Note key={note.id} note={note} />
        ))}

        {/* Files Layer - renders both code modules and uploaded files */}
        {blueprints.files?.map((file) => {
          // Check file type and view mode (with null safety)
          const isBabelFile = file.name ? isBabelCompatible(file.name) : false;

          const shouldRenderAsScreen = isBabelFile && file.viewMode === 'rendered';

          if (shouldRenderAsScreen && isBabelFile) {
            return <Render
              key={file.id}
              file={file}
              setFile={(update: Partial<file>) => {
                setBlueprints(prev => ({
                  ...prev,
                  files: prev.files.map(f =>
                    f.id === file.id
                      ? {
                        ...f,
                        ...update
                      }
                      : f
                  )
                }))
              }
              }
            />;
          } else {
            // Render as file card
            return <File key={file.id} fileBlueprint={file} />;
          }
        })}

        {blueprints.drawings.map(() => {
          // instance is type drawing
          return null; // render nothing
        })}
      </div>

      {/* Drag-and-drop visual indicator */}
      {dragOver && (
        <div
          className="absolute inset-0 pointer-events-none border-4 border-dashed border-primary bg-primary/10 z-50"
          style={{
            borderRadius: '8px',
          }}
        />
      )}

      <DrawingLayer />

    </div>
  )
}
</file>

<file path="package.json">
{
  "name": "lucky-stack-v2",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "client": "tsx scripts/clearServerRequests.ts && vite --host",
    "server": "npx tsx server/server.ts",
    "liveServer": "npx tsx --watch server/server.ts",
    "lint": "eslint src/**/*.tsx",
    "buildClient": "tsc -b && vite build",
    "buildServer": "tsx scripts/generateServerRequests.ts && tsx scripts/bundleServer.ts",
    "build": "tsx scripts/generateServerRequests.ts && npm run buildClient && tsx scripts/bundleServer.ts",
    "prod": "node dist/server.js",
    "production": "node dist/server.js"
  },
  "dependencies": {
    "@babel/standalone": "^7.28.5",
    "@codemirror/commands": "^6.10.1",
    "@codemirror/lang-css": "^6.3.1",
    "@codemirror/lang-html": "^6.4.11",
    "@codemirror/lang-javascript": "^6.2.4",
    "@codemirror/lang-json": "^6.0.2",
    "@codemirror/lang-python": "^6.2.1",
    "@codemirror/language": "^6.12.1",
    "@codemirror/language-data": "^6.5.2",
    "@codemirror/state": "^6.5.3",
    "@codemirror/view": "^6.39.7",
    "@fortawesome/fontawesome-svg-core": "^7.0.1",
    "@fortawesome/free-brands-svg-icons": "^7.0.1",
    "@fortawesome/free-regular-svg-icons": "^7.0.1",
    "@fortawesome/free-solid-svg-icons": "^7.0.1",
    "@fortawesome/react-fontawesome": "^3.0.2",
    "@lezer/highlight": "^1.2.3",
    "@monaco-editor/react": "^4.7.0",
    "@prisma/client": "^6.5.0",
    "@tailwindcss/container-queries": "^0.1.1",
    "@tailwindcss/language-server": "^0.14.29",
    "@tailwindcss/postcss": "^4.0.17",
    "@tailwindcss/typography": "^0.5.19",
    "@tensorflow/tfjs": "^4.22.0",
    "@tiptap/extension-placeholder": "^3.14.0",
    "@tiptap/extension-task-item": "^3.14.0",
    "@tiptap/extension-task-list": "^3.14.0",
    "@tiptap/react": "^3.14.0",
    "@tiptap/starter-kit": "^3.14.0",
    "@tldraw/tldraw": "^4.2.0",
    "@uiw/react-codemirror": "^4.25.2",
    "bcrypt": "^5.1.1",
    "chokidar": "^4.0.3",
    "cors": "^2.8.5",
    "culori": "^4.0.2",
    "dotenv": "^16.4.7",
    "framer-motion": "^12.23.24",
    "fs": "^0.0.1-security",
    "ioredis": "^5.6.0",
    "jsonwebtoken": "^9.0.2",
    "lucide-react": "^0.540.0",
    "monaco-editor": "^0.55.1",
    "monaco-editor-textmate": "^4.0.0",
    "monaco-languageclient": "^10.2.0",
    "monaco-tailwindcss": "^0.6.1",
    "monaco-textmate": "github:NeekSandhu/monaco-textmate",
    "normalize-url": "^8.1.0",
    "path": "^0.12.7",
    "perfect-freehand": "^1.2.2",
    "react": "^19.0.0",
    "react-colorful": "^5.6.1",
    "react-dom": "^19.0.0",
    "react-router-dom": "^7.4.0",
    "repl": "^0.1.3",
    "sharp": "^0.34.3",
    "socket.io": "^4.8.1",
    "socket.io-client": "^4.8.1",
    "sonner": "^2.0.2",
    "tldraw": "^4.2.0",
    "url": "^0.11.4",
    "uuid": "^11.1.0",
    "validator": "^13.15.0",
    "vconsole": "^3.15.1",
    "vite-typescript-starter": "github:caleb1248/monaco-vscode-textmate#main",
    "vscode-oniguruma": "^2.0.1",
    "vscode-textmate": "^9.2.1",
    "vscode-ws-jsonrpc": "^3.5.0",
    "ws": "^8.18.3",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@eslint/js": "^9.21.0",
    "@rollup/plugin-alias": "^5.1.1",
    "@types/bcrypt": "^5.0.2",
    "@types/react": "^19.2.2",
    "@types/react-dom": "^19.2.2",
    "@types/validator": "^13.15.1",
    "@vitejs/plugin-react-swc": "^3.8.0",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.21.0",
    "eslint-plugin-react-dom": "^1.48.4",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "eslint-plugin-react-x": "^1.48.4",
    "globals": "^15.15.0",
    "postcss": "^8.5.6",
    "prisma": "^6.5.0",
    "tailwindcss": "^4.1.11",
    "tsx": "^4.19.3",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.24.1",
    "vite": "^6.2.0",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
</file>

</files>
